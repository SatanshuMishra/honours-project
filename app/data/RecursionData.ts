const recursion: {
  topic: string;
  bloomTaxonomyCategory: string;
  difficulty: number;
  question: string;
  code?: string;
  answersList: string[];
  correctAnswerIndex: number;
  explanationsList: string[];
}[] = [
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "In programming, what is recursion and how does it work?",
    answersList: [
      "A programming technique where a function solves a problem by calling itself with simpler versions of the same problem",
      "A programming technique where a function calls any other function",
      "A programming technique where one function can only be called by another function",
      "A programming technique where a function calls itself infinitely",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Recursion solves problems by breaking them down into smaller, similar subproblems",
      "This describes function calls in general, not specifically recursion",
      "Recursion is about self-referential calls, not about being called by other functions",
      "Proper recursion must have a way to stop (base case) to avoid infinite loops",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question: "What is a base case in recursion, and why is it essential?",
    answersList: [
      "The stopping condition that prevents infinite recursion and provides the final answer",
      "The initial condition that starts the recursive process",
      "A condition that counts the number of recursive calls",
      "A condition that validates if recursion is possible",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The base case is crucial as it defines when to stop recursion and return a final result",
      "Base cases stop recursion, they don't start it",
      "Base cases don't count recursive calls - they end them",
      "Base cases aren't for validation - they provide termination conditions",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "In mathematics and programming, what is the factorial of 0 (written as 0!)?",
    answersList: ["1", "0", "Infinity", "Error - factorial is undefined for 0"],
    correctAnswerIndex: 0,
    explanationsList: [
      "By mathematical definition, 0! equals 1. This is essential for factorial calculations",
      "Many assume 0! = 0, but this is incorrect",
      "0! is a defined value, not infinity",
      "0! is well-defined in mathematics as 1",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "What essential component must all recursive algorithms include to work correctly?",
    answersList: [
      "A base case that stops the recursion",
      "Multiple solution paths",
      "Less memory usage than loops",
      "Linear time complexity",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Without a base case, recursive algorithms would continue indefinitely",
      "Recursive algorithms don't require multiple solution paths",
      "Memory usage varies and isn't a defining characteristic",
      "Time complexity depends on the specific algorithm",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 4,
    question:
      "What is tail recursion and how is it different from regular recursion?",
    answersList: [
      "A recursive function where the recursive call is the final operation, with no pending calculations afterward",
      "A recursive function that doesn't need a base case",
      "A recursive function that always calls itself first",
      "A recursive function that never reaches its base case",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Tail recursion is optimized because no stack frame needs to be maintained after the recursive call",
      "All recursion needs a base case, including tail recursion",
      "The position of the recursive call matters, not just being first",
      "All proper recursion must reach a base case eventually",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "What will this recursive function return when called with sum(4)?",
    code: "int sum(int n) {\n  if (n <= 0) return 0;\n  return n + sum(n - 1);\n}",
    answersList: ["10", "6", "4", "0"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The function adds all numbers from n down to 1: 4 + 3 + 2 + 1 + 0 = 10",
      "The function doesn't skip numbers in the sequence",
      "The function accumulates values, not just returns n",
      "0 is just the base case, not the final result",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Which data structure is most naturally implemented and traversed using recursion?",
    answersList: [
      "Trees (because each node can branch into multiple subnodes)",
      "Stacks (because of their last-in-first-out nature)",
      "Queues (because of their first-in-first-out nature)",
      "Arrays (because of their sequential nature)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Trees are recursive by nature - each subtree is a smaller version of the same structure",
      "Stacks are typically implemented iteratively",
      "Queues are typically implemented iteratively",
      "Arrays are linear and typically handled iteratively",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "What is the time complexity of this recursive Fibonacci function and why?",
    code: "int fibonacci(int n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answersList: [
      "O(2^n), because each call creates two more recursive calls",
      "O(n^2), because it uses nested recursion",
      "O(log n), because it divides the problem",
      "O(n), because it counts down to 1",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each function call branches into two more calls, creating an exponential tree of calls",
      "The complexity grows faster than quadratic",
      "The problem size doesn't divide in half each time",
      "The branching nature makes it grow faster than linear",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What will this recursive function print for printDigits(123)?",
    code: "void printDigits(int n) {\n  if (n < 10) {\n    System.out.print(n);\n    return;\n  }\n  printDigits(n / 10);\n  System.out.print(n % 10);\n}",
    answersList: ["123", "321", "0", "1"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The function prints digits in order: first 1, then 2, then 3",
      "The function prints in forward order, not reverse",
      "The function prints all digits, not just 0",
      "The function prints all digits, not just 1",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "What is memoization in recursive algorithms and why is it useful?",
    answersList: [
      "A optimization technique that stores previously calculated results to avoid redundant computations",
      "A technique to prevent infinite recursion",
      "A way to make recursive code simpler to write",
      "A method to ensure recursion always stops",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Memoization significantly improves performance by avoiding repeated calculations",
      "Memoization is for optimization, not preventing infinite recursion",
      "Memoization may actually make code more complex",
      "Memoization improves efficiency but doesn't ensure termination",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "What will this recursive power function return when called with power(2, 3)?",
    code: "int power(int base, int exponent) {\n  if (exponent == 0) {\n    return 1;\n  }\n  return base * power(base, exponent - 1);\n}\n",
    answersList: ["8", "6", "1", "0"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The function multiplies 2 by itself 3 times: 2 × 2 × 2 = 8",
      "Addition is not used in this power calculation",
      "1 is only returned for exponent 0",
      "0 is never returned by this function",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "What is the most significant practical limitation when implementing recursive solutions?",
    answersList: [
      "Stack memory limitations",
      "CPU usage",
      "Code readability",
      "Algorithm complexity",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each recursive call adds to the call stack, which has a fixed size - too many calls can crash the program",
      "CPU usage is typically not the primary limitation in recursive solutions",
      "While recursion can be complex, modern practices make it manageable",
      "Algorithm complexity is independent of whether recursion is used",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question: "What will this function return for gcd(12, 18)?",
    code: "int gcd(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n",
    answersList: ["6", "3", "1", "0"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Using Euclid's algorithm, this calculates the greatest common divisor as 6",
      "3 is a common divisor but not the greatest",
      "1 would indicate the numbers are coprime, which they aren't",
      "0 is never the GCD of positive numbers",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "What makes tail recursion more efficient than regular recursion?",
    answersList: [
      "Stack frame optimization",
      "Execution speed",
      "Time complexity",
      "Compilation efficiency",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Tail recursion enables stack frame reuse, preventing stack overflow in optimizing compilers",
      "Speed improvements aren't guaranteed in all cases",
      "Time complexity remains the same - only memory usage is optimized",
      "Compilation time is not affected by tail recursion",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 4,
    question: "How does memoization improve recursive algorithms?",
    answersList: [
      "Result caching",
      "Stack management",
      "Memory allocation",
      "Algorithm restructuring",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "By caching results, memoization prevents recalculating the same values repeatedly",
      "Memoization doesn't directly manage the call stack",
      "Memoization actually uses more memory to store results",
      "The algorithm structure remains unchanged - only computation is optimized",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "Which data structure is most efficiently implemented using recursion?",
    answersList: ["Binary trees", "Hash tables", "Stacks", "Queues"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Tree operations (traversal, insertion, deletion) map naturally to recursive solutions",
      "Hash tables are better implemented iteratively",
      "Stacks are typically implemented iteratively",
      "Queues are typically implemented iteratively",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 4,
    question:
      "What will this recursive factorial function return for factorial(3)?",
    code: "int factorial(int n) {\n  if (n == 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}\n",
    answersList: ["6", "3", "1", "0"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The function recursively multiplies: 3 × 2 × 1 = 6",
      "This would ignore the multiplication steps",
      "This is only returned for factorial(0)",
      "The function never returns 0",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Which statement about recursive and iterative solutions is accurate?",
    answersList: [
      "All recursive solutions can be rewritten iteratively",
      "Recursive solutions always use less memory",
      "Iterative solutions cannot solve recursive problems",
      "Recursive solutions are always faster",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Any recursive solution can be transformed into an iterative one using a stack",
      "Recursive solutions often use more memory due to stack frames",
      "Iterative solutions can solve the same problems as recursive ones",
      "Performance depends on the specific problem and implementation",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What will this countdown function print?",
    code: 'void countDown(int n) {\n  if (n == 0) {\n    return;\n  }\n  System.out.print(n + " ");\n  countDown(n - 1);\n}\ncountDown(5);',
    answersList: ["5 4 3 2 1", "1 2 3 4 5", "0", "5 4 3 2 1 0"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Prints each number before recursive call, stopping at 1",
      "Numbers would print in ascending order",
      "Zero is never printed due to the base case check",
      "Zero is not printed due to the base case return",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "In a recursive algorithm, what role does the recursive case serve?",
    answersList: [
      "Problem reduction",
      "Error handling",
      "Memory management",
      "Loop control",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Breaks down the problem into smaller, similar subproblems",
      "Error handling is separate from the recursive case",
      "Memory management is handled by the system",
      "Loop control is a concept from iteration, not recursion",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question: "What will this Fibonacci function return for fibonacci(6)?",
    code: "public static int fibonacci(int n) {\n  if (n <= 1)\n    return n;\n  else\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n",
    answersList: ["8", "13", "21", "34"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Fibonacci sequence: 0,1,1,2,3,5,8 - so f(6)=8",
      "13 is f(7)",
      "21 is f(8)",
      "34 is f(9)",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Which implementation correctly calculates a factorial recursively?",
    code: "// Option A:\npublic int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\n// Option B:\npublic int factorial(int n) {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\n// Option C:\npublic int factorial(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return factorial(n - 1);\n}\n\n// Option D:\npublic int factorial(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n",
    answersList: ["Option A", "Option B", "Option C", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Correctly handles base case (n≤1) and recursive multiplication",
      "Incorrectly returns 0 for factorial(0)",
      "Missing the multiplication step in recursion",
      "Incorrect base case handling",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "When solving programming problems, what is the key benefit of choosing recursion over iteration?",
    answersList: [
      "Code expression",
      "Memory usage",
      "Processing speed",
      "Input handling",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "For certain problems, recursive solutions can express the algorithm more naturally and clearly",
      "Recursion typically uses more memory due to stack frames",
      "Speed depends on specific implementation and compiler optimization",
      "Large inputs can actually be problematic for recursive solutions",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      'What will this recursive string reversal function return for reverse("hello")?',
    code: "public static String reverse(String str) {\n  if (str.isEmpty())\n    return str;\n  else\n    return reverse(str.substring(1)) + str.charAt(0);\n}\n",
    answersList: ["olleh", "hello", "eh", "olle"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each recursive call moves one character to its reversed position",
      "This would be the original string without reversal",
      "This would be an incomplete reversal",
      "This would be missing the first character",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question: "What will this digit sum function return for sumDigits(123)?",
    code: "public static int sumDigits(int n) {\n  if (n == 0)\n    return 0;\n  else\n    return n % 10 + sumDigits(n / 10);\n}\n",
    answersList: ["6", "5", "3", "1"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each recursive call adds one digit: 3 + 2 + 1 = 6",
      "This would skip one of the digits",
      "This would only count the last digit",
      "This would only count the first digit",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      'What will this palindrome checker return for isPalindrome("racecar")?',
    code: "public static boolean isPalindrome(String str) {\n  if (str.length() <= 1)\n    return true;\n  else if (str.charAt(0) != str.charAt(str.length() - 1))\n    return false;\n  else\n    return isPalindrome(str.substring(1, str.length() - 1));\n}\n",
    answersList: ["true", "false", "error", "undefined"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Checks matching pairs from outside in, confirming palindrome",
      "Would indicate non-matching character pairs",
      "The function is properly defined and won't throw errors",
      "The function always returns a boolean value",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What will this digit counter return for countDigits(12345)?",
    code: "public static int countDigits(int n) {\n  if (n == 0)\n    return 0;\n  else\n    return 1 + countDigits(n / 10);\n}\n",
    answersList: ["5", "4", "3", "2"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Counts each digit through recursive division by 10",
      "Would miss counting one digit",
      "Would miss counting two digits",
      "Would miss counting three digits",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What happens if a recursive function has no base case?",
    answersList: [
      "Stack overflow",
      "Immediate return",
      "Single execution",
      "Null result",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Without a stopping condition, calls continue until stack space is exhausted",
      "The function would need a base case to return immediately",
      "Without a base case, calls continue beyond one execution",
      "Missing base case affects termination, not return value type",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 2,
    question: "Which scenario is most naturally solved using recursion?",
    answersList: [
      "Directory traversal",
      "Array summation",
      "List iteration",
      "Bubble sort",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Tree-like structures match recursive problem decomposition",
      "Linear structures are often more efficient with loops",
      "Linear scanning is typically better with iteration",
      "Bubble sort is naturally iterative",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question: "What will this factorial function return for factorial(5)?",
    code: "public static int factorial(int n) {\n  if (n <= 1)\n    return 1;\n  else\n    return n * factorial(n - 1);\n}\n",
    answersList: ["120", "125", "25", "100"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Multiplies: 5 × 4 × 3 × 2 × 1 = 120",
      "Would be 5³",
      "Would be 5 × 5",
      "Would be missing some multiplications",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 4,
    question:
      "Which implementation correctly calculates the Fibonacci sequence?",
    code: "// Option A:\npublic int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Option B:\npublic int fibonacci(int n) {\n    if (n <= 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Option C:\npublic int fibonacci(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Option D:\npublic int fibonacci(int n) {\n    if (n <= 1)\n        return 0;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n",
    answersList: ["Option A", "Option B", "Option C", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles all cases correctly with minimal base case checking",
      "Has redundant base case checking",
      "Incorrect base case return value",
      "Incorrect base case condition",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question: "What determines the maximum recursion depth in Java?",
    answersList: [
      "Stack configuration",
      "Hardware limits",
      "JVM version",
      "Code complexity",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Available stack memory and JVM settings determine maximum depth",
      "Hardware affects overall performance but not directly recursion depth",
      "JVM version doesn't directly limit recursion depth",
      "Code complexity affects performance but not maximum depth",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Which underlying data structure makes recursion possible in programming languages?",
    answersList: ["Stack", "Queue", "Array", "Linked List"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Function calls are managed on a stack, enabling the recursive process",
      "Queues process items in FIFO order, unsuitable for recursion",
      "Arrays store data but don't manage function calls",
      "Linked lists can be traversed recursively but don't manage the calls",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question: "What is memoization's role in recursive algorithms?",
    answersList: [
      "Result storage",
      "Stack management",
      "Depth control",
      "Loop conversion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stores computed results to avoid duplicate calculations",
      "Stack management is handled by the runtime system",
      "Depth is controlled by base cases, not memoization",
      "Converting to loops is a different optimization technique",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "Which step is NOT part of the recursive problem-solving approach?",
    answersList: ["Iteration", "Divide", "Conquer", "Combine"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Iteration is an alternative to recursion, not a step within it",
      "Divide splits the problem into smaller parts",
      "Conquer solves the smaller subproblems",
      "Combine merges solutions back together",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "What role does the return statement play in recursive functions?",
    answersList: [
      "Value propagation",
      "Loop termination",
      "Memory allocation",
      "Variable scope",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Passes calculated results back up through the call chain",
      "Return statements don't control looping in recursion",
      "Memory is managed by the runtime system",
      "Scope is handled by the function structure",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Which type of problem would be least suitable for a recursive solution?",
    answersList: [
      "Sequential database search",
      "Tree traversal",
      "Factorial calculation",
      "Array sorting",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Linear searches are more efficient with simple loops",
      "Trees have a natural recursive structure",
      "Factorial has a clear recursive definition",
      "Many efficient sorting algorithms use recursion",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What is the main function of the call stack in recursion?",
    answersList: [
      "Context tracking",
      "Data storage",
      "Code execution",
      "Error handling",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Maintains the state and variables for each function call",
      "Primary data storage happens in program memory",
      "Execution is managed by the processor",
      "Errors are handled by exception mechanisms",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 1,
    question:
      "What distinguishes a well-designed recursive solution from a poorly designed one?",
    answersList: [
      "Problem reduction",
      "Variable count",
      "Function length",
      "Return types",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each recursive call should meaningfully reduce the problem size",
      "Number of variables doesn't indicate recursive quality",
      "Function length isn't a determining factor",
      "Return type doesn't affect recursive design quality",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "What specific error occurs when recursive calls exceed the stack's capacity?",
    answersList: [
      "Stack overflow",
      "Null reference",
      "Memory leak",
      "Type mismatch",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Exceeding stack space results in a stack overflow error",
      "Null references occur from invalid pointer operations",
      "Memory leaks happen from unfreed heap allocations",
      "Type mismatches result from incompatible data types",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "How does the divide-and-conquer strategy relate to recursive problem solving?",
    answersList: [
      "Problem decomposition",
      "Data aggregation",
      "Resource allocation",
      "Error handling",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Breaks larger problems into smaller, similar subproblems",
      "Combining data isn't the primary focus",
      "Resource management is a separate concern",
      "Error handling is independent of the strategy",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "In recursive algorithms, how do local variables behave across different recursive calls?",
    answersList: [
      "Independent copies",
      "Shared values",
      "Global access",
      "Static storage",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each recursive call maintains its own set of local variables",
      "Values aren't shared between different recursive calls",
      "Local variables don't have global scope",
      "Variables aren't static across recursive calls",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 1,
    question: "Which factorial implementation correctly handles the base case?",
    code: "// Option A:\npublic int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\n// Option B:\npublic int factorial(int n) {\n    if (n == 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\n// Option C:\npublic int factorial(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n * factorial(n - 1);\n}\n\n// Option D:\npublic int factorial(int n) {\n    return n * factorial(n - 1);\n}\n",
    answersList: ["Option A", "Option B", "Option C", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles 0! correctly and has proper termination",
      "Fails for input of 0",
      "Returns incorrect result for 0!",
      "No base case, causes infinite recursion",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "Which array sum implementation is most efficient?",
    code: "// Option A:\npublic int sum(int[] arr, int index) {\n    if (index < 0)\n        return 0;\n    return arr[index] + sum(arr, index - 1);\n}\n\n// Option B:\npublic int sum(int[] arr, int index) {\n    if (index >= arr.length)\n        return 0;\n    return arr[index] + sum(arr, index + 1);\n}\n\n// Option C:\npublic int sum(int[] arr, int start, int end) {\n    if (start > end)\n        return 0;\n    int mid = (start + end) / 2;\n    return sum(arr, start, mid) + sum(arr, mid + 1, end);\n}\n\n// Option D:\npublic int sum(int[] arr, int index) {\n    if (index == arr.length - 1)\n        return arr[index];\n    return arr[index] + sum(arr, index + 1);\n}\n",
    answersList: ["Option D", "Option A", "Option B", "Option C"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Minimizes stack frames and has clear termination",
      "Uses unnecessary comparisons",
      "Does extra bounds checking",
      "Unnecessarily divides the problem",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question: "Which string reversal implementation is most efficient?",
    code: "// Option A:\npublic String reverse(String str) {\n    if (str.isEmpty())\n        return str;\n    return reverse(str.substring(1)) + str.charAt(0);\n}\n\n// Option B:\npublic String reverse(String str) {\n    if (str.length() <= 1)\n        return str;\n    return str.charAt(str.length()-1) + \n           reverse(str.substring(0, str.length()-1));\n}\n\n// Option C:\npublic String reverse(String str, int start, int end) {\n    if (start >= end)\n        return str;\n    char[] chars = str.toCharArray();\n    char temp = chars[start];\n    chars[start] = chars[end];\n    chars[end] = temp;\n    return reverse(new String(chars), start + 1, end - 1);\n}\n\n// Option D:\npublic String reverse(String str) {\n    if (str.length() <= 1)\n        return str;\n    int mid = str.length() / 2;\n    return reverse(str.substring(mid)) + \n           reverse(str.substring(0, mid));\n}\n",
    answersList: ["Option B", "Option A", "Option C", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Minimizes string operations and memory usage",
      "Creates more intermediate strings",
      "Unnecessarily converts to char array",
      "Performs unnecessary splits",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Which implementation for finding array maximum is most efficient?",
    code: "// Option A:\npublic int findMax(int[] arr, int index) {\n    if (index == arr.length - 1)\n        return arr[index];\n    return Math.max(arr[index], findMax(arr, index + 1));\n}\n\n// Option B:\npublic int findMax(int[] arr, int start, int end) {\n    if (start == end)\n        return arr[start];\n    int mid = (start + end) / 2;\n    return Math.max(findMax(arr, start, mid),\n                   findMax(arr, mid + 1, end));\n}\n\n// Option C:\npublic int findMax(int[] arr, int index) {\n    if (index < 0)\n        return Integer.MIN_VALUE;\n    return Math.max(arr[index], findMax(arr, index - 1));\n}\n\n// Option D:\npublic int findMax(int[] arr, int index, int maxSoFar) {\n    if (index >= arr.length)\n        return maxSoFar;\n    return findMax(arr, index + 1,\n                  Math.max(maxSoFar, arr[index]));\n}\n",
    answersList: ["Option D", "Option A", "Option B", "Option C"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses tail recursion and maintains running maximum",
      "Makes redundant comparisons",
      "Unnecessarily divides the array",
      "Uses less intuitive backwards traversal",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "Which permutation generation implementation is most memory efficient?",
    code: "// Option A:\npublic void permute(String prefix, String str) {\n    if (str.length() == 0)\n        System.out.println(prefix);\n    for (int i = 0; i < str.length(); i++)\n        permute(prefix + str.charAt(i),\n               str.substring(0, i) + str.substring(i + 1));\n}\n\n// Option B:\npublic void permute(char[] str, int l, int r) {\n    if (l == r)\n        System.out.println(new String(str));\n    for (int i = l; i <= r; i++) {\n        swap(str, l, i);\n        permute(str, l + 1, r);\n        swap(str, l, i);\n    }\n}\n\n// Option C:\npublic void permute(List<Character> chars, String current) {\n    if (chars.isEmpty())\n        System.out.println(current);\n    for (int i = 0; i < chars.size(); i++) {\n        Character c = chars.remove(i);\n        permute(chars, current + c);\n        chars.add(i, c);\n    }\n}\n\n// Option D:\npublic void permute(StringBuilder str, int index) {\n    if (index == str.length())\n        System.out.println(str);\n    for (int i = index; i < str.length(); i++) {\n        swap(str, index, i);\n        permute(str, index + 1);\n        swap(str, index, i);\n    }\n}\n",
    answersList: ["Option B", "Option A", "Option C", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses in-place swapping with minimal memory overhead",
      "Creates new strings on each recursion",
      "List operations add overhead",
      "StringBuilder operations are unnecessary",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "Which palindrome checking implementation is most efficient?",
    code: "// Option A:\npublic boolean isPalindrome(String str) {\n    if (str.length() <= 1) return true;\n    if (str.charAt(0) != str.charAt(str.length() - 1))\n        return false;\n    return isPalindrome(str.substring(1, str.length() - 1));\n}\n\n// Option B:\npublic boolean isPalindrome(String str, int start, int end) {\n    if (start >= end) return true;\n    if (str.charAt(start) != str.charAt(end))\n        return false;\n    return isPalindrome(str, start + 1, end - 1);\n}\n\n// Option C:\npublic boolean isPalindrome(char[] str, int start, int end) {\n    if (start >= end) return true;\n    if (str[start] != str[end]) return false;\n    return isPalindrome(str, start + 1, end - 1);\n}\n\n// Option D:\npublic boolean isPalindrome(String str) {\n    if (str.length() <= 1) return true;\n    int mid = str.length() / 2;\n    return isPalindrome(str.substring(0, mid)) &&\n           isPalindrome(str.substring(mid));\n}\n",
    answersList: ["Option B", "Option A", "Option C", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses indices without creating new strings",
      "Creates new substrings unnecessarily",
      "Array conversion adds overhead",
      "Incorrectly splits the problem",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 1,
    question:
      "What sequence will this ascending number printer produce for mystery(3)?",
    code: 'public static void mystery(int n) {\n    if (n > 0) {\n        mystery(n - 1);\n        System.out.print(n + " ");\n    }\n}\n',
    answersList: ["1 2 3", "3 2 1", "3 3 3", "1 1 1"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Prints after recursive call, creating ascending order",
      "Would require print before recursive call",
      "Would require different recursive logic",
      "Would require different base case",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question:
      'What will this string reversal function return for mystery("hello", 0)?',
    code: 'public static String mystery(String s, int index) {\n    if (index == s.length())\n        return "";\n    return mystery(s, index + 1) + s.charAt(index);\n}\n',
    answersList: ["olleh", "hello", "h", "o"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Concatenates chars after recursive call, reversing string",
      "Would need concatenation before recursive call",
      "Would need different base case",
      "Would need different return logic",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question: "What will this odd number summer return for mystery(5)?",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    return n + mystery(n - 2);\n}\n",
    answersList: ["9", "15", "5", "25"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Sums odd numbers: 5 + 3 + 1 = 9",
      "Would include even numbers",
      "Would only return input",
      "Would include squares",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "What value will this division-based recursion return for mystery(4)?",
    code: "public int mystery(int n) {\n    if (n == 0)\n        return 1;\n    return mystery(n / 2);\n}\n",
    answersList: ["1", "2", "4", "8"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Always returns 1 when reaching base case: 4→2→1→0→1",
      "Would need multiplication in return",
      "Would need different base case",
      "Would need different recursive step",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question: "What will this function return for mystery(3, -3)?",
    code: "public int mystery(int n, int m) {\n    if (n <= 0)\n        return 0;\n    if (m > n)\n        return n * mystery(n - 1, m);\n    return mystery(n - 1, m);\n}\n",
    answersList: ["6", "3", "0", "9"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Multiplies numbers > m: 3 × 2 × 1 = 6",
      "Would only return input",
      "Would hit base case immediately",
      "Would include additional multiplications",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Which subset generation implementation correctly handles all cases?",
    code: "// Option A:\npublic void generateSubsets(int[] nums, int index,\n                          List<Integer> subset,\n                          List<List<Integer>> result) {\n    result.add(new ArrayList<>(subset));\n    for (int i = index; i < nums.length; i++) {\n        subset.add(nums[i]);\n        generateSubsets(nums, i + 1, subset, result);\n        subset.remove(subset.size() - 1);\n    }\n}\n\n// Option B:\npublic void generateSubsets(int[] nums, int index,\n                          List<List<Integer>> result) {\n    if (index == nums.length) {\n        result.add(new ArrayList<>());\n        return;\n    }\n    generateSubsets(nums, index + 1, result);\n    int n = result.size();\n    for (int i = 0; i < n; i++) {\n        List<Integer> subset = new ArrayList<>(result.get(i));\n        subset.add(nums[index]);\n        result.add(subset);\n    }\n}\n\n// Option C:\npublic void generateSubsets(int[] nums, int index,\n                          List<Integer> current) {\n    if (index == nums.length) {\n        System.out.println(current);\n        return;\n    }\n    generateSubsets(nums, index + 1, current);\n    current.add(nums[index]);\n    generateSubsets(nums, index + 1, current);\n    current.remove(current.size() - 1);\n}\n",
    answersList: ["Option A", "Option B", "Option C", "All are correct"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses backtracking correctly and maintains subset state",
      "Inefficient duplicate list creation",
      "Prints instead of collecting results",
      "Each has different limitations",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "Which implementation for sum of array elements is most efficient?",
    code: "// Option A:\npublic int sum(int[] arr, int index) {\n    if (index < 0) return 0;\n    return arr[index] + sum(arr, index - 1);\n}\n\n// Option B:\npublic int sum(int[] arr, int start, int end) {\n    if (start > end) return 0;\n    int mid = (start + end) / 2;\n    return sum(arr, start, mid) + \n           sum(arr, mid + 1, end);\n}\n\n// Option C:\npublic int sum(int[] arr, int index, int total) {\n    if (index >= arr.length) return total;\n    return sum(arr, index + 1, total + arr[index]);\n}\n\n// Option D:\npublic int sum(int[] arr, int start, int end) {\n    if (start == end) return arr[start];\n    return arr[start] + sum(arr, start + 1, end);\n}\n",
    answersList: ["Option C", "Option A", "Option B", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses tail recursion with accumulator",
      "Creates unnecessary stack frames",
      "Unnecessarily divides the array",
      "No accumulator optimization",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question: "Which GCD implementation handles negative numbers correctly?",
    code: "// Option A:\npublic int gcd(int a, int b) {\n    if (b == 0) return Math.abs(a);\n    return gcd(b, a % b);\n}\n\n// Option B:\npublic int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, Math.abs(a % b));\n}\n\n// Option C:\npublic int gcd(int a, int b) {\n    a = Math.abs(a); b = Math.abs(b);\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n// Option D:\npublic int gcd(int a, int b) {\n    if (a < 0 || b < 0) return -1;\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n",
    answersList: ["Option C", "Option A", "Option B", "Option D"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles negatives at start and maintains Euclidean algorithm",
      "May give incorrect signs",
      "Modulo operation needs abs first",
      "Unnecessarily rejects negative inputs",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question: "Which parentheses generation implementation is most efficient?",
    code: '// Option A:\npublic void generate(int n, int open, int close,\n                    String curr, List<String> result) {\n    if (curr.length() == 2 * n) {\n        result.add(curr);\n        return;\n    }\n    if (open < n)\n        generate(n, open + 1, close, curr + "(", result);\n    if (close < open)\n        generate(n, open, close + 1, curr + ")", result);\n}\n\n// Option B:\npublic void generate(int n, int open, int close,\n                    StringBuilder curr, List<String> result) {\n    if (curr.length() == 2 * n) {\n        result.add(curr.toString());\n        return;\n    }\n    if (open < n) {\n        curr.append("(");\n        generate(n, open + 1, close, curr, result);\n        curr.setLength(curr.length() - 1);\n    }\n    if (close < open) {\n        curr.append(")");\n        generate(n, open, close + 1, curr, result);\n        curr.setLength(curr.length() - 1);\n    }\n}\n\n// Option C:\npublic void generate(int n, char[] curr, int pos,\n                    int open, int close, List<String> result) {\n    if (close == n) {\n        result.add(new String(curr));\n        return;\n    }\n    if (open < n) {\n        curr[pos] = \'(\';\n        generate(n, curr, pos + 1, open + 1, close, result);\n    }\n    if (close < open) {\n        curr[pos] = \')\';\n        generate(n, curr, pos + 1, open, close + 1, result);\n    }\n}\n',
    answersList: ["Option B", "Option A", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses StringBuilder for efficient string manipulation",
      "Creates new strings on each recursion",
      "Array conversion overhead",
      "Performance differences are significant",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Which longest increasing subsequence implementation is most optimal?",
    code: "// Option A:\npublic int lis(int[] arr, int index, int prev) {\n    if (index == arr.length) return 0;\n    int include = 0;\n    if (prev < arr[index])\n        include = 1 + lis(arr, index + 1, arr[index]);\n    int exclude = lis(arr, index + 1, prev);\n    return Math.max(include, exclude);\n}\n\n// Option B:\npublic int lis(int[] arr, int index, int prev,\n               Integer[][] memo) {\n    if (index == arr.length) return 0;\n    if (memo[index][prev + 1] != null)\n        return memo[index][prev + 1];\n    \n    int include = 0;\n    if (prev == -1 || arr[prev] < arr[index])\n        include = 1 + lis(arr, index + 1, index, memo);\n    int exclude = lis(arr, index + 1, prev, memo);\n    return memo[index][prev + 1] = Math.max(include, exclude);\n}\n\n// Option C:\npublic int lis(int[] arr) {\n    int[] dp = new int[arr.length];\n    Arrays.fill(dp, 1);\n    \n    for(int i = 1; i < arr.length; i++)\n        for(int j = 0; j < i; j++)\n            if(arr[i] > arr[j])\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n    \n    return Arrays.stream(dp).max().getAsInt();\n}\n",
    answersList: ["Option B", "Option A", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses memoization to avoid redundant calculations",
      "Has exponential time complexity",
      "Iterative approach loses flexibility",
      "Performance differences are significant",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question: "Which combination generation approach is most memory efficient?",
    code: "// Option A:\npublic void combine(String s, int index,\n                   String current,\n                   List<String> result) {\n    result.add(current);\n    for (int i = index; i < s.length(); i++)\n        combine(s, i + 1,\n               current + s.charAt(i),\n               result);\n}\n\n// Option B:\npublic void combine(String s, int index,\n                   StringBuilder current,\n                   List<String> result) {\n    result.add(current.toString());\n    for (int i = index; i < s.length(); i++) {\n        current.append(s.charAt(i));\n        combine(s, i + 1, current, result);\n        current.setLength(current.length() - 1);\n    }\n}\n\n// Option C:\npublic void combine(char[] s, int index,\n                   boolean[] used,\n                   List<String> result) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < used.length; i++)\n        if (used[i]) sb.append(s[i]);\n    result.add(sb.toString());\n    \n    for (int i = index; i < s.length; i++) {\n        used[i] = true;\n        combine(s, i + 1, used, result);\n        used[i] = false;\n    }\n}\n",
    answersList: ["Option B", "Option A", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses StringBuilder with backtracking",
      "Creates new strings unnecessarily",
      "Extra boolean array overhead",
      "Memory usage differences matter",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Which implementation of a recursive palindrome checker has the best space complexity and why?",
    code: "// Option A:\npublic boolean isPalindrome(String s) {\n    if (s.length() <= 1) return true;\n    return s.charAt(0) == s.charAt(s.length() - 1) &&\n           isPalindrome(s.substring(1, s.length() - 1));\n}\n\n// Option B:\npublic boolean isPalindrome(String s, int start, int end) {\n    if (start >= end) return true;\n    return s.charAt(start) == s.charAt(end) &&\n           isPalindrome(s, start + 1, end - 1);\n}\n\n// Option C:\npublic boolean isPalindrome(String s) {\n    if (s.length() <= 1) return true;\n    String sub = s.substring(1, s.length() - 1);\n    return s.charAt(0) == s.charAt(s.length() - 1) &&\n           isPalindrome(sub);\n}\n",
    answersList: ["Option B", "Option A", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Uses pointers instead of creating new strings: O(1) extra space besides call stack",
      "Creates new substring on each call: O(n) extra space",
      "Explicitly stores substring: O(n) extra space",
      "Space complexity differences are significant",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question:
      "Which array reversal implementation achieves the optimal balance of time and space complexity?",
    code: "// Option A:\npublic void reverse(int[] arr, int start, int end) {\n    if (start >= end) return;\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverse(arr, start + 1, end - 1);\n}\n\n// Option B:\npublic int[] reverse(int[] arr) {\n    if (arr.length <= 1) return arr;\n    int[] left = Arrays.copyOfRange(arr, 0, arr.length/2);\n    int[] right = Arrays.copyOfRange(arr, arr.length/2, arr.length);\n    return concatenate(reverse(right), reverse(left));\n}\n\n// Option C:\npublic void reverse(int[] arr) {\n    reverseHelper(arr, 0, arr.length - 1);\n}\n\nprivate void reverseHelper(int[] arr, int left, int right) {\n    if (left < right) {\n        swap(arr, left, right);\n        reverseHelper(arr, left + 1, right - 1);\n    }\n}\n",
    answersList: ["Option A", "Option B", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "In-place reversal with O(n) time and O(n) stack space",
      "Creates unnecessary arrays: O(n log n) space",
      "Extra function call overhead",
      "Performance characteristics differ significantly",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "What is the key difference in time complexity between these GCD implementations?",
    code: "// Option A:\npublic int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n// Option B:\npublic int gcd(int a, int b) {\n    if (a == b) return a;\n    if (a > b) return gcd(a - b, b);\n    return gcd(a, b - a);\n}\n\n// Option C:\npublic int gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n",
    answersList: [
      "log(min(a,b)) vs linear",
      "log(max(a,b)) vs constant",
      "quadratic vs linear",
      "All same complexity",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Option A uses modulo for logarithmic time, B uses subtraction for linear time",
      "None achieve constant time",
      "None have quadratic complexity",
      "Different approaches have different complexities",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "Trace this recursive call stack step by step. What values are computed when calling factorial(4)?",
    code: 'public int factorial(int n) {\n    System.out.println("Calling factorial(" + n + ")");\n    if (n <= 1)\n        return 1;\n    int result = n * factorial(n - 1);\n    System.out.println("factorial(" + n + ") returns " + result);\n    return result;\n}\n',
    answersList: ["4→3→2→1→1←2←6←24", "4→12→24→1", "24←12←4←1", "4→3→2→1→24"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Shows complete call stack flow down and back up",
      "Misses intermediate calculations",
      "Shows only return values",
      "Misses return path calculations",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Trace this GCD computation sequence. What intermediate values are calculated for gcd(48, 18)?",
    code: 'public int gcd(int a, int b) {\n    System.out.printf("gcd(%d, %d)%n", a, b);\n    if (b == 0)\n        return a;\n    int remainder = a % b;\n    System.out.printf("remainder: %d%n", remainder);\n    return gcd(b, remainder);\n}\n',
    answersList: [
      "48,18→18,12→12,6→6,0",
      "48,18→30,18→12,6",
      "48,18→30→12→6",
      "48→18→12→6",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Shows each step with remainder calculation",
      "Missing last step to base case",
      "Missing intermediate values",
      "Missing remainder calculations",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question:
      'Analyze the execution flow of this palindrome checker. What is the sequence of recursive calls for "level"?',
    code: 'public boolean isPalindrome(String s) {\n    System.out.println("Checking \'" + s + "\'");\n    if (s.length() <= 1)\n        return true;\n    boolean firstLast = s.charAt(0) == s.charAt(s.length()-1);\n    System.out.println(s.charAt(0) + " vs " + s.charAt(s.length()-1));\n    return firstLast && isPalindrome(s.substring(1, s.length()-1));\n}\n',
    answersList: ["level→eve→v", "l→e→v→e→l", "level→leve→lev", "l,l→e,e→v"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Shows string reduction at each step",
      "Shows character sequence incorrectly",
      "Shows incorrect reduction pattern",
      "Misses string context",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question: "Which recursive design pattern does this function demonstrate?",
    code: "// Pattern A:\npublic int sum(int[] arr, int n) {\n    if (n <= 0) return 0;\n    return arr[n-1] + sum(arr, n-1);\n}\n\n// Pattern B:\npublic void print(int n) {\n    if (n <= 0) return;\n    print(n-1);\n    System.out.println(n);\n}\n\n// Pattern C:\npublic int search(int[] arr, int l, int r, int x) {\n    if (l > r) return -1;\n    int mid = (l + r) / 2;\n    if (arr[mid] == x) return mid;\n    if (arr[mid] > x)\n        return search(arr, l, mid-1, x);\n    return search(arr, mid+1, r, x);\n}\n",
    answersList: [
      "Linear reduction",
      "Divide and conquer",
      "Tree recursion",
      "Mutual recursion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Reduces problem size by 1 in each step",
      "Would split into subproblems",
      "Would have multiple recursive calls",
      "Would involve multiple functions",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "What makes this implementation eligible for tail-call optimization?",
    code: "// Version A:\npublic int factorial(int n, int acc) {\n    if (n <= 1) return acc;\n    return factorial(n-1, n * acc);\n}\n\n// Version B:\npublic int factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n-1);\n}\n\n// Version C:\npublic int factorial(int n) {\n    return factHelper(n, 1);\n}\nprivate int factHelper(int n, int result) {\n    if (n <= 1) return result;\n    return factHelper(n-1, n * result);\n}\n",
    answersList: [
      "Uses accumulator parameter",
      "Has single recursive call",
      "Uses helper function",
      "Has simple base case",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Accumulator eliminates need for pending operations",
      "Single call alone doesn't enable optimization",
      "Helper function isn't the key factor",
      "Base case complexity is unrelated",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question: "How does this recursive solution manage stack space?",
    code: "// Approach A:\npublic String reverse(String str) {\n    if (str.isEmpty()) return str;\n    return reverse(str.substring(1)) + str.charAt(0);\n}\n\n// Approach B:\npublic void reverse(char[] str, int start, int end) {\n    if (start >= end) return;\n    char temp = str[start];\n    str[start] = str[end];\n    str[end] = temp;\n    reverse(str, start + 1, end - 1);\n}\n\n// Approach C:\npublic String reverse(String str) {\n    StringBuilder result = new StringBuilder();\n    reverseHelper(str, str.length() - 1, result);\n    return result.toString();\n}\n\nprivate void reverseHelper(String str, int i,\n                          StringBuilder result) {\n    if (i < 0) return;\n    result.append(str.charAt(i));\n    reverseHelper(str, i - 1, result);\n}\n",
    answersList: [
      "In-place modification",
      "String concatenation",
      "StringBuilder growth",
      "Character copying",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Modifies array directly without extra space",
      "Creates new strings on each call",
      "Grows result incrementally",
      "Requires additional storage",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 1,
    question:
      "What's wrong with this recursive function that's meant to print numbers from n down to 1?",
    code: "public void printNumbers(int n) {\n    System.out.println(n);\n    printNumbers(n-1);\n}\n",
    answersList: [
      "Missing base case",
      "Wrong print statement",
      "Incorrect parameter",
      "Wrong return type",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "No termination condition leads to infinite recursion",
      "Print statement location isn't the issue",
      "Parameter decrement is correct",
      "Void return type is appropriate",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Convert this iterative function to a recursive one. What would be the correct base case?",
    code: "// Iterative version:\npublic int sumOfDigits(int n) {\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n",
    answersList: ["n < 10", "n == 0", "sum == 0", "n % 10 == 0"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Single digit numbers don't need further processing",
      "Would miss the last digit",
      "Sum isn't part of base case",
      "Wouldn't handle all numbers",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "This recursive function should count vowels in a string. Find the error:",
    code: "public int countVowels(String str) {\n    if (str.length() == 0)\n        return 0;\n    char first = str.charAt(0);\n    if (isVowel(first))\n        return countVowels(str.substring(1));\n    return countVowels(str.substring(1));\n}\n",
    answersList: [
      "Missing increment",
      "Wrong base case",
      "Incorrect substring",
      "Wrong parameter",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Should add 1 when vowel is found",
      "Empty string base case is correct",
      "Substring handling is correct",
      "Parameter is appropriate",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Looking at this call tree, what will be printed for printPattern(3)?",
    code: 'public void printPattern(int n) {\n    if (n <= 0) return;\n    System.out.print(n + " ");\n    printPattern(n-1);\n    System.out.print(n + " ");\n}\n\n/* Call tree:\n   print(3)\n   ├── print "3"\n   ├── print(2)\n   │   ├── print "2"\n   │   ├── print(1)\n   │   │   ├── print "1"\n   │   │   ├── print(0) returns\n   │   │   └── print "1"\n   │   └── print "2"\n   └── print "3"\n*/',
    answersList: ["3 2 1 1 2 3", "3 2 1 3 2 1", "1 2 3 3 2 1", "3 3 2 2 1 1"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Follows tree: down then back up",
      "Would print in wrong order",
      "Would print smallest first",
      "Would print duplicates wrong",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "A student wants to count files in a directory and its subdirectories. Which recursive approach is most appropriate?",
    code: "// Option A:\npublic int countFiles(File dir) {\n    if (!dir.isDirectory()) return 1;\n    return 1 + Arrays.stream(dir.listFiles())\n             .mapToInt(this::countFiles)\n             .sum();\n}\n\n// Option B:\npublic int countFiles(File dir) {\n    if (dir.isFile()) return 1;\n    int count = 0;\n    for (File f : dir.listFiles())\n        count += countFiles(f);\n    return count;\n}\n\n// Option C:\npublic int countFiles(File dir) {\n    if (!dir.exists()) return 0;\n    if (dir.isFile()) return 1;\n    int count = 0;\n    for (File f : dir.listFiles())\n        if (f.isFile()) count++;\n    return count;\n}\n",
    answersList: ["Option B", "Option A", "Option C", "All work equally"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Correctly handles both files and directories recursively",
      "Counts directories as files incorrectly",
      "Misses subdirectory contents",
      "They have different behaviors",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "What would be the appropriate base case(s) for a recursive binary search?",
    answersList: [
      "Element found or search range empty",
      "Array length is zero",
      "Middle element check only",
      "Element not found",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Covers both success and failure conditions",
      "Misses found element case",
      "Insufficient termination condition",
      "Misses success case",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "This function should print a pyramid pattern recursively. What's wrong?",
    code: 'public void printPyramid(int n) {\n    if (n <= 0) return;\n    printPyramid(n-1);\n    for(int i = 0; i < n; i++)\n        System.out.print("*");\n}\n',
    answersList: [
      "Missing line breaks",
      "Wrong base case",
      "Incorrect loop",
      "Wrong recursion order",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Needs println() for pyramid shape",
      "Base case is correct",
      "Loop prints correct stars",
      "Recursion builds correctly",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Why will this power calculation function fail for some inputs?",
    code: "public int power(int base, int exp) {\n    if (exp == 0)\n        return 1;\n    return base * power(base, exp - 1);\n}\n",
    answersList: [
      "Negative exponents",
      "Zero base",
      "Large exponents",
      "Decimal results",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "No handling of negative exponents",
      "Zero base works correctly",
      "Integer overflow is different issue",
      "Int return type is appropriate",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      "Complete this recursive method to insert commas in a large number (e.g., '1234567' → '1,234,567')",
    code: "public String addCommas(String num) {\n    // Base case\n    if (num.length() <= 3)\n        return num;\n    \n    // Your recursive case here\n    return ________;\n}\n",
    answersList: [
      'addCommas(num.substring(0, num.length()-3)) + "," + num.substring(num.length()-3)',
      'num.substring(0, 3) + "," + addCommas(num.substring(3))',
      'addCommas(num.substring(3)) + "," + num.substring(0, 3)',
      '"," + addCommas(num.substring(0, num.length()-3)) + num.substring(num.length()-3)',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Correctly processes from right to left",
      "Would place commas wrong",
      "Would reverse the number",
      "Would start with comma",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question:
      "What pattern of stars (*) will this recursive function print for n=3?",
    code: 'public void printPattern(int n) {\n    if (n <= 0) return;\n    for(int i = 0; i < n; i++)\n        System.out.print("*");\n    System.out.println();\n    printPattern(n-1);\n    for(int i = 0; i < n; i++)\n        System.out.print("*");\n    System.out.println();\n}\n',
    answersList: [
      "***\n**\n*\n*\n**\n***",
      "***\n**\n*\n***\n**\n*",
      "*\n**\n***\n***\n**\n*",
      "*\n**\n***\n*\n**\n***",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Decreases then increases pattern",
      "Wrong return pattern",
      "Wrong initial pattern",
      "Wrong overall pattern",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "What will this stair-climbing visualization print for climbStairs(3)?",
    code: 'public void climbStairs(int n) {\n    if (n <= 0) {\n        System.out.println("🏁"); // Reached ground\n        return;\n    }\n    System.out.println("🦶" + "_".repeat(n-1) + "⬆");\n    climbStairs(n-1);\n    System.out.println("🦶" + "_".repeat(n-1) + "⬇");\n}\n\n/* Example for n=2:\n🦶_⬆  // Starting second step\n🦶⬆   // Starting first step\n🏁    // Ground\n🦶⬇   // Returning from first step\n🦶_⬇  // Returning from second step\n*/',
    answersList: [
      "🦶__⬆\n🦶_⬆\n🦶⬆\n🏁\n🦶⬇\n🦶_⬇\n🦶__⬇",
      "🦶⬆\n🦶_⬆\n🦶__⬆\n🏁\n🦶__⬇\n🦶_⬇\n🦶⬇",
      "🦶__⬆\n🦶_⬆\n🦶⬆\n🏁\n🦶__⬇\n🦶_⬇\n🦶⬇",
      "🦶⬆\n🦶_⬆\n🦶__⬆\n🏁\n🦶⬇\n🦶_⬇\n🦶__⬇",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Shows correct descent from top stair",
      "Wrong order of climbing",
      "Wrong return pattern",
      "Incorrect step sequence",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "What's wrong with this recursive function meant to find duplicates in an array?",
    code: "public boolean hasDuplicates(int[] arr, int index) {\n    if (index >= arr.length - 1)\n        return false;\n    if (arr[index] == arr[index + 1])\n        return true;\n    return hasDuplicates(arr, index + 1);\n}\n",
    answersList: [
      "Only checks adjacent elements",
      "Incorrect base case",
      "Wrong index increment",
      "Missing return statement",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Misses duplicates that aren't next to each other",
      "Base case correctly handles array end",
      "Index increment is appropriate",
      "All paths have returns",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 2,
    question:
      "Complete this recursive method to reverse words in a sentence ('hello world' → 'world hello')",
    code: 'public String reverseWords(String sentence) {\n    // Base case: single word or empty\n    if (!sentence.contains(" "))\n        return sentence;\n    \n    int space = sentence.indexOf(" ");\n    String firstWord = sentence.substring(0, space);\n    String rest = sentence.substring(space + 1);\n    \n    // Your recursive case here\n    return ________;\n}\n',
    answersList: [
      'reverseWords(rest) + " " + firstWord',
      'firstWord + " " + reverseWords(rest)',
      'rest + " " + reverseWords(firstWord)',
      'reverseWords(firstWord) + " " + rest',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Correctly builds reversed sentence",
      "Would maintain original order",
      "Would process words incorrectly",
      "Would reverse individual words",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "This code should count occurrences of 'x' in a string. What's missing?",
    code: "public int countX(String str) {\n    if (str.length() == 0)\n        return 0;\n    \n    if (str.charAt(0) == 'x')\n        countX(str.substring(1));\n    else\n        countX(str.substring(1));\n}\n",
    answersList: [
      "Return statements and increment",
      "Base case only",
      "Substring method only",
      "Parameter validation",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Needs to return 1 + recursive call or just recursive call",
      "Base case is correctly defined",
      "Substring usage is correct",
      "Parameters are handled correctly",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "What would be the appropriate recursive approach to print this number pattern for n=3?",
    code: "// Desired output:\n// 1\n// 2 2\n// 3 3 3\n// 2 2\n// 1\n",
    answersList: [
      "Print n n-times, recur down, print n n-times",
      "Print line, recur up, print line",
      "Print all ascending, then descending",
      "Print recursively without backtracking",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Creates symmetric pattern with correct repetition",
      "Wouldn't create number repetition",
      "Would print wrong pattern",
      "Would miss descending part",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "What makes this recursive solution inefficient for checking if a number is prime?",
    code: "public boolean isPrime(int n, int divisor) {\n    if (divisor <= 1)\n        return true;\n    if (n % divisor == 0)\n        return false;\n    return isPrime(n, divisor - 1);\n}\n// Called as: isPrime(n, n-1)",
    answersList: [
      "Checks unnecessary divisors",
      "Wrong base case",
      "Incorrect division check",
      "Missing return statement",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Only needs to check up to square root",
      "Base case correctly identifies primes",
      "Division check is correct",
      "All paths have returns",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question:
      "How would this recursive tree traversal behave with an unbalanced tree?",
    code: 'class Node {\n    int value;\n    Node left, right;\n}\n\npublic void printTree(Node root) {\n    if (root == null) return;\n    System.out.print(root.value + " ");\n    printTree(root.left);\n    printTree(root.right);\n}\n',
    answersList: [
      "Deep stack for skewed trees",
      "Print in wrong order",
      "Skip some nodes",
      "Infinite recursion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each node adds to stack without balance",
      "Prints in correct preorder",
      "Visits all nodes correctly",
      "Has proper termination",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Why might this recursive list search return incorrect results?",
    code: "class ListNode {\n    int value;\n    ListNode next;\n}\n\npublic boolean contains(ListNode list, int x) {\n    if (list == null)\n        return false;\n    if (list.value == x)\n        contains(list.next, x);\n    return contains(list.next, x);\n}\n",
    answersList: [
      "Missing return for found value",
      "Wrong base case",
      "Incorrect next pointer",
      "Wrong comparison",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Should return true when value found",
      "Null check is appropriate",
      "Next pointer usage is correct",
      "Value comparison is correct",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      "Complete this recursive method to generate balanced parentheses pairs (n=2 → '(())', '()()')",
    code: 'public void generateParens(int open, int closed,\n                        int n, String current) {\n    if (current.length() == 2 * n) {\n        System.out.println(current);\n        return;\n    }\n    \n    // Your code here - when can you add open/closed parentheses?\n    if (_________)\n        generateParens(open + 1, closed, n, current + "(");\n    if (_________)\n        generateParens(open, closed + 1, n, current + ")");\n}\n',
    answersList: [
      "open < n, closed < open",
      "open < n, closed < n",
      "open > closed, closed < n",
      "open < closed, open < n",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Ensures balanced pairs and correct count",
      "Would allow unbalanced pairs",
      "Wrong comparison order",
      "Would create invalid patterns",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "What sequence of calls would this recursive function make for fun(3)?",
    code: 'public void fun(int n) {\n    if (n <= 0) return;\n    System.out.print(n + " ");\n    fun(n-2);\n    System.out.print(n + " ");\n    fun(n-1);\n}\n',
    answersList: ["3 1 1 3 2 2", "3 2 1 1 2 3", "3 1 3 2 1 2", "3 2 1 3 1 2"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Follows branching pattern with correct backtracking",
      "Wrong call sequence",
      "Incorrect backtracking",
      "Wrong recursive pattern",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Help Dr. RecursiveChef make a recursive sandwich! What's wrong with this function?",
    code: 'public void makeSandwich(int layers) {\n    System.out.println("🍞 Adding bread");\n    System.out.println("🧀 Adding cheese");\n    makeSandwich(layers - 1);\n    System.out.println("Done!");\n}\n// Called as: makeSandwich(3);\n// Warning: No sandwich artists were harmed in making this code',
    answersList: [
      "Infinite sandwich (missing base case)",
      "Not enough cheese layers",
      "Too many bread slices",
      "Missing mayo (just kidding)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Would make sandwiches forever! Needs if (layers <= 0) return;",
      "Cheese quantity is a design choice 🧀",
      "Bread amount follows recipe 🍞",
      "Mayo is optional! 😄",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Help the recursive space explorer count stars! Complete the pattern:",
    code: 'public void exploreSpace(int sectors) {\n    if (sectors <= 0) {\n        System.out.println("🚀 Mission complete!");\n        return;\n    }\n    System.out.println("✨".repeat(sectors) + "🛸");\n    exploreSpace(sectors - 1);\n    // Mystery line here\n}\n\n/* Current output for exploreSpace(3):\n✨✨✨🛸\n✨✨🛸\n✨🛸\n🚀 Mission complete!\n*/',
    answersList: [
      'System.out.println("✨".repeat(sectors) + "👾")',
      'System.out.println("👾".repeat(sectors))',
      'System.out.println("🛸" + "✨".repeat(sectors))',
      'System.out.println("🚀".repeat(sectors))',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Adds space invaders on the way back! 👾",
      "Too many aliens! 👽",
      "UFO should lead the fleet 🛸",
      "One rocket is enough! 🚀",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question:
      "The Recursive Pizza Chef needs to cut a pizza into slices! What's the bug?",
    code: 'public int cutPizza(int cuts) {\n    System.out.println("🔪 Making cut #" + cuts);\n    return cuts * cutPizza(cuts - 1);\n}\n// Hint: A pizza with 0 cuts has 1 piece!\n// Warning: No pizzas were harmed in this recursion',
    answersList: [
      "Missing base case for 0",
      "Wrong multiplication",
      "Not enough pepperoni",
      "Pizza got cold",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Needs if (cuts == 0) return 1; to avoid 🔪 infinity",
      "Math checks out (when base case added) 🧮",
      "Pepperoni is a topping choice 🍕",
      "Recursive pizzas stay hot! 🔥",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Help the recursive frog hop home! What's the output?",
    code: 'public void frogHop(int hops) {\n    if (hops <= 0) {\n        System.out.println("🏠 Home sweet home!");\n        return;\n    }\n    System.out.println("🌿" + "_".repeat(hops) + "🐸");\n    frogHop(hops - 1);\n    System.out.println("🌿" + "_".repeat(hops) + "💤");\n}\n// Called as: frogHop(2);',
    answersList: [
      "🌿__🐸\n🌿_🐸\n🏠 Home sweet home!\n🌿_💤\n🌿__💤",
      "🐸__🌿\n🐸_🌿\n🏠\n💤_🌿\n💤__🌿",
      "🌿🐸🌿\n🏠\n🌿💤🌿",
      "🐸🐸🏠💤💤",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Froggy hops closer then takes naps on return! 🐸",
      "Froggy can't hop backwards! 🙈",
      "Not enough lily pads! 🌿",
      "Too sleepy to hop! 💤",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      "The recursive gardener needs to plant a binary tree of flowers! Complete the pattern:",
    code: 'class TreeNode {\n    String flower;\n    TreeNode left, right;\n}\n\npublic void plantFlowers(TreeNode root, int level) {\n    if (root == null || level <= 0) return;\n    System.out.println("  ".repeat(3-level) + root.flower);\n    // Your code here to plant more flowers!\n}\n\n/* Desired output for level 3:\n🌸\n  🌷 🌷\n    🌻 🌻 🌻 🌻\n*/',
    answersList: [
      "plantFlowers(root.left, level-1);\nplantFlowers(root.right, level-1);",
      "plantFlowers(root.left, level);\nplantFlowers(root.right, level);",
      "plantFlowers(root.left, 1);\nplantFlowers(root.right, 1);",
      'System.out.println("🌸🌷🌻");',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Creates perfect flower garden! 🌸",
      "Flowers would overlap! 🌷",
      "Garden too small! 🌻",
      "Not a tree pattern! 🎋",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "The recursive chef is making pancakes! What's wrong with the stack?",
    code: 'public void makePancakes(int count) {\n    if (count > 0) {\n        System.out.println("🥞".repeat(count));\n        makePancakes(count + 1);\n    }\n}\n// Warning: Excessive pancake consumption may cause happiness',
    answersList: [
      "Stack keeps growing",
      "Not enough syrup",
      "Pancakes too flat",
      "Missing blueberries",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Should be count - 1 to avoid pancake overflow! 🥞",
      "Syrup is user preference 🍯",
      "All pancakes are beautiful 🥞",
      "Toppings are optional! 🫐",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "The recursive DJ is mixing beats! What's the output pattern?",
    code: 'public void mixBeats(int level) {\n    if (level <= 0) return;\n    System.out.print("🎵");\n    mixBeats(level - 1);\n    System.out.print("🎶");\n    mixBeats(level - 1);\n    System.out.print("🎸");\n}\n// Called as: mixBeats(2);',
    answersList: [
      "🎵🎵🎶🎸🎶🎸🎸",
      "🎵🎶🎸🎵🎶🎸",
      "🎸🎶🎵🎸🎶🎵",
      "🎵🎵🎵🎶🎶🎶",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Dropping the perfect beat! 🎵",
      "Rhythm is off! 🎶",
      "Beat dropped wrong way! 🎸",
      "Not enough variation! 🎼",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "The recursive zoo keeper is counting animals! What's missing?",
    code: 'public int countAnimals(String[] zoo, int index) {\n    if (index >= zoo.length)\n        return 0;\n    if (zoo[index].equals("🦁"))\n        countAnimals(zoo, index + 1);\n    return countAnimals(zoo, index + 1);\n}\n// Note: Lions are mandatory in every zoo!',
    answersList: [
      "Return 1 + recursive call",
      "More lions",
      "Bigger zoo array",
      "Zoo keeper emoji",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Need to count those lions! 🦁",
      "One lion is fierce enough! 🦁",
      "Zoo size is purr-fect 😺",
      "Zoo keeper is on break 😴",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      "The recursive ice cream shop needs help making a tower! Complete the pattern:",
    code: 'public void makeIceCreamTower(int scoops) {\n    if (scoops <= 0) {\n        System.out.println("🍽️");\n        return;\n    }\n    // Your code here to stack ice cream!\n    // Hint: It should look like a tower\n}\n\n/* Desired output for scoops=3:\n  🍨\n 🍨🍨\n🍨🍨🍨\n  🍽️\n*/',
    answersList: [
      'spacing + "🍨".repeat(scoops)',
      '"🍨" + spacing',
      '"🍨🍨🍨"',
      '"🍦".repeat(scoops)',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Perfect ice cream tower! 🍨",
      "Tower would fall over! 😱",
      "Not enough scoops! 🍨",
      "Wrong ice cream type! 🍦",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question: "The recursive alien is learning Earth numbers! What's wrong?",
    code: 'public String alienCount(int n) {\n    if (n == 0) return "👽";\n    return "👾" + alienCount(n - 1) + "👽";\n}\n// Note: Aliens prefer symmetric patterns\n// Warning: No aliens were confused during this recursion',
    answersList: [
      "Base case returns wrong alien",
      "Not enough space ships",
      "Wrong alien color",
      "Aliens too cute",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Base case alien breaks symmetry! 👽",
      "UFOs are optional 🛸",
      "All alien colors valid 👾",
      "Aliens can't be too cute! 👽",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Why does this recursive maze solver get stuck in some mazes but not others?",
    code: "class MazeCell {\n    boolean isWall;\n    boolean visited;\n    int row, col;\n}\n\npublic boolean solveMaze(MazeCell[][] maze, int row, int col) {\n    if (row < 0 || col < 0 || \n        row >= maze.length || col >= maze[0].length)\n        return false;\n    \n    if (maze[row][col].isWall || maze[row][col].visited)\n        return false;\n        \n    maze[row][col].visited = true;\n    \n    if (row == maze.length-1 && col == maze[0].length-1)\n        return true;\n    \n    return solveMaze(maze, row + 1, col) ||\n           solveMaze(maze, row, col + 1) ||\n           solveMaze(maze, row - 1, col) ||\n           solveMaze(maze, row, col - 1);\n}\n",
    answersList: [
      "Never unmarks visited cells",
      "Wrong order of directions",
      "Missing wall checks",
      "Incorrect bounds check",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Needs backtracking: unmark cells when path fails",
      "Direction order doesn't affect correctness",
      "Wall checks are properly implemented",
      "Boundary checks are correct",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Implement memoization to optimize this recursive string distance calculator",
    code: "// Currently: O(3^n) time complexity\npublic int stringDistance(String s1, String s2,\n                         int i1, int i2) {\n    if (i1 == 0) return i2;\n    if (i2 == 0) return i1;\n    \n    if (s1.charAt(i1-1) == s2.charAt(i2-1))\n        return stringDistance(s1, s2, i1-1, i2-1);\n        \n    return 1 + Math.min(\n        stringDistance(s1, s2, i1-1, i2),   // delete\n        Math.min(\n            stringDistance(s1, s2, i1, i2-1),   // insert\n            stringDistance(s1, s2, i1-1, i2-1)  // replace\n        )\n    );\n}\n",
    answersList: [
      "Add Integer[][] memo and cache results",
      "Add map of previous results",
      "Store only last result",
      "Cache string prefixes",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "2D array cache gives O(nm) time complexity",
      "Map lookup would be slower than array",
      "Single result cache insufficient",
      "Prefix cache misses subproblems",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question: "This recursive tree balancer has a subtle bug. Find it:",
    code: "class Node {\n    int value;\n    Node left, right;\n    int height;\n}\n\npublic Node balance(Node root) {\n    if (root == null) return null;\n    \n    root.left = balance(root.left);\n    root.right = balance(root.right);\n    \n    int balance = height(root.left) - height(root.right);\n    \n    if (balance > 1) {\n        if (height(root.left.left) >= height(root.left.right))\n            return rightRotate(root);\n        root.left = leftRotate(root.left);\n        return rightRotate(root);\n    }\n    \n    if (balance < -1) {\n        if (height(root.right.right) >= height(root.right.left))\n            return leftRotate(root);\n        root.right = rightRotate(root.right);\n        return leftRotate(root);\n    }\n    \n    return root;\n}\n",
    answersList: [
      "Height not updated after rotation",
      "Wrong rotation direction",
      "Incorrect balance check",
      "Missing null check",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Node heights must be recalculated after each rotation",
      "Rotation directions match balance factors",
      "Balance calculation is correct",
      "Null checks are present",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Complete this recursive expression evaluator to handle nested parentheses",
    code: "public int evaluate(String expr, int[] pos) {\n    int value = 0;\n    int op = 1; // 1 for add, -1 for subtract\n    \n    while (pos[0] < expr.length()) {\n        char curr = expr.charAt(pos[0]);\n        if (curr == '(') {\n            pos[0]++;\n            // Your code here for nested expressions\n            value += ________;\n        } else if (curr == ')') {\n            return value;\n        } else if (curr == '+') {\n            op = 1;\n        } else if (curr == '-') {\n            op = -1;\n        } else if (Character.isDigit(curr)) {\n            value += op * (curr - '0');\n        }\n        pos[0]++;\n    }\n    return value;\n}\n// evaluate(\"2+(3-(4+5))\", new int[]{0}) should return -4",
    answersList: [
      "op * evaluate(expr, pos)",
      "evaluate(expr, pos)",
      "value * evaluate(expr, pos)",
      "op + evaluate(expr, pos)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Properly handles nested expressions with signs",
      "Would ignore current operation sign",
      "Would multiply instead of add/subtract",
      "Would add operation instead of apply it",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "What causes potential stack overflow in this recursive regex matcher?",
    code: "public boolean isMatch(String text, String pattern) {\n    if (pattern.isEmpty()) return text.isEmpty();\n    \n    boolean firstMatch = (!text.isEmpty() &&\n                         (pattern.charAt(0) == text.charAt(0) ||\n                          pattern.charAt(0) == '.'));\n                          \n    if (pattern.length() >= 2 && pattern.charAt(1) == '*') {\n        return (isMatch(text, pattern.substring(2)) ||\n                (firstMatch && isMatch(text.substring(1), pattern)));\n    } else {\n        return firstMatch && isMatch(text.substring(1), \n                                    pattern.substring(1));\n    }\n}\n// isMatch(\"aaaaa\", \"a*\") could overflow",
    answersList: [
      "Star pattern creates too many branches",
      "Text too long",
      "Pattern too complex",
      "Wrong recursion order",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "* operator creates exponential possibilities",
      "Text length alone isn't the issue",
      "Pattern complexity isn't main factor",
      "Recursion order is correct",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question: "Implement the missing case in this recursive JSON parser",
    code: "class JsonValue {\n    String stringValue;\n    JsonObject objectValue;\n    JsonArray arrayValue;\n    // etc...\n}\n\npublic JsonValue parse(String json, int[] pos) {\n    char c = json.charAt(pos[0]);\n    if (c == '{') {\n        return parseObject(json, pos);\n    } else if (c == '[') {\n        return parseArray(json, pos);\n    } else if (c == '\"') {\n        return parseString(json, pos);\n    } else if (c == 't' || c == 'f') {\n        return parseBoolean(json, pos);\n    } else if (/* Your condition here */) {\n        // Your code to parse numbers\n        // \"-?[0-9]+(.[0-9]+)?([eE][+-]?[0-9]+)?\" \n    }\n    throw new ParseException(\"Unexpected char: \" + c);\n}\n",
    answersList: [
      "c == '-' || Character.isDigit(c)",
      "c >= '0' && c <= '9'",
      "!Character.isLetter(c)",
      "c != '\"' && c != '{' && c != '['",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles negative numbers and digits",
      "Misses negative numbers",
      "Would match invalid characters",
      "Too broad, matches invalid starts",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Complete this recursive SQL query generator for hierarchical data",
    code: 'class Node {\n    int id;\n    String table;\n    List<Node> joins;\n}\n\npublic String generateQuery(Node root, Set<Integer> seen) {\n    if (seen.contains(root.id))\n        return "";\n    seen.add(root.id);\n    \n    StringBuilder query = new StringBuilder()\n        .append("SELECT * FROM ")\n        .append(root.table);\n    \n    for (Node join : root.joins) {\n        String subQuery = generateQuery(join, seen);\n        if (!subQuery.isEmpty()) {\n            // Your code here to add JOIN clauses\n            query.________(" JOIN ")\n                 .________(join.table)\n                 .________(" ON ")\n                 .________(root.table)\n                 .________(".id = ")\n                 .________(join.table)\n                 .________(".parent_id");\n        }\n    }\n    return query.toString();\n}\n',
    answersList: [
      "append (all gaps)",
      "add (all gaps)",
      "concat (all gaps)",
      "join (all gaps)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "StringBuilder.append builds query correctly",
      "add isn't StringBuilder method",
      "concat creates new strings unnecessarily",
      "join isn't appropriate here",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "What will this simple drawing program output for drawTriangle(3)?",
    code: 'public void drawTriangle(int size) {\n    if (size <= 0) return;\n    \n    // Draw current line\n    for (int i = 0; i < size; i++) {\n        System.out.print("*");\n    }\n    System.out.println();\n    \n    drawTriangle(size - 1);\n}\n\n// Example for size=2:\n// **\n// *',
    answersList: ["***\n**\n*", "*\n**\n***", "***\n***\n***", "***\n**"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Prints decreasing number of stars",
      "Would need different recursion order",
      "Would need loop without recursion",
      "Missing last line",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 2,
    question: "Why will this array sum function give wrong results sometimes?",
    code: "public int sumArray(int[] arr, int index) {\n    // Base case: reached the end\n    if (index == arr.length-1)\n        return arr[index];\n    \n    // Recursive case: add current element\n    return arr[index] + sumArray(arr, index+1);\n}\n\n// Called as: sumArray(arr, 0)",
    answersList: [
      "Empty array problem",
      "Wrong addition order",
      "Missing multiplication",
      "Index too large",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Crashes on empty array - needs check for index >= length",
      "Addition order is correct",
      "Sum doesn't need multiplication",
      "Index starts correctly at 0",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "Complete this method to count all vowels in a string recursively",
    code: 'public int countVowels(String str) {\n    // Base case\n    if (str.length() == 0)\n        return 0;\n        \n    // Your recursive solution here\n    char first = str.charAt(0);\n    if (isVowel(first)) {\n        return ________;\n    } else {\n        return ________;\n    }\n}\n\nboolean isVowel(char c) {\n    return "aeiouAEIOU".indexOf(c) >= 0;\n}',
    answersList: [
      "1 + countVowels(str.substring(1)), countVowels(str.substring(1))",
      "1 + countVowels(str), countVowels(str)",
      "countVowels(str.substring(1)), countVowels(str)",
      "1, 0",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Adds 1 for vowel and continues, or just continues for consonant",
      "Would cause infinite recursion",
      "Missing base case handling",
      "Would not recurse",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What's wrong with this recursive even number counter?",
    code: "public int countEvens(int[] arr, int index) {\n    if (index >= arr.length)\n        return 0;\n        \n    if (arr[index] % 2 == 0)\n        countEvens(arr, index + 1);\n    return countEvens(arr, index + 1);\n}\n",
    answersList: [
      "Missing return increment",
      "Wrong base case",
      "Incorrect modulo",
      "Wrong index",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Should return 1 + recursive call for even numbers",
      "Base case correctly handles end of array",
      "Modulo 2 correctly checks for even numbers",
      "Index increments correctly",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "How many times will this function print 'Hello' for printHello(3)?",
    code: 'public void printHello(int n) {\n    if (n <= 0) return;\n    System.out.println("Hello");\n    printHello(n-1);\n    System.out.println("Hello");\n}\n',
    answersList: ["6", "3", "4", "5"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Prints both before and after recursion: 3 + 3 = 6 times",
      "Would be if only printing before recursion",
      "Not possible with this pattern",
      "Would be missing one print",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "Complete this function to check if a string has matching parentheses",
    code: "public boolean checkParens(String str, int openCount) {\n    // Base case: reached end of string\n    if (str.length() == 0)\n        return openCount == 0;\n        \n    char first = str.charAt(0);\n    if (first == '(') {\n        return checkParens(________, ________);  // More open\n    } else if (first == ')') {\n        if (openCount <= 0) return false;  // Too many closed\n        return checkParens(________, ________);  // One less open\n    }\n    // Not a parenthesis\n    return checkParens(________, ________);  // Count stays same\n}\n",
    answersList: [
      "str.substring(1), openCount + 1\nstr.substring(1), openCount - 1\nstr.substring(1), openCount",
      "str.substring(1), 1\nstr.substring(1), -1\nstr.substring(1), 0",
      "str, openCount + 1\nstr, openCount - 1\nstr, openCount",
      "str.substring(0), openCount\nstr.substring(0), openCount\nstr.substring(0), openCount",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Properly tracks open parens and moves through string",
      "Would lose track of total open count",
      "Would not progress through string",
      "Wrong substring method usage",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What sequence will this method print for printNum(3)?",
    code: 'public void printNum(int n) {\n    if (n <= 0) return;\n    System.out.print(n + " ");\n    printNum(n-1);\n    printNum(n-1);\n}\n',
    answersList: ["3 2 1 1 2 1 1", "3 2 1 2 1", "1 2 3 3 2 1", "3 3 2 2 1 1"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each call branches into two smaller calls",
      "Missing some recursive calls",
      "Wrong order of numbers",
      "Incorrect branching pattern",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question: "What's missing from this recursive array search function?",
    code: "public boolean contains(int[] arr, int target, int start) {\n    if (start >= arr.length)\n        return false;\n        \n    contains(arr, target, start + 1);\n}\n",
    answersList: [
      "Check current element and return",
      "Sort array first",
      "Count occurrences",
      "Print elements",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Needs: if (arr[start] == target) return true;",
      "Search works on unsorted arrays too",
      "Just needs to find one occurrence",
      "Printing not needed for search",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question: "Complete this method to print a number's digits vertically",
    code: "public void printVertical(int num) {\n    // Example: printVertical(123) should print:\n    // 1\n    // 2\n    // 3\n    \n    // Your code here - use recursion!\n}\n",
    answersList: [
      "if (num > 0) {\n    printVertical(num / 10);\n    System.out.println(num % 10);\n}",
      "System.out.println(num);\nprintVertical(num / 10);",
      "while (num > 0) {\n    System.out.println(num % 10);\n    num = num / 10;\n}",
      "if (num > 0) {\n    System.out.println(num % 10);\n    printVertical(num / 10);\n}",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Prints digits top-down using recursion",
      "Would print full numbers",
      "Uses iteration instead of recursion",
      "Would print digits bottom-up",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Why doesn't this recursive list printer work correctly?",
    code: 'class ListNode {\n    int value;\n    ListNode next;\n}\n\npublic void printList(ListNode head) {\n    System.out.print(head.value + " ");\n    printList(head.next);\n}\n',
    answersList: [
      "Missing null check",
      "Wrong print format",
      "Incorrect value access",
      "Wrong next pointer",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Needs base case: if (head == null) return;",
      "Print format is fine",
      "Value access is correct",
      "Next pointer usage is correct",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "A photo gallery app needs to find all image files in a folder and its subfolders. What's wrong with this recursive file finder?",
    code: "public List<String> findImages(File folder) {\n    List<String> images = new ArrayList<>();\n    \n    // Look through all files in the folder\n    for (File file : folder.listFiles()) {\n        if (file.isDirectory()) {\n            findImages(file);  // Search subfolders\n        } else if (isImageFile(file.getName())) {\n            images.add(file.getPath());\n        }\n    }\n    return images;\n}\n\n// Helper that checks if file ends with .jpg, .png, etc.\nboolean isImageFile(String name) { /* ... */ }",
    answersList: [
      "Missing list combination",
      "Wrong file check",
      "Incorrect path",
      "Bad helper method",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Should add results from recursion: images.addAll(findImages(file))",
      "File type checking is correct",
      "Path handling is correct",
      "Helper method is fine",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "A recipe app needs to calculate the total calories of a dish that may contain other dishes as ingredients. What does this method return for a sandwich recipe?",
    code: "class Recipe {\n    String name;\n    int basicCalories;  // calories from basic ingredients\n    List<Recipe> subRecipes;  // other dishes used in this one\n}\n\npublic int calculateCalories(Recipe recipe) {\n    if (recipe.subRecipes.isEmpty()) {\n        return recipe.basicCalories;\n    }\n    \n    int total = recipe.basicCalories;\n    for (Recipe sub : recipe.subRecipes) {\n        total += calculateCalories(sub);\n    }\n    return total;\n}\n\n/* Example:\nSandwich (basic: 100) contains:\n  - Bread (basic: 150)\n  - Sauce (basic: 50)\n*/",
    answersList: ["300", "100", "200", "150"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Adds all calories: 100 + 150 + 50 = 300",
      "Would only count main recipe",
      "Would miss sauce calories",
      "Would only count bread",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "A family tree app needs to count how many ancestors came from a specific country. Complete the method:",
    code: "class Person {\n    String country;\n    Person mother;\n    Person father;\n}\n\npublic int countAncestorsFromCountry(Person person,\n                                    String targetCountry) {\n    // Base case: no person (end of tree)\n    if (person == null) return 0;\n    \n    // Count this person if they're from target country\n    int count = person.country.equals(targetCountry) ? 1 : 0;\n    \n    // Your recursive code here to check parents\n    return ________;\n}\n",
    answersList: [
      "count + countAncestorsFromCountry(person.mother, targetCountry) + countAncestorsFromCountry(person.father, targetCountry)",
      "1 + countAncestorsFromCountry(person.mother, targetCountry) + countAncestorsFromCountry(person.father, targetCountry)",
      "countAncestorsFromCountry(person.mother, targetCountry) + countAncestorsFromCountry(person.father, targetCountry)",
      "count",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Correctly adds current person (if matching) and both parents",
      "Would count person even if not from country",
      "Would miss current person",
      "Would miss parents completely",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "A file compressor needs to calculate folder size. What's wrong with this code?",
    code: "public long getFolderSize(File folder) {\n    long size = 0;\n    for (File file : folder.listFiles()) {\n        if (file.isDirectory()) {\n            getFolderSize(file);\n        } else {\n            size += file.length();\n        }\n    }\n    return size;\n}\n",
    answersList: [
      "Not adding subfolder sizes",
      "Wrong size calculation",
      "Incorrect loop",
      "Bad return value",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Missing: size += getFolderSize(file)",
      "File size calculation is correct",
      "Loop properly checks all files",
      "Return type is appropriate",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "A menu system needs to find an item by ID. Complete the recursive search:",
    code: "class MenuItem {\n    int id;\n    String name;\n    List<MenuItem> subMenus;  // Submenus under this item\n}\n\npublic MenuItem findItem(MenuItem current, int targetId) {\n    // Check if current item matches\n    if (current.id == targetId) {\n        return current;\n    }\n    \n    // Search submenus - your code here\n    for (MenuItem sub : current.subMenus) {\n        // What should go here?\n        ________\n    }\n    \n    return null;  // Not found\n}\n",
    answersList: [
      "MenuItem result = findItem(sub, targetId);\nif (result != null) return result;",
      "return findItem(sub, targetId);",
      "if (sub.id == targetId) return sub;",
      "findItem(sub, targetId);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Checks result and only returns if found",
      "Would return after first submenu",
      "Would miss deeper submenus",
      "Ignores return value",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "A comment system needs to count total replies (including replies to replies). What does this return for the example?",
    code: "class Comment {\n    String text;\n    List<Comment> replies;\n}\n\npublic int countTotalReplies(Comment comment) {\n    if (comment.replies.isEmpty()) {\n        return 0;\n    }\n    \n    int count = comment.replies.size();\n    for (Comment reply : comment.replies) {\n        count += countTotalReplies(reply);\n    }\n    return count;\n}\n\n/* Example structure:\nMain comment\n ├─ Reply 1\n │  └─ Sub-reply 1A\n └─ Reply 2\n    ├─ Sub-reply 2A\n    └─ Sub-reply 2B\n*/",
    answersList: ["5", "2", "3", "4"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Counts all: 2 replies + 3 sub-replies = 5",
      "Would only count main replies",
      "Would miss some sub-replies",
      "Would miss one sub-reply",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "A messaging app needs to format chat timestamps recursively. What's missing?",
    code: 'public String formatTime(int seconds) {\n    // Format time like: 2h 30m 45s\n    if (seconds < 60) {\n        return seconds + "s";\n    }\n    \n    if (seconds < 3600) {\n        int minutes = seconds / 60;\n        // Your code here for minutes and remaining seconds\n        return _______;\n    }\n    \n    int hours = seconds / 3600;\n    // Your code here for hours and remaining time\n    return _______;\n}\n',
    answersList: [
      'minutes + "m " + formatTime(seconds % 60)\nhours + "h " + formatTime(seconds % 3600)',
      'minutes + "m"\nhours + "h"',
      "formatTime(minutes) + formatTime(seconds)\nformatTime(hours) + formatTime(seconds)",
      'seconds / 60 + "m"\nseconds / 3600 + "h"',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Properly formats each unit and recursively handles remainder",
      "Would miss smaller units",
      "Would format units incorrectly",
      "Would miss recursive formatting",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "A music player needs to calculate total playlist time. What's wrong with this code?",
    code: "class Playlist {\n    String name;\n    int duration;  // in seconds\n    List<Playlist> subPlaylists;\n}\n\npublic int getTotalTime(Playlist list) {\n    int total = list.duration;\n    \n    for (Playlist sub : list.subPlaylists) {\n        total = getTotalTime(sub);\n    }\n    \n    return total;\n}\n",
    answersList: [
      "Overwriting total time",
      "Wrong duration unit",
      "Incorrect list access",
      "Bad return type",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Should add instead: total += getTotalTime(sub)",
      "Seconds are appropriate unit",
      "List iteration is correct",
      "Int is appropriate for seconds",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "A document editor needs to find all mentions of a word, including in nested sections. Complete the method:",
    code: "class Document {\n    String text;\n    List<Document> sections;  // Nested sections\n}\n\npublic int findWordCount(Document doc, String word) {\n    // Count in current text\n    int count = countOccurrences(doc.text, word);\n    \n    // Your code here to count in nested sections\n    for (Document section : doc.sections) {\n        ________\n    }\n    \n    return count;\n}\n\n// Helper that counts words in simple text\nint countOccurrences(String text, String word) { /* ... */ }",
    answersList: [
      "count += findWordCount(section, word);",
      "count = findWordCount(section, word);",
      "findWordCount(section, word);",
      "if (section.text.contains(word)) count++;",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Adds counts from all sections",
      "Would lose main text count",
      "Ignores return value",
      "Would miss nested occurrences",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "A task manager needs to calculate total project time. What will this return for the example?",
    code: "class Task {\n    String name;\n    int timeNeeded;  // in hours\n    List<Task> subtasks;\n}\n\npublic int calculateTotalTime(Task task) {\n    if (task.subtasks.isEmpty()) {\n        return task.timeNeeded;\n    }\n    \n    int total = task.timeNeeded;\n    for (Task sub : task.subtasks) {\n        total += calculateTotalTime(sub);\n    }\n    return total;\n}\n\n/* Example:\nProject Setup (2 hours)\n ├─ Install Software (1 hour)\n └─ Configure Settings (3 hours)\n    └─ Test Setup (2 hours)\n*/",
    answersList: ["8", "6", "5", "7"],
    correctAnswerIndex: 0,
    explanationsList: [
      "2 + 1 + 3 + 2 = 8 hours total",
      "Would miss some subtasks",
      "Would miss main task",
      "Would miss deepest task",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 1,
    question:
      "Write your first recursive function! Complete this method to print 'Hi' n times:",
    code: "// Example output for n=3:\n// Hi\n// Hi\n// Hi\n\npublic void printHi(int n) {\n    // Your code here - use recursion!\n    ________\n}\n",
    answersList: [
      'if (n <= 0) return;\nSystem.out.println("Hi");\nprintHi(n-1);',
      'for(int i = 0; i < n; i++) {\n    System.out.println("Hi");\n}',
      'while(n > 0) {\n    System.out.println("Hi");\n    n--;\n}',
      'System.out.println("Hi".repeat(n));',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Base case when done, print once, recurse for rest",
      "Uses iteration instead of recursion",
      "Uses loop instead of recursion",
      "No recursion, just string repetition",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Design a recursive solution for alternating letter case ('hello' → 'hElLo'). Handle empty strings!",
    code: "public String alternateCase(String str) {\n    // Your complete solution here\n    ________\n}\n",
    answersList: [
      'if (str.isEmpty()) return str;\nreturn str.substring(0, 1).toLowerCase() + \n       (str.length() > 1 ? str.substring(1, 2).toUpperCase() : "") +\n       alternateCase(str.length() > 2 ? str.substring(2) : "");',
      "if (str.isEmpty()) return str;\nreturn str.toUpperCase();",
      "return str.chars()\n          .mapToObj(ch -> Character.isUpperCase(ch) ? \n                   Character.toLowerCase(ch) : \n                   Character.toUpperCase(ch))\n          .collect(Collectors.joining());",
      "StringBuilder result = new StringBuilder(str);\nfor(int i = 0; i < str.length(); i += 2) {\n    result.setCharAt(i, Character.toLowerCase(str.charAt(i)));\n}",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles empty string, processes 2 chars at once",
      "Doesn't alternate case",
      "Uses streams instead of recursion",
      "Uses iteration instead of recursion",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 1,
    question: "Which calls to this countdown function would cause an error?",
    code: 'public void countdown(int n) {\n    if (n == 0) {\n        System.out.println("Blast off!");\n        return;\n    }\n    System.out.println(n);\n    countdown(n - 1);\n}\n',
    answersList: [
      "countdown(-1)",
      "countdown(5)",
      "countdown(0)",
      "countdown(1)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Negative numbers never reach base case",
      "Works correctly counting down from 5",
      "Base case handles 0 properly",
      "Works correctly for single step",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Which recursive solution is most memory-efficient for printing binary numbers up to n?",
    code: '// Option A:\npublic void binary(int n) {\n    if (n < 1) return;\n    binary(n - 1);\n    System.out.println(Integer.toBinaryString(n));\n}\n\n// Option B:\npublic void binary(int n, String current) {\n    if (current.length() > n) return;\n    if (!current.isEmpty())\n        System.out.println(current);\n    binary(n, current + "0");\n    binary(n, current + "1");\n}\n\n// Option C:\npublic void binary(int n) {\n    if (n < 1) return;\n    System.out.println(Integer.toBinaryString(n));\n    binary(n - 1);\n}\n',
    answersList: ["Option A", "Option B", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Linear recursion with no string building",
      "Creates many string copies",
      "Same as A but prints in reverse",
      "Memory usage differs significantly",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 1,
    question:
      "Write your first recursive math function! Complete sum from 1 to n:",
    code: "// Example: sum(3) should return 6 (1+2+3)\npublic int sum(int n) {\n    // Your code here\n    ________\n}\n",
    answersList: [
      "if (n <= 0) return 0;\nreturn n + sum(n-1);",
      "return n * (n + 1) / 2;",
      "int total = 0;\nfor(int i = 1; i <= n; i++) total += i;\nreturn total;",
      "if (n <= 0) return 0;\nreturn sum(n-1);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Base case plus recursive sum formula",
      "Direct formula without recursion",
      "Iterative solution instead",
      "Missing adding current number",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Which recursive palindrome checker handles special characters best?",
    code: '// Option A:\npublic boolean isPalindrome(String s) {\n    s = s.toLowerCase().replaceAll("[^a-z0-9]", "");\n    if (s.length() <= 1) return true;\n    return s.charAt(0) == s.charAt(s.length()-1) &&\n           isPalindrome(s.substring(1, s.length()-1));\n}\n\n// Option B:\npublic boolean isPalindrome(String s, int left, int right) {\n    while (left < right && !Character.isLetterOrDigit(s.charAt(left)))\n        left++;\n    while (left < right && !Character.isLetterOrDigit(s.charAt(right)))\n        right--;\n    if (left >= right) return true;\n    return Character.toLowerCase(s.charAt(left)) ==\n           Character.toLowerCase(s.charAt(right)) &&\n           isPalindrome(s, left+1, right-1);\n}\n\n// Option C:\npublic boolean isPalindrome(String s) {\n    if (s.length() <= 1) return true;\n    s = s.toLowerCase();\n    char first = s.charAt(0);\n    char last = s.charAt(s.length()-1);\n    if (!Character.isLetterOrDigit(first))\n        return isPalindrome(s.substring(1));\n    if (!Character.isLetterOrDigit(last))\n        return isPalindrome(s.substring(0, s.length()-1));\n    return first == last &&\n           isPalindrome(s.substring(1, s.length()-1));\n}\n',
    answersList: ["Option B", "Option A", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Skips special chars without string copying",
      "Creates new string unnecessarily",
      "Makes multiple recursive calls",
      "Have different performance characteristics",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 2,
    question:
      "Create a recursive method to print numbers in ascending then descending order",
    code: "// Example output for n=3:\n// 1 2 3 3 2 1\n\npublic void printPattern(int n) {\n    // Your solution here\n    ________\n}\n",
    answersList: [
      'if (n < 1) return;\nprintPattern(n-1);\nSystem.out.print(n + " ");\nSystem.out.print(n + " ");\nprintPattern(n-1);',
      'for(int i = 1; i <= n; i++) System.out.print(i + " ");\nfor(int i = n; i >= 1; i--) System.out.print(i + " ");',
      'if (n < 1) return;\nSystem.out.print(n + " ");\nprintPattern(n-1);\nSystem.out.print(n + " ");',
      'while(n > 0) {\n    System.out.print(n + " ");\n    n--;\n}',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Builds pattern recursively in both directions",
      "Uses iteration instead of recursion",
      "Produces wrong pattern",
      "Only prints descending numbers",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 1,
    question:
      "Write your first recursive printer! Complete this pattern printer:",
    code: "// Example for n=3:\n// *\n// **\n// ***\n\npublic void printStars(int n) {\n    // Your code here\n    ________\n}\n",
    answersList: [
      'if (n <= 0) return;\nprintStars(n-1);\nSystem.out.println("*".repeat(n));',
      'for(int i = 1; i <= n; i++)\n    System.out.println("*".repeat(i));',
      'while(n > 0) {\n    System.out.println("*".repeat(n));\n    n--;\n}',
      'System.out.println("*".repeat(n));\nprintStars(n-1);',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Builds pattern bottom-up correctly",
      "Uses iteration instead of recursion",
      "Prints wrong pattern",
      "Prints reverse pattern",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 3,
    question:
      "Which implementation best handles this recursive pattern printer?",
    code: '// Example output for n=3:\n// *\n// **\n// ***\n// **\n// *\n\n// Option A:\npublic void pattern(int n, int current, boolean up) {\n    System.out.println("*".repeat(current));\n    if (current == n && up) up = false;\n    if (current > 1 && !up)\n        pattern(n, current-1, up);\n    else if (current < n && up)\n        pattern(n, current+1, up);\n}\n\n// Option B:\npublic void pattern(int n) {\n    if (n < 1) return;\n    pattern(n-1);\n    System.out.println("*".repeat(n));\n    pattern(n-1);\n}\n\n// Option C:\npublic void pattern(int n, int current) {\n    if (current <= 0) return;\n    String stars = "*".repeat(current);\n    pattern(n, current-1);\n    System.out.println(stars);\n    if (current != n)\n        System.out.println(stars);\n}\n',
    answersList: ["Option B", "Option A", "Option C", "All equal"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Cleanest solution with natural recursion",
      "Complex boolean flag tracking",
      "Prints some lines twice",
      "Have different complexities",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      "Create a recursive method to check if a number is in sequence 1, 3, 9, 27, ...",
    code: "// Returns true if n is in sequence: 1, 3, 9, 27, ...\n// Each number is previous * 3\npublic boolean inSequence(int n) {\n    // Your solution here\n    ________\n}\n",
    answersList: [
      "if (n == 1) return true;\nif (n < 1) return false;\nif (n % 3 != 0) return false;\nreturn inSequence(n / 3);",
      "return n % 3 == 0;",
      "while (n > 1) {\n    if (n % 3 != 0) return false;\n    n = n / 3;\n}\nreturn true;",
      "if (n <= 0) return false;\nreturn inSequence(n * 3);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Checks base case and divides back to 1",
      "Only checks divisibility by 3",
      "Uses iteration instead of recursion",
      "Would cause infinite recursion",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a recursive solution that prints Pascal's Triangle. Row 3 looks like: 1 3 3 1",
    code: "// Example output for n=3:\n// 1\n// 1 1\n// 1 2 1\n// 1 3 3 1\n\npublic void printPascal(int row) {\n    // Your complete solution here!\n    ________\n}\n",
    answersList: [
      'if (row < 0) return;\nprintPascal(row - 1);\nfor (int i = 0; i <= row; i++) {\n    System.out.print(pascal(row, i) + " ");\n}\nSystem.out.println();\n\n// Helper method:\nprivate int pascal(int r, int c) {\n    if (c == 0 || c == r) return 1;\n    return pascal(r-1, c-1) + pascal(r-1, c);\n}',
      'for(int i = 0; i <= row; i++) {\n    for(int j = 0; j <= i; j++) {\n        System.out.print("1 ");\n    }\n    System.out.println();\n}',
      'printPascal(row - 1);\nSystem.out.println("1 ".repeat(row + 1));',
      'if (row < 0) return;\nSystem.out.println("1 ".repeat(row + 1));\nprintPascal(row - 1);',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Correctly calculates each value using recursion",
      "Would print only 1s",
      "Would print wrong values",
      "Would print reverse order",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question: "Find TWO bugs in this recursive list reversal code:",
    code: "class ListNode {\n    int value;\n    ListNode next;\n}\n\npublic ListNode reverse(ListNode head) {\n    // Base case\n    if (head == null) return null;\n    if (head.next == null) return head;\n    \n    // Recursive case\n    ListNode rest = reverse(head.next);\n    head.next.next = head;\n    \n    return rest;\n}\n",
    answersList: [
      "Missing head.next = null and not handling two nodes",
      "Wrong base case and wrong return value",
      "Wrong recursive call and missing link",
      "Wrong pointer update and missing case",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Needs to break old link and handle two-node case specially",
      "Base cases are correct",
      "Recursive call is correct",
      "Pointer update is correct but incomplete",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Implement a recursive solution to flatten nested integers (e.g., [1,[2,3],[4,[5,6]]] → [1,2,3,4,5,6])",
    code: "class NestedList {\n    boolean isInteger();\n    Integer getInteger();\n    List<NestedList> getList();\n}\n\npublic List<Integer> flatten(NestedList nested) {\n    List<Integer> result = new ArrayList<>();\n    // Your code here\n    ________\n    return result;\n}\n",
    answersList: [
      "if (nested.isInteger()) {\n    result.add(nested.getInteger());\n} else {\n    for (NestedList item : nested.getList()) {\n        result.addAll(flatten(item));\n    }\n}",
      "for (NestedList item : nested.getList()) {\n    result.add(item.getInteger());\n}",
      "if (nested.isInteger()) {\n    result.add(nested.getInteger());\n}\nresult.addAll(flatten(nested.getList()));",
      "result.addAll(nested.getList().stream()\n    .map(NestedList::getInteger)\n    .collect(Collectors.toList()));",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles both integers and nested lists correctly",
      "Misses nested elements",
      "Invalid recursive call",
      "Doesn't handle nesting",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Create a recursive solution to print all possible ways to climb n stairs, taking 1 or 2 steps at a time",
    code: "// Example for n=3:\n// 1,1,1\n// 1,2\n// 2,1\n\npublic void printSteps(int n, String path) {\n    // Your solution here\n    ________\n}\n",
    answersList: [
      'if (n == 0) {\n    System.out.println(path.substring(1));\n    return;\n}\nif (n >= 1) printSteps(n-1, path + ",1");\nif (n >= 2) printSteps(n-2, path + ",2");',
      'while (n > 0) {\n    System.out.print("1,");\n    n--;\n}\nSystem.out.println();',
      "for (int i = 1; i <= 2; i++) {\n    System.out.println(i);\n}",
      'if (n <= 0) return;\nSystem.out.println("1");\nprintSteps(n-1, path);',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Explores all combinations recursively",
      "Only prints single solution",
      "Doesn't track combinations",
      "Misses 2-step options",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "What causes potential integer overflow in this recursive power function? How to fix it?",
    code: "public int power(int base, int exp) {\n    if (exp == 0) return 1;\n    if (exp == 1) return base;\n    \n    int half = power(base, exp/2);\n    if (exp % 2 == 0) {\n        return half * half;\n    } else {\n        return half * half * base;\n    }\n}\n",
    answersList: [
      "Missing long conversion",
      "Wrong base case",
      "Incorrect division",
      "Bad recursion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "half * half can overflow, needs long type",
      "Base cases are correct",
      "Division is correct for recursion",
      "Recursion pattern is efficient",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Implement a recursive solution to find the longest palindromic substring in a string",
    code: "public String longestPalindrome(String s) {\n    if (s == null || s.length() < 2) return s;\n    // Your solution here\n    ________\n}\n\n// Helper method to use:\nboolean isPalindrome(String s, int start, int end) {\n    while (start < end) {\n        if (s.charAt(start++) != s.charAt(end--))\n            return false;\n    }\n    return true;\n}\n",
    answersList: [
      "String maxPal = s.substring(0, 1);\nfor (int i = 0; i < s.length(); i++) {\n    String odd = expandAroundCenter(s, i, i);\n    String even = expandAroundCenter(s, i, i+1);\n    if (odd.length() > maxPal.length()) maxPal = odd;\n    if (even.length() > maxPal.length()) maxPal = even;\n}\nreturn maxPal;",
      "if (isPalindrome(s, 0, s.length()-1)) return s;\nreturn longestPalindrome(s.substring(1));",
      "return s.charAt(0) + longestPalindrome(s.substring(1));",
      'if (isPalindrome(s, 0, s.length()-1)) return s;\nreturn "";',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Expands around centers to find all palindromes",
      "Misses internal palindromes",
      "Doesn't check palindrome property",
      "Returns empty for non-palindromes",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question: "This recursive BST validator has a subtle bug. Find it:",
    code: "class Node {\n    int value;\n    Node left, right;\n}\n\npublic boolean isValidBST(Node root) {\n    return isValidBST(root, null, null);\n}\n\nprivate boolean isValidBST(Node node, Integer min, Integer max) {\n    if (node == null) return true;\n    \n    if (min != null && node.value <= min) return false;\n    if (max != null && node.value >= max) return false;\n    \n    return isValidBST(node.left, min, node.value)\n           && isValidBST(node.right, node.value, max);\n}\n",
    answersList: [
      "Integer overflow possible",
      "Wrong comparison operator",
      "Incorrect recursion",
      "Bad null check",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Doesn't handle Integer.MIN_VALUE/MAX_VALUE edges",
      "Comparisons are correct",
      "Recursion pattern is correct",
      "Null checks are appropriate",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Create a recursive solution to print all ways to split a string into palindromes",
    code: '// Example: for "aaa", print:\n// [a, a, a]\n// [a, aa]\n// [aa, a]\n// [aaa]\n\npublic void printPalindromeSplits(String s, List<String> current) {\n    // Your solution here\n    ________\n}\n\nboolean isPalindrome(String s) {\n    int i = 0, j = s.length() - 1;\n    while (i < j) if (s.charAt(i++) != s.charAt(j--)) return false;\n    return true;\n}\n',
    answersList: [
      "if (s.isEmpty()) {\n    System.out.println(current);\n    return;\n}\nfor (int i = 1; i <= s.length(); i++) {\n    String prefix = s.substring(0, i);\n    if (isPalindrome(prefix)) {\n        current.add(prefix);\n        printPalindromeSplits(s.substring(i), current);\n        current.remove(current.size() - 1);\n    }\n}",
      "if (isPalindrome(s)) {\n    current.add(s);\n    System.out.println(current);\n    return;\n}",
      "System.out.println(s);\nprintPalindromeSplits(s.substring(1), current);",
      "current.add(s);\nif (!s.isEmpty())\n    printPalindromeSplits(s.substring(1), current);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Tries all possible splits and backtracks",
      "Only finds single palindrome",
      "Doesn't check palindrome property",
      "Doesn't handle splits properly",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      'Write a recursive function to check if a string is a rotation of another (e.g., "waterbottle" is a rotation of "erbottlewat")',
    code: "public boolean isRotation(String s1, String s2) {\n    // Your solution here\n    // Hint: Use substring operations\n    ________\n}\n",
    answersList: [
      "if (s1.length() != s2.length()) return false;\nif (s1.equals(s2)) return true;\nreturn isRotation(s1.substring(1) + s1.charAt(0), s2);",
      "return s1.length() == s2.length() && (s1 + s1).contains(s2);",
      "return s1.equals(s2);",
      "if (s1.length() != s2.length()) return false;\nreturn s1.charAt(0) == s2.charAt(0) && isRotation(s1.substring(1), s2.substring(1));",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Recursively tries each rotation",
      "Non-recursive solution",
      "Only checks equality",
      "Doesn't handle rotations",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "Which of these statements correctly defines the term 'base case' in recursion?",
    answersList: [
      "The condition where the recursive function stops calling itself",
      "The first time a function calls itself",
      "The last time a function calls itself",
      "The condition where a function starts",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Base case defines the termination condition for recursion",
      "First recursive call is part of recursive step",
      "Last call isn't predetermined",
      "Starting condition isn't related to base case",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the name of the data structure that programming languages use to keep track of recursive function calls?",
    answersList: ["Call stack", "Call queue", "Call list", "Call tree"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Call stack manages function calls in Last-In-First-Out order",
      "Queue follows First-In-First-Out order",
      "List isn't used for managing calls",
      "Tree represents call relationships but isn't used for execution",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a recursive solution for generating all possible binary trees with n nodes. Complete the method:",
    code: "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\npublic List<TreeNode> generateTrees(int n) {\n    // Your recursive solution here\n    if (n == 0) return new ArrayList<>();\n    return ________;\n}\n",
    answersList: [
      "generateSubtrees(1, n)",
      "generateSubtrees(0, n)",
      "generateSubtrees(n, n)",
      "generateSubtrees(n, 0)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Generates trees using range from 1 to n",
      "Starting from 0 would create invalid trees",
      "Would generate incorrect range",
      "Invalid range parameters",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Analyze the time complexity pattern in this recursive grid path finder. Why is memoization essential?",
    code: "public int findPaths(int[][] grid, int row, int col) {\n    if (row < 0 || col < 0 || grid[row][col] == 1)\n        return 0;\n    if (row == 0 && col == 0)\n        return 1;\n    return findPaths(grid, row - 1, col) +\n           findPaths(grid, row, col - 1);\n}\n",
    answersList: [
      "Exponential overlap in subproblems",
      "Loop in recursion tree",
      "Deep recursion depth",
      "Large input size",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Same positions calculated multiple times exponentially",
      "No loops occur in this implementation",
      "Depth isn't the primary concern",
      "Input size alone isn't the issue",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 1,
    question:
      "Write your first tail-recursive function! Complete this sum calculation:",
    code: "// Should add numbers from 1 to n\npublic int sum(int n, int acc) {\n    // Your tail-recursive solution here\n    ________\n}\n",
    answersList: [
      "if (n <= 0) return acc;\nreturn sum(n-1, acc + n);",
      "if (n <= 0) return acc;\nreturn acc + sum(n-1, n);",
      "return sum(n-1, n) + acc;",
      "if (n <= 0) return 0;\nreturn n + sum(n-1, acc);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Proper tail recursion with accumulator",
      "Accumulator used incorrectly",
      "Not tail recursive - addition after call",
      "Accumulator not used properly",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 1,
    question:
      "Which recursive call sequence would print numbers in ascending order?",
    answersList: [
      "Recursive call then print",
      "Print then recursive call",
      "Both would work the same",
      "Neither would work",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Recursive call first reaches smallest number first",
      "Would print in descending order",
      "Order of operations matters",
      "Both approaches are valid but give different orders",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a recursive solution for generating all possible regular expressions that match a given string. Complete the method:",
    code: "public List<String> generateRegex(String str) {\n    // Your solution here to generate valid regex patterns\n    // Example: for 'aa', valid patterns include 'aa', 'a{2}', '(a){2}'\n    ________\n}\n",
    answersList: [
      'if (str.isEmpty()) return Arrays.asList("");\nList<String> patterns = new ArrayList<>();\nfor (int i = 1; i <= str.length(); i++) {\n    String curr = str.substring(0, i);\n    if (isRepeating(curr)) {\n        patterns.addAll(addQuantifier(curr, generateRegex(str.substring(i))));\n    }\n}\nreturn patterns;',
      "return Arrays.asList(str);",
      'return Arrays.asList(str.replaceAll(".", ".*"));',
      'if (str.isEmpty()) return Arrays.asList("");\nreturn Arrays.asList(str);',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles repeating patterns and generates valid combinations",
      "Only returns original string",
      "Creates invalid regex pattern",
      "Misses pattern combinations",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "What causes the inefficiency in this recursive edit distance calculator?",
    code: "public int editDistance(String s1, String s2, int m, int n) {\n    if (m == 0) return n;  // Insert all remaining\n    if (n == 0) return m;  // Delete all remaining\n    \n    if (s1.charAt(m-1) == s2.charAt(n-1))\n        return editDistance(s1, s2, m-1, n-1);\n        \n    return 1 + Math.min(\n        editDistance(s1, s2, m, n-1),    // Insert\n        Math.min(\n            editDistance(s1, s2, m-1, n),    // Delete\n            editDistance(s1, s2, m-1, n-1)  // Replace\n        )\n    );\n}\n",
    answersList: [
      "Redundant subproblem calculations",
      "Incorrect base cases",
      "Wrong string comparison",
      "Too many parameters",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Same (m,n) pairs calculated multiple times",
      "Base cases are correct",
      "Character comparison is valid",
      "Parameters are necessary",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What term describes a recursive function that has its recursive call as the very last operation?",
    answersList: [
      "Tail recursion",
      "Head recursion",
      "End recursion",
      "Final recursion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Tail recursion has recursive call as final operation",
      "Head recursion has recursive call before operations",
      "Not a standard recursion term",
      "Not a standard recursion term",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a recursive solution for finding all possible ways to decode a string of digits into letters (1=A, 2=B, ..., 26=Z):",
    code: 'public List<String> decodeWays(String digits) {\n    // Your solution here\n    // Example: "123" -> ["ABC", "LC", "AW"]\n    ________\n}\n',
    answersList: [
      "if (digits.isEmpty()) return Arrays.asList(\"\");\nList<String> result = new ArrayList<>();\nif (digits.length() >= 1) {\n    int oneDigit = Integer.parseInt(digits.substring(0, 1));\n    if (oneDigit >= 1) {\n        for (String sub : decodeWays(digits.substring(1))) {\n            result.add((char)('A' + oneDigit - 1) + sub);\n        }\n    }\n}\nif (digits.length() >= 2) {\n    int twoDigits = Integer.parseInt(digits.substring(0, 2));\n    if (twoDigits >= 10 && twoDigits <= 26) {\n        for (String sub : decodeWays(digits.substring(2))) {\n            result.add((char)('A' + twoDigits - 1) + sub);\n        }\n    }\n}\nreturn result;",
      "return Arrays.asList(digits);",
      "if (digits.isEmpty()) return Arrays.asList(\"\");\nreturn Arrays.asList(String.valueOf((char)('A' + Integer.parseInt(digits) - 1)));",
      'return Arrays.asList(digits.replaceAll("\\d", "A"));',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Handles both single and double digit cases recursively",
      "Returns digits without decoding",
      "Only handles single digits",
      "Replaces all digits with 'A'",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 1,
    question:
      "Create your first recursive string processor! Complete the vowel counter:",
    code: "public int countVowels(String str) {\n    // Your first recursive solution here\n    // Count 'a', 'e', 'i', 'o', 'u'\n    ________\n}\n",
    answersList: [
      "if (str.isEmpty()) return 0;\nreturn (isVowel(str.charAt(0)) ? 1 : 0) + countVowels(str.substring(1));",
      'return str.replaceAll("[^aeiou]", "").length();',
      "int count = 0;\nfor (char c : str.toCharArray())\n    if (isVowel(c)) count++;\nreturn count;",
      "if (!str.isEmpty())\n    return countVowels(str.substring(1));",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Proper recursion with character check",
      "Uses regex instead of recursion",
      "Uses iteration instead of recursion",
      "Missing vowel counting logic",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Why is this recursive matrix path counter inefficient for large grids?",
    code: "public long countPaths(int[][] matrix, int row, int col) {\n    if (row < 0 || col < 0 || matrix[row][col] == 1)\n        return 0;\n    if (row == 0 && col == 0)\n        return 1;\n    return countPaths(matrix, row - 1, col) +\n           countPaths(matrix, row, col - 1);\n}\n",
    answersList: [
      "Recalculates same positions repeatedly",
      "Wrong direction checking",
      "Incorrect base case",
      "Bad matrix access",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Same (row,col) pairs calculated many times",
      "Direction checking is correct",
      "Base cases are properly defined",
      "Matrix access is valid",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Creating",
    difficulty: 1,
    question:
      "Write your first recursive array processor! Complete the array maximum finder:",
    code: "public int findMax(int[] arr, int index) {\n    // Your first recursive solution here\n    ________\n}\n",
    answersList: [
      "if (index == arr.length - 1) return arr[index];\nreturn Math.max(arr[index], findMax(arr, index + 1));",
      "int max = arr[0];\nfor (int i = 1; i < arr.length; i++)\n    max = Math.max(max, arr[i]);\nreturn max;",
      "return Arrays.stream(arr).max().getAsInt();",
      "if (index < arr.length) return arr[index];",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Proper recursion comparing current with rest",
      "Uses iteration instead of recursion",
      "Uses streams instead of recursion",
      "Doesn't compare all elements",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the term for when a recursive function calls itself more than once in its recursive step?",
    answersList: [
      "Multiple recursion",
      "Double recursion",
      "Split recursion",
      "Branch recursion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Multiple recursion refers to multiple recursive calls in one step",
      "Not a standard term for this concept",
      "Not a standard term for this concept",
      "Not a standard term for this concept",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "Which of these is the correct definition of a recursive data structure?",
    answersList: [
      "A data structure that contains one or more references to instances of the same data structure type",
      "A data structure that only contains primitive data types",
      "A data structure that uses arrays internally",
      "A data structure that can only store numbers",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like a tree node containing references to other tree nodes",
      "Data structure type is unrelated to content type",
      "Implementation details don't define recursion",
      "Content type doesn't define recursive structure",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the term for when a recursive function modifies its return value after the recursive call?",
    answersList: [
      "Head recursion",
      "Tail recursion",
      "Linear recursion",
      "Binary recursion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Head recursion performs operations after recursive call",
      "Tail recursion has recursive call as final operation",
      "Linear recursion refers to single recursive call",
      "Binary recursion refers to two recursive calls",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What is the technical term for when a recursive function saves previously calculated results to avoid recalculation?",
    answersList: ["Memoization", "Caching", "Storage", "Memory mapping"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Memoization is the technical term for storing results",
      "General term, not specific to recursion",
      "Too general, not specific to results saving",
      "Different concept from computer architecture",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the minimum number of cases a recursive function must have to work correctly?",
    answersList: [
      "Two (base case and recursive case)",
      "One (just the recursive case)",
      "Three (start, middle, end)",
      "Four (init, process, recurse, end)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Must have base case to stop and recursive case to continue",
      "Would never terminate without base case",
      "Only two cases are required",
      "Only two cases are required",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What is the term for the mathematical principle that proves a recursive function works for all inputs if it works for the base case and each recursive step is correct?",
    answersList: [
      "Mathematical induction",
      "Mathematical deduction",
      "Recursive proof",
      "Logical inference",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Induction proves correctness from base case and inductive step",
      "Deduction is a different logical process",
      "Not a formal mathematical term",
      "Too general, not specific to recursion proofs",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question: "What happens to local variables in each recursive call?",
    answersList: [
      "Each call gets its own fresh copy",
      "They are shared between calls",
      "Only the first call has them",
      "They are global to all calls",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each stack frame contains its own local variables",
      "Variables are separate for each call",
      "All calls have their own variables",
      "Local variables are not shared",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What is the name of the recursive problem-solving strategy where you break a problem into smaller identical sub-problems?",
    answersList: [
      "Divide and conquer",
      "Split and solve",
      "Break and build",
      "Partition and process",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Classic term for breaking problem into smaller similar ones",
      "Not the standard term",
      "Not the standard term",
      "Not the standard term",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the term for a recursive function that calls itself through another function?",
    answersList: [
      "Indirect recursion",
      "Secondary recursion",
      "Chain recursion",
      "Linked recursion",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Indirect recursion occurs through intermediate functions",
      "Not the standard term",
      "Not the standard term",
      "Not the standard term",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "Which memory segment stores the recursive function call information?",
    answersList: [
      "Stack segment",
      "Heap segment",
      "Data segment",
      "Code segment",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Function calls and local variables stored on stack",
      "Heap is for dynamic allocation",
      "Data segment is for global variables",
      "Code segment stores program instructions",
    ],
  },
  {
    topic: "Recursion",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the primary characteristic that makes a problem suitable for recursion?",
    answersList: [
      "It can be broken down into smaller versions of the same problem",
      "It involves mathematical calculations",
      "It requires sorting of data",
      "It needs to process arrays",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Self-similarity is key for recursive solutions",
      "Math operations don't determine recursion suitability",
      "Sorting isn't a requirement for recursion",
      "Array processing isn't a requirement for recursion",
    ],
  },
];

export default recursion;
