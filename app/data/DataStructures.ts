const dataStructures: {
  topic: string;
  bloomTaxonomyCategory: string;
  difficulty: number;
  question: string;
  code?: string;
  answersList: string[];
  correctAnswerIndex: number;
  explanationsList: string[];
}[] = [
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the fundamental difference between how a stack and a queue handle the order of elements?",
    answersList: [
      "A stack follows Last In First Out (LIFO) principle, while a queue follows First In First Out (FIFO) principle.",
      "A stack follows First In First Out (FIFO) principle, while a queue follows Last In First Out (LIFO) principle.",
      "A stack and a queue both follow Last In First Out (LIFO) principle.",
      "A stack and a queue both follow First In First Out (FIFO) principle.",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "A stack follows Last In First Out (LIFO) principle, meaning the last element added to the stack will be the first one to be removed. Whereas, a queue follows First In First Out (FIFO) principle, meaning the first element added to the queue will be the first one to be removed.",
      "This statement is incorrect because a stack does not follow the First In First Out (FIFO) principle; instead, it follows the Last In First Out (LIFO) principle.",
      "This statement is incorrect because both a stack and a queue do not follow the Last In First Out (LIFO) principle; only a stack does.",
      "This statement is incorrect because both a stack and a queue do not follow the First In First Out (FIFO) principle; only a queue does.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "In a real-world application, which data structure would be most appropriate for implementing the 'undo' feature in a text editor?",
    answersList: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correctAnswerIndex: 0,
    explanationsList: [
      "A stack is the appropriate data structure for implementing undo functionality in a text editor. This is because the last action performed is the first to be undone, which aligns with the Last In First Out (LIFO) behavior of a stack.",
      "Using a queue for undo functionality is not appropriate because a queue follows the First In First Out (FIFO) principle, which would undo the oldest actions first rather than the most recent ones.",
      "ArrayList does not provide the desired behavior for implementing undo functionality in a text editor because it does not inherently support the Last In First Out (LIFO) behavior required for undo operations.",
      "LinkedList does not provide the desired behavior for implementing undo functionality in a text editor because it does not inherently support the Last In First Out (LIFO) behavior required for undo operations.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "In Java's Stack class, which method both retrieves and removes the topmost element?",
    answersList: ["pop()", "peek()", "remove()", "get()"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The 'pop()' method in the Java Stack class is used to retrieve and remove the element at the top of the stack. It follows the Last In First Out (LIFO) principle of a stack.",
      "The 'peek()' method only retrieves but does not remove the element at the top of the stack.",
      "The 'remove()' method in the Collection interface is not specific to stacks and doesn't necessarily remove the top element of the stack.",
      "The 'get()' method is not used for retrieving and removing elements in a stack. It's used in other data structures like ArrayList to get an element at a specified index.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "In a queue data structure, at which position are new elements added to maintain the FIFO principle?",
    answersList: [
      "At the rear (end)",
      "At the front",
      "In the middle",
      "At random positions",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "In a queue, new elements are always added at the rear (end). This follows the First In First Out (FIFO) principle, ensuring that elements are processed in the order they arrive.",
      "Adding new elements at the front of a queue would violate the First In First Out (FIFO) principle as it would disrupt the order of elements.",
      "Queues do not allow adding elements in the middle because it would disrupt the order of elements and violate the First In First Out (FIFO) principle.",
      "Adding elements at random positions would violate the queue's ordered structure and the First In First Out (FIFO) principle.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 3,
    question:
      "Which of the following is NOT a concrete implementation of a queue in Java?",
    answersList: [
      "Queue interface",
      "LinkedList",
      "ArrayList",
      "PriorityQueue",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The Queue interface itself is not a concrete implementation but rather a blueprint that defines queue behavior. It cannot be instantiated directly.",
      "LinkedList is a concrete implementation of the Queue interface in Java, providing all the necessary functionality to represent a queue.",
      "ArrayList can be used to implement a queue, though it's not the most efficient implementation.",
      "PriorityQueue is a concrete implementation of a queue in Java that orders elements based on their priority.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "In Java's Queue interface, which method is the standard way to add an element to the end of a queue?",
    answersList: ["offer()", "enqueue()", "add()", "push()"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The 'offer()' method is the standard way to add an element to the end of a queue in Java. It safely handles capacity restrictions and returns false if the element cannot be added.",
      "The 'enqueue()' method is not a standard method in Java's Queue interface.",
      "While 'add()' can be used, it throws an exception if the queue is full, making 'offer()' a safer choice.",
      "The 'push()' method is used for adding elements to a stack, not a queue.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What is the time complexity (Big O notation) of adding an element to a stack implemented with a LinkedList in Java?",
    answersList: ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The push operation in a LinkedList-based stack has O(1) time complexity because it only requires adding an element at the beginning of the list, which is a constant-time operation.",
      "O(n) would be incorrect as we don't need to traverse the entire list to add an element to a stack.",
      "O(log n) would be the time complexity for operations like binary search, not for adding elements to a stack.",
      "O(n log n) is typically seen in sorting algorithms, not in basic stack operations.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "Which Java Queue method allows you to view the front element without removing it?",
    answersList: ["peek()", "poll()", "remove()", "pop()"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The 'peek()' method safely returns the element at the front of the queue without removing it. If the queue is empty, it returns null.",
      "The 'poll()' method removes and returns the element at the front of the queue.",
      "The 'remove()' method removes a specific element from the collection, not specifically designed for queue operations.",
      "The 'pop()' method is used with stacks, not queues, and removes the top element.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 3,
    question:
      "Which method is NOT part of Java's standard Stack class for removing elements?",
    answersList: ["remove()", "pop()", "poll()", "None of the above"],
    correctAnswerIndex: 0,
    explanationsList: [
      "While 'remove()' exists in the Collection interface, it's not a standard method specifically designed for stack operations in Java's Stack class.",
      "The 'pop()' method is the standard way to remove and return the top element from a stack.",
      "The 'poll()' method is used with queues, not stacks.",
      "This option is incorrect as 'remove()' is indeed not a standard stack operation method.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What exception is thrown when attempting to pop an element from an empty stack in Java?",
    answersList: [
      "EmptyStackException",
      "NullPointerException",
      "ArrayIndexOutOfBoundsException",
      "The stack remains unchanged",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Java throws an EmptyStackException when you try to pop from an empty stack. This is a specific exception designed to indicate that the stack has no elements to remove.",
      "NullPointerException is thrown when trying to access or modify a null reference, not when attempting to pop from an empty stack.",
      "ArrayIndexOutOfBoundsException is thrown when trying to access an invalid array index, not when attempting to pop from an empty stack.",
      "The stack doesn't remain unchanged - an exception is thrown to indicate the error condition.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What are the key interfaces that Java's LinkedList class implements?",
    answersList: [
      "It implements both List and Queue interfaces",
      "It implements only the List interface",
      "It implements only the Queue interface",
      "It implements neither List nor Queue interfaces",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "A LinkedList in Java implements both the List and Queue interfaces, making it versatile for use as either a sequential list or as a FIFO queue structure.",
      "This is incorrect as LinkedList implements both List and Queue interfaces, providing functionality for both sequential and queue-based operations.",
      "This is incorrect as LinkedList implements both List and Queue interfaces, not just Queue.",
      "This is incorrect as LinkedList implements both List and Queue interfaces, not neither.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the primary purpose of the size() method in Java collections?",
    answersList: [
      "To return the number of elements in the collection",
      "To add elements to the collection",
      "To remove elements from the collection",
      "To check if the collection is empty",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The size() method returns an integer representing the current number of elements stored in the collection. This is useful for tracking how many elements are present.",
      "The size() method only reports the element count; it doesn't modify the collection by adding elements.",
      "The size() method only reports the element count; it doesn't modify the collection by removing elements.",
      "While size() can be used to check if a collection is empty (by checking if size is 0), this is not its primary purpose. The isEmpty() method is specifically designed for that.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 3,
    question:
      "When choosing between ArrayList and LinkedList in Java, which performance characteristic is correct?",
    answersList: [
      "ArrayList provides faster random access, while LinkedList offers more efficient insertions and deletions",
      "LinkedList provides faster random access, while ArrayList offers more efficient insertions and deletions",
      "Both ArrayList and LinkedList have identical performance for random access and insertions/deletions",
      "Neither ArrayList nor LinkedList are suitable for random access or efficient for insertions and deletions",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList uses a dynamic array implementation, allowing O(1) random access but O(n) insertions/deletions due to element shifting. LinkedList uses a doubly-linked list implementation, providing O(1) insertions/deletions but O(n) random access.",
      "This is incorrect because ArrayList's array-based structure is what provides faster random access, while LinkedList's node-based structure is what enables efficient insertions and deletions.",
      "This is incorrect as their underlying data structures give them different performance characteristics for these operations.",
      "This is incorrect as each structure is optimized for different types of operations - ArrayList for random access and LinkedList for insertions/deletions.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "Which of these Java collection types permits duplicate elements by design?",
    answersList: ["List", "Set", "Queue", "Map"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The List interface and its implementations (ArrayList, LinkedList, etc.) are designed to allow duplicate elements, maintaining insertion order.",
      "Sets are specifically designed to prevent duplicates, ensuring each element appears only once.",
      "While some Queue implementations might allow duplicates (if they implement List), the Queue interface itself doesn't specify duplicate behavior.",
      "Maps don't allow duplicate keys, though they can have duplicate values.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What is the default behavior of the add() method in Java's ArrayList class?",
    answersList: [
      "It appends the specified element to the end of the list",
      "It inserts the specified element at the specified position in the list",
      "It removes the specified element from the list",
      "It retrieves the specified element from the list",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The single-parameter add(E element) method in ArrayList automatically appends the new element to the end of the list, increasing its size by one.",
      "This describes the behavior of add(int index, E element), not the default add(E element) method.",
      "This describes the remove() method, not add().",
      "This describes the get() method, not add().",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What exception occurs when calling remove() on an empty Java queue?",
    answersList: [
      "NoSuchElementException",
      "NullPointerException",
      "ArrayIndexOutOfBoundsException",
      "The queue remains unchanged",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The remove() method throws NoSuchElementException when called on an empty queue, indicating that there are no elements to remove. For a safer alternative, consider using poll() which returns null instead.",
      "NullPointerException is thrown when attempting to access or modify a null reference, not when removing from an empty queue.",
      "ArrayIndexOutOfBoundsException relates to invalid array access, not queue operations.",
      "An exception is thrown rather than leaving the queue unchanged.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 3,
    question:
      "Which method safely removes and returns the front element from a queue in Java, returning null if the queue is empty?",
    answersList: ["poll()", "peek()", "dequeue()", "remove()"],
    correctAnswerIndex: 0,
    explanationsList: [
      "poll() safely removes and returns the front element, or returns null if the queue is empty. This makes it safer than remove() which throws an exception on empty queues.",
      "peek() only views the front element without removing it.",
      "dequeue() is not a standard Java Queue method - poll() or remove() are the standard methods.",
      "remove() throws an exception if the queue is empty, making it less safe than poll().",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "What is the purpose of the isEmpty() method in Java collections?",
    answersList: [
      "It returns true if the collection contains no elements",
      "It returns true if the collection contains one or more elements",
      "It adds elements to the collection",
      "It removes elements from the collection",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "isEmpty() is a convenient way to check if a collection has no elements, returning true if the size is 0.",
      "This is the opposite of what isEmpty() does - it returns false when elements are present.",
      "isEmpty() only checks the collection's state; it doesn't modify the contents.",
      "isEmpty() only checks the collection's state; it doesn't modify the contents.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What is the standard method in Java's Stack class to check if a stack has no elements?",
    answersList: ["isEmpty()", "empty()", "hasElements()", "nonEmpty()"],
    correctAnswerIndex: 1,
    explanationsList: [
      "While isEmpty() is common in other collections, Stack specifically uses empty().",
      "empty() is the correct method in the Stack class to check if the stack contains no elements.",
      "hasElements() is not a standard method in Java's Stack class.",
      "nonEmpty() is not a standard method in Java's Stack class.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "When implementing a Last In First Out (LIFO) data structure, which of the following would be most appropriate?",
    answersList: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correctAnswerIndex: 0,
    explanationsList: [
      "A Stack is specifically designed for LIFO operations, where the most recently added element is the first to be removed, making it perfect for tasks like undo operations or backtracking.",
      "A Queue follows FIFO (First In First Out) behavior, which is the opposite of what's needed for LIFO operations.",
      "While an ArrayList could be used to implement LIFO behavior, it's not specifically designed for this purpose and would require additional logic.",
      "While a LinkedList could be used to implement LIFO behavior, it's not specifically designed for this purpose and would require additional logic.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "Which method specifically adds an element to the end of a Java LinkedList?",
    answersList: ["addLast()", "addFirst()", "insert()", "append()"],
    correctAnswerIndex: 0,
    explanationsList: [
      "addLast() is the specific method in LinkedList that appends an element to the end of the list. This method makes the intention clear compared to using add().",
      "addFirst() adds an element to the beginning of the list, not the end.",
      "insert() is not a method in LinkedList. To insert at a specific position, you would use add(int index, E element).",
      "append() is not a method in LinkedList; addLast() or add() should be used instead.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "When removing elements from an ArrayList using the remove(int index) method, what happens to the remaining elements?",
    answersList: [
      "All subsequent elements shift left (their indices decrease by 1)",
      "The first occurrence of the specified element is removed",
      "The element is retrieved but not removed",
      "A new element is added at the specified position",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "When an element is removed by index from an ArrayList, all elements to the right of the removed element shift left to fill the gap, and their indices decrease by 1.",
      "This describes remove(Object o), not remove(int index). The index version removes the element at that specific position.",
      "This describes get(int index), not remove(int index). Remove actually deletes the element.",
      "This describes add(int index, E element), not remove(int index). Remove deletes elements, not adds them.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 3,
    question:
      "What makes LinkedList more efficient than ArrayList for frequent insertions and deletions in the middle of the list?",
    answersList: [
      "It only needs to update node references, avoiding the need to shift elements",
      "It provides better random access performance",
      "It uses less memory overall",
      "It maintains elements in sorted order automatically",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "LinkedList's node-based structure means insertions and deletions only require updating a few references between nodes, while ArrayList needs to shift all subsequent elements.",
      "LinkedList actually has worse random access performance than ArrayList as it needs to traverse from the start/end to reach a specific index.",
      "LinkedList often uses more memory than ArrayList due to storing node references in addition to the data.",
      "LinkedList does not automatically sort elements; it maintains insertion order unless specifically sorted.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "What is the difference between peek() and pop() methods in Java's Stack class?",
    answersList: [
      "peek() returns the top element without removing it, while pop() returns and removes it",
      "peek() removes the top element, while pop() only views it",
      "peek() adds elements to the stack, while pop() removes them",
      "peek() and pop() both remove and return the top element",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "peek() allows you to view the top element without modifying the stack, while pop() both returns and removes the top element. This makes peek() useful for checking the next element to be processed.",
      "This is the opposite of their actual behavior. peek() is non-destructive while pop() removes the element.",
      "Neither peek() nor pop() add elements - push() is used for adding elements to a stack.",
      "Only pop() removes elements; peek() is non-destructive and leaves the stack unchanged.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 3,
    question:
      "What is the time complexity of removing an element by index from the middle of a LinkedList?",
    answersList: ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
    correctAnswerIndex: 0,
    explanationsList: [
      "While the actual removal is O(1), finding the element at the specified index requires traversing an average of n/2 nodes, making the overall operation O(n).",
      "Though the removal itself is O(1), the need to traverse to the specified index makes the overall operation O(n), not O(1).",
      "LinkedList removal is linear time, not logarithmic, as it requires traversing nodes sequentially.",
      "The operation is simpler than this - it's just linear time O(n) due to the traversal requirement.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 2,
    question:
      "Which method is used to add an element to the top of a Java Stack?",
    answersList: ["push()", "add()", "append()", "insert()"],
    correctAnswerIndex: 0,
    explanationsList: [
      "push() is the standard method for adding elements to a Stack, following the conventional stack terminology used in computer science.",
      "While add() exists due to Stack extending Vector, push() is the preferred method for stack operations.",
      "append() is not a method in the Stack class; push() should be used instead.",
      "insert() is not a method in the Stack class; push() should be used instead.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 4,
    question:
      "What are the key differences between ArrayList and LinkedList implementations in Java? Consider internal structure, performance characteristics, and synchronization.",
    answersList: [
      "ArrayList uses dynamic arrays with fast random access but slower insertions/deletions, while LinkedList uses doubly-linked nodes with fast insertions/deletions but slower random access. Neither is synchronized by default.",
      "ArrayList uses arrays with slow random access and fast insertions/deletions, while LinkedList uses doubly-linked nodes with slow insertions/deletions but fast random access. ArrayList is synchronized.",
      "Both ArrayList and LinkedList use arrays internally with similar performance characteristics for all operations.",
      "ArrayList uses dynamic arrays while LinkedList uses singly-linked nodes. Both have identical performance characteristics.",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList uses a resizable array offering O(1) random access but O(n) insertions/deletions due to element shifting. LinkedList uses doubly-linked nodes providing O(1) insertions/deletions but O(n) random access due to traversal requirements. Neither class is synchronized by default - use Collections.synchronizedList() if needed.",
      "This reverses the actual performance characteristics of these data structures and incorrectly states ArrayList's synchronization status.",
      "This is incorrect as they use different internal structures (array vs. nodes) leading to different performance characteristics.",
      "This is incorrect about both the internal structure (LinkedList uses doubly-linked nodes) and performance characteristics.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "In a Java Queue implementation, what principle governs element processing and what are some real-world applications?",
    answersList: [
      "Queues follow First In First Out (FIFO), making them ideal for printer spoolers, task scheduling, and processing network packets in order of arrival",
      "Queues follow Last In First Out (LIFO), making them ideal for browser history and undo operations",
      "Queues allow random access to elements, making them ideal for database indexing",
      "Queues process elements based on priority, making them ideal for emergency response systems",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Queues implement FIFO behavior, ensuring the first element added is the first processed. This makes them perfect for scenarios requiring ordered processing like print jobs, task queues, or maintaining packet order in networking.",
      "This describes stack behavior (LIFO), not queue behavior. Browser history and undo operations are better implemented with stacks.",
      "Queues don't provide random access - elements must be processed in order. LinkedList or ArrayList would be better for random access needs.",
      "This describes a PriorityQueue, a special type of queue, not a standard queue implementation.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "How does a Stack's behavior differ from a Queue in Java, and what are their typical use cases?",
    answersList: [
      "Stacks use LIFO (Last In First Out) suited for function calls and undo operations, while Queues use FIFO (First In First Out) suited for print spooling and task scheduling",
      "Stacks use FIFO while Queues use LIFO, making Stacks better for task scheduling and Queues better for undo operations",
      "Stacks and Queues both use FIFO, making them interchangeable for most applications",
      "Stacks and Queues both use LIFO, but differ in their internal implementation",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stacks and Queues have opposite behaviors: Stacks (LIFO) are perfect for tracking nested operations like function calls or undo history, while Queues (FIFO) excel at ordered processing like print jobs or task scheduling.",
      "This incorrectly reverses their behaviors and consequently their appropriate use cases.",
      "This is incorrect as they have fundamentally different behaviors - LIFO vs FIFO.",
      "This is incorrect as they have different behaviors and are not both LIFO-based.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 4,
    question:
      "In a music player application, what would be the most appropriate data structure for implementing a playlist with forward/backward navigation, and why?",
    answersList: [
      "LinkedList, because its doubly-linked structure allows efficient bidirectional traversal and song insertion/removal",
      "ArrayList, because it provides faster random access to songs",
      "Stack, because it follows LIFO principle for song management",
      "Queue, because it maintains song order using FIFO",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "A LinkedList's doubly-linked structure perfectly suits a playlist's needs: O(1) insertion/deletion of songs, efficient next/previous navigation via node links, and natural maintenance of song order.",
      "While ArrayList provides good random access, it's less efficient for frequent insertions/deletions and doesn't naturally support bidirectional traversal.",
      "A Stack's LIFO behavior doesn't match playlist requirements for maintaining song order and allowing bidirectional navigation.",
      "A Queue's FIFO behavior and unidirectional access don't support the bidirectional navigation needed in a playlist.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "For each of these real-world scenarios, which Java data structure would be most appropriate and why: A) Customer service phone queue, B) Browser history navigation, C) Restaurant waiting list?",
    answersList: [
      "A) Queue - ensures FIFO for fair customer handling, B) Stack - enables LIFO for back/forward navigation, C) Queue - maintains fair FIFO order for seating customers",
      "A) Stack - handles customers in LIFO order, B) Queue - processes history sequentially, C) ArrayList - allows random access to waiting customers",
      "A) ArrayList - allows random customer selection, B) LinkedList - enables bidirectional navigation, C) Stack - serves most recent customers first",
      "A) Queue - handles customers randomly, B) Stack - stores history without order, C) LinkedList - allows customer reordering",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each scenario maps to its ideal data structure: Queues for fair, sequential processing (phone queue, restaurant list), Stack for last-in-first-out navigation (browser history). This matches real-world expectations of fairness and functionality.",
      "This incorrectly suggests unfair customer handling with LIFO and misunderstands browser history navigation needs.",
      "Random access isn't appropriate for customer service, and LIFO would be unfair for restaurant waiting.",
      "Queues don't handle elements randomly, and stacks maintain strict LIFO order.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "In a GUI application, which data structure would be most appropriate for handling user-generated events, and why?",
    answersList: [
      "Queue - ensures events are processed in the order they occurred (FIFO), maintaining a natural sequence of user interactions",
      "Stack - processes most recent events first (LIFO), ignoring older events",
      "ArrayList - allows random access to events in any order",
      "LinkedList - enables events to be processed from both ends",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "A Queue is ideal for event handling as it preserves the temporal order of events (FIFO), ensuring user actions are processed in the sequence they occurred, which is crucial for maintaining application state and user experience.",
      "Processing most recent events first would disrupt the natural flow of user interactions and could lead to inconsistent application state.",
      "Random access to events would break the temporal relationship between user actions and could cause logical errors in the application.",
      "Processing events from both ends would complicate event handling logic and potentially cause race conditions.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "How does the processing order differ between Stack and Queue implementations in Java, and what are their ideal use cases?",
    answersList: [
      "Stack uses LIFO (ideal for undo features, browser history), Queue uses FIFO (ideal for print spooling, event handling)",
      "Stack uses FIFO (ideal for event handling), Queue uses LIFO (ideal for undo features)",
      "Both use FIFO but with different internal implementations",
      "Both use LIFO but process elements differently",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The fundamental difference in processing order (LIFO vs FIFO) makes each structure ideal for different scenarios. Stacks excel when you need to reverse order or track history, while Queues are perfect for maintaining sequential order.",
      "This reverses the characteristic behaviors of Stacks and Queues, leading to inappropriate use cases.",
      "This is incorrect as Stack and Queue have fundamentally different processing orders.",
      "This is incorrect as only Stacks use LIFO; Queues use FIFO.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Which of the following code snippets correctly adds an element to the end of an ArrayList in Java?",
    code: "// Assuming ArrayList<T> list has been properly initialized",
    answersList: [
      "list.add(element);",
      "list.insert(element);",
      "list.push(element);",
      "list.enqueue(element);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "add() is the standard method in ArrayList for appending elements to the end of the list. It's part of the List interface and handles dynamic resizing automatically.",
      "insert() is not a method in ArrayList. To insert at a specific position, use add(int index, E element).",
      "push() is a Stack method, not an ArrayList method. For ArrayList, use add().",
      "enqueue() is a Queue operation, not an ArrayList method. For ArrayList, use add().",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Which code correctly implements these common LinkedList operations: A) Remove first element, B) Add element to front, C) Get first element without removing it?",
    code: "// Assume LinkedList<T> list has been properly initialized\n// Assume T element is a valid element",
    answersList: [
      "A) list.removeFirst();\nB) list.addFirst(element);\nC) list.getFirst();",
      "A) list.remove();\nB) list.push(element);\nC) list.peek();",
      "A) list.poll();\nB) list.add(0, element);\nC) list.get(0);",
      "A) list.pop();\nB) list.addFront(element);\nC) list.peekFirst();",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "These are the correct LinkedList-specific methods. removeFirst() removes the first element, addFirst() adds to the front, and getFirst() retrieves without removing.",
      "While some of these work (remove() and peek()), they're Queue interface methods rather than LinkedList-specific methods.",
      "While these work, they're less efficient or from different interfaces. add(0,element) requires traversing to index 0.",
      "These methods either don't exist (addFront) or are from different interfaces (pop).",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "What are the correct methods for adding and removing elements in Java's Queue and Stack implementations?",
    code: "// Assume Queue<T> queue and Stack<T> stack are initialized\n// Assume T element is a valid element",
    answersList: [
      "Queue: add(element)/offer(element) to add, remove()/poll() to remove\nStack: push(element) to add, pop() to remove",
      "Queue: push(element) to add, pop() to remove\nStack: add(element) to add, remove() to remove",
      "Queue: enqueue(element) to add, dequeue() to remove\nStack: push(element) to add, pull() to remove",
      "Queue: insert(element) to add, delete() to remove\nStack: addTop(element) to add, removeTop() to remove",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "These are the standard Java methods. Queue offers both add/offer (with offer being safer as it returns false if full instead of throwing exception) and remove/poll. Stack uses traditional push/pop terminology.",
      "This incorrectly applies Stack methods to Queue and Collection methods to Stack.",
      "While these names are conceptually correct, they're not the actual Java method names.",
      "These method names don't exist in Java's Queue or Stack implementations.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "What will be the final contents of this ArrayList after all operations are performed?",
    code: "List<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nlist.remove(2);\nSystem.out.println(list);",
    answersList: ["[1, 2, 4]", "[1, 3, 4]", "[1, 2, 3]", "[1, 4]"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The ArrayList will contain [1, 2, 4] because remove(2) removes the element at index 2 (the third element, which is 3), not the element with value 2. After removal, 4 shifts left to fill the gap.",
      "This would be the result if remove(2) removed the element with value 2 rather than the element at index 2.",
      "This would be the result if remove(2) removed the last element rather than the element at index 2.",
      "This would be the result if remove(2) removed both elements at index 2 and 3.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "What will be the contents of this Queue after all operations are executed?",
    code: 'Queue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.offer("C");\nqueue.remove();\nSystem.out.println(queue);',
    answersList: ["[B, C]", "[A, B, C]", "[B, A, C]", "[A, C]"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The queue will contain [B, C] because: 1) A, B, C are added in order, 2) remove() removes A (the first element), leaving B and C in their original order.",
      "This would be the contents if remove() wasn't called.",
      "This would be incorrect as queues maintain FIFO order - elements can't be reordered.",
      "This would be incorrect as remove() removes the first element (A), not B.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "Which methods correctly check for element presence and emptiness in Java collections?",
    code: "// Assume list, stack, and queue are properly initialized",
    answersList: [
      "contains(element) to check for an element\nisEmpty() to check if collection is empty",
      "hasElement(element) to check for an element\nsize() == 0 to check if empty",
      "includes(element) to check for an element\nlength() == 0 to check if empty",
      "find(element) to check for an element\ncount() == 0 to check if empty",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "contains() and isEmpty() are the standard methods in Java Collections Framework. isEmpty() is more readable and possibly more efficient than checking size().",
      "hasElement() isn't a Java collections method. While size() == 0 works, isEmpty() is clearer and preferred.",
      "These methods come from other languages (e.g., JavaScript) and aren't part of Java collections.",
      "These method names aren't part of the Java Collections Framework.",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "What will be the final state of this Stack after all operations are performed?",
    code: "Stack<Integer> stack = new Stack<>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nstack.pop();\nstack.peek();\nSystem.out.println(stack);",
    answersList: ["[1, 2]", "[1, 2, 3]", "[2, 3]", "[1, 3]"],
    correctAnswerIndex: 0,
    explanationsList: [
      "The final state will be [1, 2] because: 1) Elements 1,2,3 are pushed in order, 2) pop() removes 3, 3) peek() only views the top element (2) without removing it",
      "This would be the state if pop() wasn't called or if peek() added elements",
      "This would indicate incorrect removal order since pop() removes from the top",
      "This would indicate incorrect element manipulation during the operations",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Analyze how different LinkedList operations affect the list contents:",
    code: 'List<String> list = new LinkedList<>();\nlist.add("A");       // Operation 1\nlist.add("B");       // Operation 2\nlist.add("C");       // Operation 3\nlist.set(1, "D");    // Operation 4\nlist.remove("B");    // Operation 5\nlist.add("E");       // Operation 6\nSystem.out.println(list);',
    answersList: [
      "[A, D, C, E]",
      "[A, D, B, C, E]",
      "[D, C, E]",
      "[A, C, D, E]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      'The final state is [A, D, C, E] because: 1) ABC are added in order, 2) B is replaced with D at index 1, 3) remove("B") has no effect since B was already replaced, 4) E is added at the end',
      "This would be incorrect as B was replaced by D in operation 4",
      "This would be incorrect as A remains in the list throughout all operations",
      "This would indicate incorrect order of elements after the set operation",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Compare the behavior of remove() operations on different collection types:",
    code: "// Scenario 1: ArrayList\nList<Integer> list = new ArrayList<>();\nlist.add(1); list.add(2); list.add(3);\nlist.remove(Integer.valueOf(2));\n\n// Scenario 2: Stack\nStack<Integer> stack = new Stack<>();\nstack.push(1); stack.push(2); stack.push(3);\nstack.remove(Integer.valueOf(2));\n\n// Scenario 3: Queue\nQueue<Integer> queue = new LinkedList<>();\nqueue.add(1); queue.add(2); queue.add(3);\nqueue.remove();",
    answersList: [
      "ArrayList: [1, 3], Stack: [1, 3], Queue: [2, 3]",
      "ArrayList: [1, 3], Stack: [3, 1], Queue: [1, 2]",
      "ArrayList: [2, 3], Stack: [1, 3], Queue: [1, 3]",
      "ArrayList: [1, 2], Stack: [1, 3], Queue: [1, 2]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList.remove(Object) removes first occurrence of 2, Stack.remove(Object) removes 2 wherever it is, Queue.remove() removes the first element (1)",
      "This incorrectly shows Stack maintaining wrong order and Queue removing wrong element",
      "This shows incorrect removal behavior for ArrayList",
      "This shows elements not being removed as specified",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "What will be the contents and return value of this Queue operation sequence?",
    code: 'Queue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.offer("C");\nString removed = queue.poll();\nSystem.out.println("Queue: " + queue);\nSystem.out.println("Removed: " + removed);',
    answersList: [
      "Queue: [B, C], Removed: A",
      "Queue: [A, B], Removed: C",
      "Queue: [A, C], Removed: B",
      "Queue: [B, A], Removed: C",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "poll() removes and returns first element (A), leaving B and C in order. offer() is same as add() but returns boolean success value",
      "This shows incorrect removal order for FIFO queue behavior",
      "This shows incorrect element order and removal",
      "This shows incorrect queue ordering and removal behavior",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "What will be the final state of these collections after their respective operations?",
    code: '// Scenario 1: Stack Operations\nStack<String> stack = new Stack<>();\nstack.push("red");\nstack.push("green");\nstack.pop();\nstack.push("blue");\n\n// Scenario 2: ArrayList Operations\nList<Integer> list = new ArrayList<>();\nlist.add(100);\nlist.add(200);\nlist.add(300);\nlist.remove(2);\n\n// Scenario 3: Queue Operations\nQueue<String> queue = new LinkedList<>();\nqueue.add("apple");\nqueue.add("banana");\nqueue.remove();\nqueue.add("orange");',
    answersList: [
      "Stack: [red, blue], ArrayList: [100, 200], Queue: [banana, orange]",
      "Stack: [red, green, blue], ArrayList: [100, 300], Queue: [apple, orange]",
      "Stack: [green, blue], ArrayList: [200, 300], Queue: [banana]",
      "Stack: [blue], ArrayList: [100, 200, 300], Queue: [orange]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each collection behaves according to its properties: Stack (LIFO): green is popped then blue added; ArrayList: element at index 2 (300) removed; Queue (FIFO): first element (apple) removed, then orange added at end",
      "This incorrectly shows elements not being removed properly from the collections",
      "This shows incorrect base elements remaining in the collections",
      "This shows too many elements being removed from the collections",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Which Java data structures and methods are most appropriate for these real-world scenarios?",
    answersList: [
      "A) Print queue: Queue with add()/remove() - FIFO for document order\nB) Browser history: Stack with push()/pop() - LIFO for back navigation\nC) Shopping cart: ArrayList with add()/remove() - Random access to items",
      "A) Print queue: Stack - LIFO for document printing\nB) Browser history: Queue - FIFO for navigation\nC) Shopping cart: LinkedList - Sequential access",
      "A) Print queue: ArrayList - Random access to documents\nB) Browser history: LinkedList - Bidirectional navigation\nC) Shopping cart: Stack - Last added first removed",
      "A) Print queue: Stack - Document stacking\nB) Browser history: ArrayList - Index-based access\nC) Shopping cart: Queue - First in first out",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each scenario maps to the most appropriate data structure: Queue maintains printer order, Stack tracks navigation history in reverse order, ArrayList provides efficient random access for cart items",
      "These mappings don't match the natural behavior needed for each scenario",
      "These choices don't optimize for the primary operations needed in each case",
      "These selections would make the operations more complex than necessary",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "Compare the characteristics and methods of Queue and Deque interfaces:",
    answersList: [
      "Queue: FIFO (offer/poll/peek), single-ended operations\nDeque: Double-ended queue (offerFirst/offerLast/pollFirst/pollLast), supports both FIFO and LIFO",
      "Queue: Double-ended operations, Deque: Single-ended operations",
      "Queue: LIFO operations only, Deque: FIFO operations only",
      "Queue and Deque: Both support only single-ended operations",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Queue is designed for single-ended FIFO operations, while Deque extends this to support operations at both ends, making it more versatile for both FIFO and LIFO operations",
      "This incorrectly reverses the capabilities of Queue and Deque",
      "This misrepresents both interfaces' capabilities",
      "This understates the capabilities of both interfaces",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "What are the key differences between ArrayList and LinkedList implementations?",
    answersList: [
      "ArrayList: Resizable array (fast random access, slow insertions/deletions)\nLinkedList: Double-linked list (fast insertions/deletions, slow random access), implements both List and Queue interfaces",
      "ArrayList: Fixed-size array, LinkedList: Single-linked list",
      "ArrayList and LinkedList: Both have same performance characteristics",
      "ArrayList: Linked structure, LinkedList: Array structure",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The key differences reflect their internal implementations: ArrayList uses a dynamic array offering O(1) access but O(n) modifications, while LinkedList uses nodes offering O(1) modifications but O(n) access",
      "This incorrectly describes both structures' implementation details",
      "This ignores the fundamental differences in their implementations and performance",
      "This completely reverses their actual implementations",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Compare the method behaviors for Queue, Stack, and Deque interfaces in Java:",
    answersList: [
      "Queue: offer()/poll()/peek() - FIFO, no exceptions\nStack: push()/pop()/peek() - LIFO\nDeque: offerFirst()/pollLast()/peekFirst()/offerLast() - both ends",
      "Queue: push()/pop()/peek() - LIFO\nStack: offer()/poll()/peek() - FIFO\nDeque: add()/remove() - single end",
      "Queue: add()/remove() - random access\nStack: get()/set() - indexed\nDeque: push()/pop() - LIFO only",
      "Queue, Stack, and Deque all use the same methods with different names",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each interface provides methods optimized for its purpose: Queue for FIFO (with non-throwing methods), Stack for LIFO, and Deque for both-ends access. Deque is the most flexible, supporting both FIFO and LIFO operations.",
      "This incorrectly swaps Queue and Stack behaviors and understates Deque capabilities",
      "This misrepresents the primary purpose and behavior of each interface",
      "This oversimplifies the distinct purposes and capabilities of each interface",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "Which methods are used for element addition and removal in different List implementations?",
    code: "// Consider ArrayList and LinkedList implementations",
    answersList: [
      "ArrayList: add(E)/add(int,E)/remove(int)/remove(Object) - O(1) append, O(n) middle operations\nLinkedList: addFirst()/addLast()/removeFirst()/removeLast() - O(1) for ends, also has List methods",
      "ArrayList: push()/pop() for all operations\nLinkedList: enqueue()/dequeue() for all operations",
      "ArrayList and LinkedList: only support add()/remove() with same performance",
      "Both only support index-based operations with O(1) performance",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList optimizes for random access with array operations, while LinkedList provides efficient end operations through its doubly-linked structure. LinkedList implements both List and Deque interfaces, offering more operation choices.",
      "This confuses List implementations with Stack/Queue operations",
      "This ignores the performance differences and additional methods available",
      "This incorrectly suggests identical performance characteristics",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Compare operations and performance characteristics of different ordered collections in Java:",
    answersList: [
      "TreeSet: Balanced BST (O(log n) ops), natural ordering\nLinkedHashSet: Hash table + linked list (O(1) ops), insertion order\nPriorityQueue: Heap (O(log n) for offer/poll), priority order\nArrayList: Dynamic array (O(1) get/add at end, O(n) middle), insertion order",
      "All collections provide O(1) operations and maintain insertion order",
      "All collections use array backing and differ only in method names",
      "All collections provide the same ordering guarantees with different syntax",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each collection uses different internal structures optimized for specific use cases: TreeSet for sorted access, LinkedHashSet for fast access with order preservation, PriorityQueue for priority-based access, ArrayList for dynamic array operations",
      "This ignores the fundamental differences in implementation and performance",
      "This oversimplifies the diverse internal implementations",
      "This incorrectly suggests identical ordering behaviors",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 4,
    question:
      "Which collection methods should be used for these operations, considering exception handling?",
    answersList: [
      "Queue retrieval: poll() returns null if empty, remove() throws exception\nStack check: peek() returns null if empty, pop() throws exception\nList access: get(index) throws IndexOutOfBoundsException",
      "All methods throw exceptions when empty",
      "All methods return null when empty",
      "No methods throw exceptions or return null",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Java collections provide both safe (returning null) and unsafe (throwing exceptions) methods. Choose based on whether null is a valid response or if exceptions should signal errors.",
      "Some methods are designed to return null instead of throwing exceptions",
      "Some methods are designed to throw exceptions for better error handling",
      "All collections have defined behavior for empty/error cases",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 5,
    question:
      "Compare access patterns and performance characteristics of Map implementations in Java:",
    answersList: [
      "HashMap: O(1) average case operations, unordered\nTreeMap: O(log n) operations, sorted by keys\nLinkedHashMap: O(1) operations, maintains insertion order\nHashtable: O(1) operations, thread-safe, no null keys/values",
      "All Map implementations provide O(1) operations",
      "All Map implementations maintain insertion order",
      "All Map implementations sort elements by keys",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each Map implementation optimizes for different use cases: HashMap for raw speed, TreeMap for sorted access, LinkedHashMap for ordered iteration, Hashtable for thread safety",
      "This ignores the O(log n) operations in TreeMap's balanced tree structure",
      "Only LinkedHashMap specifically maintains insertion order",
      "Only TreeMap maintains key-based ordering",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 4,
    question: "Identify the correct deque operations for different scenarios:",
    code: "Deque<T> deque = new ArrayDeque<>();  // Consider operations at both ends",
    answersList: [
      "Add front: addFirst()/offerFirst() - throws/returns false if full\nAdd back: addLast()/offerLast() - throws/returns false if full\nRemove front: removeFirst()/pollFirst() - throws/returns null if empty\nRemove back: removeLast()/pollLast() - throws/returns null if empty",
      "Only supports add() and remove() operations",
      "Only supports push() and pop() operations",
      "All operations throw exceptions when full/empty",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Deque provides both exception-throwing (add/remove) and special value-returning (offer/poll) methods for both ends, allowing flexible error handling",
      "This understates Deque's rich API for both ends",
      "This confuses Deque with Stack operations",
      "This misrepresents Deque's error handling options",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 4,
    question:
      "Compare the special operations available in different Queue implementations:",
    answersList: [
      "PriorityQueue: Natural ordering or Comparator, O(log n) enqueue/dequeue\nArrayDeque: No ordering, O(1) operations at both ends\nLinkedList: Insertion order, O(1) end operations, implements both Queue and List\nConcurrentLinkedQueue: Thread-safe FIFO operations",
      "All Queue implementations provide identical operations",
      "All Queue implementations sort elements automatically",
      "All Queue implementations are thread-safe",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each Queue implementation offers unique features: PriorityQueue for ordered processing, ArrayDeque for efficient double-ended operations, LinkedList for combined List/Queue operations, ConcurrentLinkedQueue for thread safety",
      "Different Queue implementations optimize for different use cases",
      "Only PriorityQueue provides automatic element ordering",
      "Only certain Queue implementations (like ConcurrentLinkedQueue) are thread-safe",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 5,
    question:
      "What are the key distinctions between core collection interfaces in terms of ordering and duplicates?",
    answersList: [
      "List: Ordered, allows duplicates, indexed access\nSet: No duplicates, ordering varies by implementation (HashSet unordered, TreeSet sorted, LinkedHashSet insertion-ordered)\nQueue: FIFO by default, specialized ordering in PriorityQueue\nDeque: Double-ended, can be used as both FIFO queue and LIFO stack",
      "All interfaces maintain insertion order",
      "All interfaces prohibit duplicates",
      "All interfaces provide indexed access",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each interface serves different needs: List for ordered sequences with duplicates, Set for unique elements with various ordering options, Queue for processing sequences, Deque for double-ended access",
      "Different interfaces handle ordering differently",
      "Only Set prohibits duplicates",
      "Only List guarantees indexed access",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "What are common pitfalls when using an Iterator with a Collection during iteration?",
    code: 'List<String> list = new ArrayList<>();\nlist.add("A"); list.add("B"); list.add("C");\n\nIterator<String> iter = list.iterator();\nwhile(iter.hasNext()) {\n    String item = iter.next();\n    // What operations are safe here?\n}',
    answersList: [
      "Safe: iter.remove(), list.size()\nUnsafe: list.add(), list.remove(), list modification through any means except iterator",
      "Safe: list.add(), list.remove()\nUnsafe: iter.remove()",
      "All list modifications are safe during iteration",
      "No operations are safe during iteration",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Only iterator's own remove() method and non-modifying operations are safe during iteration. Direct collection modification will cause ConcurrentModificationException.",
      "Direct list modifications during iteration can cause ConcurrentModificationException",
      "Most modifications during iteration will cause errors",
      "Some operations like iterator's remove() are specifically designed for safe iteration modification",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "How would you convert between different collection types while preserving order?",
    code: "List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 1);\n// Need unique elements in insertion order",
    answersList: [
      "LinkedHashSet<Integer> ordered = new LinkedHashSet<>(numbers);  // Maintains order, removes duplicates",
      "HashSet<Integer> unordered = new HashSet<>(numbers);  // Loses order",
      "TreeSet<Integer> sorted = new TreeSet<>(numbers);  // Sorts elements",
      "ArrayList<Integer> duplicate = new ArrayList<>(numbers);  // Keeps duplicates",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "LinkedHashSet is ideal for maintaining insertion order while removing duplicates. Its constructor accepts any Collection and preserves the order of first appearance of each element.",
      "HashSet would remove duplicates but lose the original order",
      "TreeSet would sort elements rather than maintain insertion order",
      "ArrayList would maintain order but keep duplicates",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "Which synchronization approach is most appropriate for these multi-threaded scenarios?",
    answersList: [
      "High contention: ConcurrentHashMap, ConcurrentLinkedQueue\nLow contention: Collections.synchronizedList/Map/Set\nSingle producer/consumer: ArrayBlockingQueue\nMultiple producers/consumers: LinkedBlockingQueue",
      "Use synchronized collections for all scenarios",
      "Use concurrent collections for all scenarios",
      "No synchronization needed for collections",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Different scenarios need different synchronization: Concurrent collections for high throughput, synchronized wrappers for simple thread-safety, blocking collections for producer-consumer patterns",
      "Synchronized collections can be a bottleneck under high contention",
      "Concurrent collections may have overhead unnecessary for simple scenarios",
      "Unsynchronized collections are unsafe in multi-threaded contexts",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "How to efficiently perform bulk operations on collections?",
    code: 'List<String> source = Arrays.asList("A", "B", "C");\nList<String> target = new ArrayList<>();\n// Need to add all elements matching a condition',
    answersList: [
      'source.stream()\n    .filter(s -> s.matches("[AB]"))\n    .forEach(target::add);\n// Or: target.addAll(source.stream()\n    .filter(s -> s.matches("[AB]"))\n    .collect(Collectors.toList()));',
      'for(String s : source) {\n    if(s.matches("[AB]")) target.add(s);\n}',
      "target.addAll(source);",
      "source.forEach(target::add);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stream operations provide efficient, readable bulk operations with filtering, mapping, and collecting capabilities",
      "Traditional loop is more verbose and potentially less efficient",
      "addAll alone doesn't allow filtering",
      "forEach alone doesn't allow filtering",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 4,
    question:
      "Implement a custom Comparator for a PriorityQueue that handles null values safely:",
    code: "class Task {\n    String priority;  // can be null\n    long timestamp;\n}",
    answersList: [
      "PriorityQueue<Task> queue = new PriorityQueue<>((a, b) -> {\n    if (a.priority == b.priority) return Long.compare(a.timestamp, b.timestamp);\n    if (a.priority == null) return 1;  // nulls last\n    if (b.priority == null) return -1;\n    return a.priority.compareTo(b.priority);\n});",
      "PriorityQueue<Task> queue = new PriorityQueue<>(\n    (a, b) -> a.priority.compareTo(b.priority));\n",
      "PriorityQueue<Task> queue = new PriorityQueue<>();",
      "PriorityQueue<Task> queue = new PriorityQueue<>(\n    Comparator.comparing(Task::getPriority));",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "A proper Comparator should handle null values, provide consistent ordering, and handle secondary sorting criteria",
      "This will throw NullPointerException if priority is null",
      "Tasks aren't naturally comparable",
      "Comparing would throw NullPointerException on null priorities",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Identify and fix the performance issue in this collection usage:",
    code: "List<String> items = new LinkedList<>();\nfor(int i = 0; i < 1000000; i++) {\n    items.add(String.valueOf(i));\n}\nfor(int i = 0; i < items.size(); i++) {\n    String item = items.get(i);  // Process item\n}",
    answersList: [
      "Problem: O(n) access time for LinkedList.get(i)\nFix: Use ArrayList for random access or enhanced for-loop/iterator for LinkedList",
      "Problem: List is too large\nFix: Reduce size",
      "Problem: String conversion\nFix: Use integers",
      "No performance issue exists",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "LinkedList.get(i) requires traversing from start/end to index i. Use ArrayList for index-based access or iterator/enhanced for-loop for sequential access.",
      "Size isn't the primary issue; access pattern is",
      "String conversion isn't the main performance bottleneck",
      "There's a significant performance issue with random access on LinkedList",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "When using Collections utility methods, which operations are safe for unmodifiable collections?",
    code: "List<String> list = Collections.unmodifiableList(new ArrayList<>());",
    answersList: [
      "Safe: Collections.min(), max(), binarySearch(), frequency()\nUnsafe: Collections.sort(), shuffle(), reverse(), swap()",
      "All Collections utility methods are safe",
      "No Collections utility methods are safe",
      "Only add/remove operations are safe",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Non-modifying operations (searching, counting, finding min/max) are safe on unmodifiable collections. Modifying operations throw UnsupportedOperationException.",
      "Methods that modify the collection will throw exceptions",
      "Many utility methods that don't modify the collection are safe",
      "Add/remove operations throw UnsupportedOperationException",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 3,
    question:
      "How would you implement a fixed-size circular buffer using a Queue?",
    code: "// Need to maintain last N elements only",
    answersList: [
      "Queue<T> queue = new LinkedList<>();\n// On add:\nif (queue.size() >= N) queue.poll();\nqueue.offer(newElement);",
      "Queue<T> queue = new LinkedList<>();\nqueue.add(newElement);  // Just add",
      "Queue<T> queue = new ArrayDeque<>(N);  // Size limit enforced",
      "List<T> list = new ArrayList<>(N);  // Fixed size",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "This implementation maintains fixed size by removing oldest element (poll) when adding new element at capacity",
      "This doesn't maintain size limit",
      "ArrayDeque constructor capacity doesn't limit size",
      "ArrayList doesn't provide FIFO behavior needed for circular buffer",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "In a multi-threaded environment, what are the implications of different collection modification approaches?",
    code: "// Approach 1: synchronized (collection) { ... }\n// Approach 2: Collections.synchronizedList(list)\n// Approach 3: ConcurrentLinkedQueue\n// Approach 4: CopyOnWriteArrayList",
    answersList: [
      "1: External locking - good for compound operations\n2: Internal locking - simple but potential bottleneck\n3: Lock-free - high concurrency, weak consistency\n4: Copy-on-write - thread-safe reads, expensive writes",
      "All approaches provide the same thread safety",
      "No approach is thread-safe",
      "Only external synchronization is safe",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each approach has different performance/safety trade-offs: External locking for atomic operations, internal for simple safety, lock-free for throughput, copy-on-write for read-heavy scenarios",
      "Different approaches have different consistency and performance characteristics",
      "Each approach provides thread safety in different ways",
      "Multiple valid approaches exist for thread safety",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question: "Design a collection wrapper that logs all modifications:",
    code: "// Need to track all changes to a List<T>",
    answersList: [
      'class LoggingList<T> extends ArrayList<T> {\n    public boolean add(T e) {\n        System.out.println("Adding: " + e);\n        return super.add(e);\n    }\n    public T remove(int index) {\n        T element = get(index);\n        System.out.println("Removing: " + element);\n        return super.remove(index);\n    }\n    // Override other modifying methods similarly\n}',
      "Use normal ArrayList and log manually",
      "Use synchronized List for logging",
      "Use unmodifiable List for logging",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Extending ArrayList and overriding modification methods allows transparent logging while maintaining all List functionality",
      "Manual logging could be forgotten and isn't encapsulated",
      "Synchronization isn't related to logging",
      "Unmodifiable List prevents modifications entirely",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What will happen in this array list example?",
    code: 'ArrayList<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add("orange");\nfruits.add(1, "grape");\nSystem.out.println(fruits);',
    answersList: [
      "[apple, grape, banana, orange]",
      "[apple, banana, grape, orange]",
      "[grape, apple, banana, orange]",
      "[apple, orange, banana, grape]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "When adding 'grape' at index 1, it shifts existing elements right. Original 'banana' and 'orange' move over one position.",
      "This would be the result if grape was added at index 2",
      "This would be the result if grape was added at index 0",
      "This would be the result if elements were reordered randomly",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Which situation best demonstrates why you would use a Queue instead of an ArrayList?",
    answersList: [
      "Managing a printer's job list where documents should be printed in the order they were sent",
      "Storing a list of high scores that need to be sorted",
      "Keeping track of a user's most recent actions for an undo feature",
      "Storing a collection of unique usernames",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "A printer queue is a perfect example of FIFO (First In First Out) - first document sent should be first printed",
      "Sorted lists are better handled by other data structures like ArrayList with sorting",
      "Undo features typically use a Stack (LIFO) not a Queue",
      "Unique collections are better handled by Set implementations",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What would be the contents of the stack after these operations?",
    code: "Stack<Integer> numbers = new Stack<>();\nnumbers.push(1);\nnumbers.push(2);\nnumbers.pop();\nnumbers.push(3);\nnumbers.push(4);\nnumbers.pop();",
    answersList: ["[1, 3]", "[1, 2, 3]", "[3, 4]", "[1, 4]"],
    correctAnswerIndex: 0,
    explanationsList: [
      "Let's track it: push(1)=[1], push(2)=[1,2], pop()=[1], push(3)=[1,3], push(4)=[1,3,4], pop()=[1,3]",
      "This ignores the pop() operations",
      "This ignores the first element",
      "This ignores the middle operations",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Remembering",
    difficulty: 1,
    question:
      "Which operation would you use to check the next element in a Queue without removing it?",
    answersList: ["peek()", "pop()", "next()", "get()"],
    correctAnswerIndex: 0,
    explanationsList: [
      "peek() looks at the front element without removing it - perfect for checking what's next",
      "pop() is a Stack operation that removes the element",
      "next() is used with iterators, not directly with queues",
      "get() is used with List implementations, not Queue",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "In a Queue of customers waiting for service, what would this code do?",
    code: 'Queue<String> customerLine = new LinkedList<>();\ncustomerLine.add("Alice");\ncustomerLine.add("Bob");\ncustomerLine.add("Charlie");\nString nextCustomer = customerLine.poll();\nSystem.out.println("Now serving: " + nextCustomer);\nSystem.out.println("Remaining in line: " + customerLine);',
    answersList: [
      "Now serving: Alice\nRemaining in line: [Bob, Charlie]",
      "Now serving: Charlie\nRemaining in line: [Alice, Bob]",
      "Now serving: Bob\nRemaining in line: [Alice, Charlie]",
      "Now serving: Alice\nRemaining in line: [Charlie, Bob]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "poll() removes and returns the first customer (Alice) who joined the queue, following FIFO principle",
      "This would violate FIFO order by serving the last person first",
      "This would incorrectly serve someone from the middle",
      "This would incorrectly reorder the remaining customers",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Which data structure would best store the sequence of web pages visited for a browser's back button?",
    answersList: [
      "Stack - because you want to go back to the most recently visited pages first",
      "Queue - because you want to visit pages in the order they were first seen",
      "ArrayList - because you need random access to pages",
      "LinkedList - because you need to add pages in the middle",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Back button follows LIFO (Last In First Out) - you want to go back to the most recent page first",
      "Queue's FIFO behavior wouldn't match how users expect the back button to work",
      "Random access isn't needed for back button functionality",
      "Adding pages in the middle isn't a requirement for back button functionality",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What is wrong with this code for storing student grades?",
    code: "Stack<Double> grades = new Stack<>();\ngrades.push(85.5);\ngrades.push(90.0);\ngrades.push(77.5);\n// Later: need to calculate average",
    answersList: [
      "Stack is a poor choice because accessing all elements requires removing them; ArrayList would be better for storing grades",
      "The grades should be stored as integers not doubles",
      "Stack cannot store decimal numbers",
      "The code has a syntax error",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stack's LIFO nature makes it awkward to process all grades; ArrayList provides easier access for calculations",
      "Decimal grades are valid and appropriately stored as doubles",
      "Stack can store any object type including decimals",
      "The code is syntactically correct",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "How would an ArrayList behave differently from a LinkedList when adding elements to the beginning?",
    answersList: [
      "ArrayList must shift all existing elements right, while LinkedList just updates a few references",
      "ArrayList is always faster than LinkedList",
      "LinkedList must shift all elements right, while ArrayList just updates a few references",
      "There is no difference between them",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList's array structure requires shifting elements, making insertion at the beginning slow with large lists. LinkedList just updates next/previous references.",
      "ArrayList is faster for random access but slower for insertions at the beginning",
      "This reverses the actual behavior of these data structures",
      "There are significant differences in how they handle insertions",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What would this code print when processing a list of tasks?",
    code: 'Queue<String> taskQueue = new LinkedList<>();\ntaskQueue.offer("Send email");\ntaskQueue.offer("Update database");\ntaskQueue.offer("Generate report");\n\nSystem.out.println(taskQueue.peek());\ntaskQueue.poll();\nSystem.out.println(taskQueue);',
    answersList: [
      "Send email\n[Update database, Generate report]",
      "Generate report\n[Send email, Update database]",
      "Send email\n[Send email, Update database, Generate report]",
      "Update database\n[Update database, Generate report]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "peek() shows first task without removing it, then poll() removes it, leaving the other tasks",
      "This would show the last task, violating FIFO order",
      "This would show the tasks without removing any",
      "This would skip the first task incorrectly",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What makes ArrayList different from a regular array?",
    answersList: [
      "ArrayList can grow in size dynamically while an array has fixed size",
      "ArrayList can only store numbers while arrays can store any type",
      "ArrayList is slower for all operations",
      "ArrayList can only store strings",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList's key advantage is automatic resizing - you don't need to specify a fixed size like with arrays",
      "Both ArrayList and arrays can store any object type",
      "ArrayList operations are often as fast as array operations",
      "ArrayList can store any object type, not just strings",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What will happen when this code runs?",
    code: "ArrayList<Integer> numbers = new ArrayList<>();\nnumbers.add(1);\nnumbers.add(null);\nnumbers.add(2);\nint value = numbers.get(1);",
    answersList: [
      "It will throw a NullPointerException because you can't convert null to int",
      "It will print null",
      "It will print 0",
      "It will print 2",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "When auto-unboxing null from Integer to int, a NullPointerException occurs. This is a common beginner mistake with collections of primitive types.",
      "int is a primitive type and can't hold null",
      "null doesn't automatically convert to 0 for primitives",
      "The value at index 1 is null, not 2",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "What's the difference between these two ways of creating an ArrayList?",
    code: "// Method 1\nArrayList<String> list1 = new ArrayList<>();\n\n// Method 2\nArrayList<String> list2 = new ArrayList<>(100);",
    answersList: [
      "Method 2 pre-allocates space for 100 elements for better performance, but both can grow beyond that size",
      "Method 2 limits the list to exactly 100 elements",
      "Method 2 requires exactly 100 elements to be added",
      "There is no difference between the methods",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The number in ArrayList constructor is just an initial capacity for performance optimization. The list can still grow or shrink as needed.",
      "ArrayList can always grow beyond its initial capacity",
      "You can add any number of elements regardless of initial capacity",
      "Initial capacity can affect performance with large lists",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 1,
    question: "What's wrong with this code for finding a student's grade?",
    code: 'ArrayList<Double> grades = new ArrayList<>();\ngrades.add(95.5);\ngrades.add(87.0);\ngrades.add(92.5);\nif (grades[1] > 90.0) {  // Check second grade\n    System.out.println("Great job!");\n}',
    answersList: [
      "ArrayList doesn't use [] for access; should use grades.get(1)",
      "The grades should be stored as integers",
      "The comparison operator is wrong",
      "ArrayList can't store decimal numbers",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Square bracket notation [] is for arrays. ArrayList uses methods like get(index) to access elements.",
      "Decimal grades are valid and appropriate here",
      "The comparison operator > is correct",
      "ArrayList can store any object type including Double",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "What's the correct way to loop through all elements in an ArrayList?",
    code: 'ArrayList<String> names = new ArrayList<>();\nnames.add("Alice");\nnames.add("Bob");\nnames.add("Charlie");',
    answersList: [
      "for (String name : names) {\n    System.out.println(name);\n}",
      "for (i = 1; i <= names.length; i++) {\n    System.out.println(names[i]);\n}",
      "while (names.hasNext()) {\n    System.out.println(names.next());\n}",
      "for (i = 0; i < names.length(); i++) {\n    System.out.println(names.get(i));\n}",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "The enhanced for loop (for-each) is the simplest and safest way to iterate through a collection",
      "This uses array syntax which doesn't work with ArrayList",
      "This uses iterator syntax directly which isn't correct",
      "ArrayList uses size(), not length() or length",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What will this print when storing student names in groups?",
    code: 'ArrayList<ArrayList<String>> groups = new ArrayList<>();\n\nArrayList<String> group1 = new ArrayList<>();\ngroup1.add("Alice");\ngroup1.add("Bob");\n\ngroups.add(group1);\nSystem.out.println(groups.get(0).get(1));',
    answersList: [
      "Bob",
      "Alice",
      "Will throw an IndexOutOfBoundsException",
      "[Alice, Bob]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "groups.get(0) gets the first group, then get(1) gets the second student (Bob) from that group",
      "get(1) returns the second element, not the first",
      "The indexes are within bounds",
      "This would print the whole group, not a single element",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "How would you check if a student's name is in the class list?",
    code: 'ArrayList<String> classList = new ArrayList<>();\nclassList.add("Alice");\nclassList.add("Bob");\nclassList.add("Charlie");',
    answersList: [
      'boolean isEnrolled = classList.contains("Bob");',
      'boolean isEnrolled = classList.find("Bob");',
      'boolean isEnrolled = classList.has("Bob");',
      'boolean isEnrolled = classList.exists("Bob");',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "contains() is the standard method to check if an element exists in any collection",
      "find() isn't a method in ArrayList",
      "has() isn't a method in ArrayList",
      "exists() isn't a method in ArrayList",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "How would you sort a list of student grades from highest to lowest?",
    code: "ArrayList<Double> grades = new ArrayList<>();\ngrades.add(88.5);\ngrades.add(94.0);\ngrades.add(91.5);",
    answersList: [
      "Collections.sort(grades, Collections.reverseOrder());",
      "grades.sort();",
      "grades.reverse();",
      "Collections.reverse(grades);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Collections.sort() with reverseOrder() sorts in descending order. This works because Double implements Comparable.",
      "ArrayList doesn't have a sort() method without arguments",
      "reverse() only reverses order, doesn't sort",
      "This would only reverse the current order, not sort",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What's the problem with this attendance tracking code?",
    code: 'ArrayList<String> present = new ArrayList<>();\npresent.add("Alice");\npresent.add("Bob");\n\nfor (String student : present) {\n    if (student.equals("Bob")) {\n        present.remove(student);\n    }\n}',
    answersList: [
      "You can't modify an ArrayList while using a for-each loop to iterate through it",
      "The equals() method is wrong for comparing strings",
      "The remove() method doesn't exist for ArrayList",
      "You can't remove strings from an ArrayList",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Modifying a collection while iterating through it with for-each can cause ConcurrentModificationException. Use a regular for loop or iterator instead.",
      "equals() is correct for String comparison",
      "remove() is a valid ArrayList method",
      "ArrayList can remove any type of element",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's the difference between these two lines of code?",
    code: "ArrayList<Integer> list1 = new ArrayList<Integer>();\nArrayList list2 = new ArrayList();",
    answersList: [
      "list1 can only store Integer objects while list2 can store any object type but isn't type-safe",
      "list1 is slower than list2",
      "list1 can store more elements than list2",
      "There is no difference",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Using generics (like <Integer>) provides type safety at compile time. Without generics, the list can store any type but might cause runtime errors.",
      "Generics don't affect performance",
      "Both can store the same number of elements",
      "The difference in type safety is significant",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "After these operations, what is the size of the list?",
    code: 'ArrayList<String> names = new ArrayList<>(100);\nnames.add("Alice");\nnames.add("Bob");\nnames.add("Charlie");\nnames.remove(1);\nSystem.out.println(names.size());',
    answersList: ["2", "100", "3", "99"],
    correctAnswerIndex: 0,
    explanationsList: [
      "size() returns the number of elements (3 added - 1 removed = 2), not the capacity (100)",
      "The initial capacity doesn't affect size",
      "This would be the size without the remove operation",
      "Capacity and size are different concepts",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Looking at this drawing of a stack of books, what would peek() return and what would the stack look like after pop()?",
    code: 'Stack<String> books = new Stack<>();\nbooks.push("Math");\nbooks.push("History");\nbooks.push("Science");\n\n// Current stack (top to bottom):\n// [Science]\n// [History]\n// [Math]',
    answersList: [
      'peek() returns "Science"\nAfter pop(): [History, Math]',
      'peek() returns "Math"\nAfter pop(): [Science, History]',
      'peek() returns "Science"\nAfter pop(): [Science, History, Math]',
      'peek() returns "Math"\nAfter pop(): [History, Science]',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "In a stack, peek() looks at the top item (Science) without removing it. pop() removes the top item, leaving History and Math.",
      "Math is at the bottom, not the top",
      "pop() removes the top element, it wouldn't stay in the stack",
      "This shows incorrect order and removal",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Which operation would produce this result in a cafeteria line queue?",
    code: "Initial queue: [Tom, Sarah, James]\nOperation happens...\nFinal queue: [Sarah, James]",
    answersList: [
      "poll() or remove() - takes the first person from the line",
      "peek() - looks at the first person",
      'add("Sarah") - adds to the end of the line',
      "clear() - removes everyone from the line",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "poll() or remove() removes the first element (Tom) from the queue, just like the first person leaving a line",
      "peek() only looks at the first element, doesn't remove it",
      "add() would add to the end, not remove from front",
      "clear() would remove all elements, not just the first",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "What happens when trying to find an element's position in an empty list?",
    code: 'ArrayList<String> empty = new ArrayList<>();\nSystem.out.println(empty.indexOf("test"));',
    answersList: [
      "-1",
      "0",
      "Throws NullPointerException",
      "Throws IndexOutOfBoundsException",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "indexOf() returns -1 when the element isn't found, even in an empty list. No exception is thrown.",
      "0 would incorrectly indicate the element was found at the beginning",
      "Empty lists are valid and don't cause NullPointerException for indexOf",
      "indexOf searches safely without throwing exceptions",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "How would you convert this array of grades into an ArrayList?",
    code: "double[] grades = {95.5, 88.0, 92.5};\n// Need to store in an ArrayList",
    answersList: [
      "ArrayList<Double> gradeList = new ArrayList<>();\nfor (double grade : grades) {\n    gradeList.add(grade);\n}",
      "ArrayList<Double> gradeList = new ArrayList<>(grades);",
      "ArrayList<Double> gradeList = Arrays.toArrayList(grades);",
      "ArrayList<Double> gradeList = (ArrayList<Double>)grades;",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "You need to add each element individually, using autoboxing to convert double to Double. A loop is the simplest way.",
      "The ArrayList constructor can't directly take an array of primitives",
      "Arrays.toArrayList isn't a real method",
      "You can't cast an array to ArrayList",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "What happens in each case when trying to remove from an empty collection?",
    code: "Stack<String> stack = new Stack<>();\nQueue<String> queue = new LinkedList<>();\nArrayList<String> list = new ArrayList<>();\n\n// What happens with:\nstack.pop();\nqueue.remove();\nlist.remove(0);",
    answersList: [
      "All three throw exceptions (EmptyStackException, NoSuchElementException, IndexOutOfBoundsException)",
      "All return null",
      "All work fine and do nothing",
      "Only stack.pop() throws an exception",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Empty collections throw exceptions when attempting to remove elements because there's nothing to remove",
      "These methods throw exceptions rather than return null",
      "Removing from empty collections isn't allowed",
      "All three operations throw exceptions when empty",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What would this waiting line code print?",
    code: 'Queue<String> line = new LinkedList<>();\nSystem.out.println(line.peek());\nline.offer("Person 1");\nSystem.out.println(line.peek());\nline.poll();\nSystem.out.println(line.peek());',
    answersList: [
      "null\nPerson 1\nnull",
      "Person 1\nPerson 1\nPerson 1",
      "Exception\nPerson 1\nException",
      "Person 1\nnull\nPerson 1",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "First peek(): empty queue returns null\nSecond peek(): shows Person 1\nAfter poll(): empty again, returns null",
      "Queue starts empty and ends empty",
      "peek() returns null for empty queue, doesn't throw exception",
      "Elements are removed by poll()",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What's the difference in behavior between these two methods?",
    code: 'void method1(ArrayList<String> list) {\n    list.add("new item");\n}\n\nvoid method2(ArrayList<String> list) {\n    list = new ArrayList<>();\n    list.add("new item");\n}',
    answersList: [
      "method1 modifies the original list, method2's changes aren't seen by the caller",
      "method2 modifies the original list, method1's changes aren't seen by the caller",
      "Both methods modify the original list",
      "Neither method modifies the original list",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "method1 modifies the list passed in, while method2 creates a new list that only exists within the method",
      "Creating a new ArrayList breaks the reference to the original list",
      "method2's new ArrayList isn't visible outside",
      "method1 definitely modifies the original list",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "If you have these to-do items, what's the correct way to get a portion of the list?",
    code: 'ArrayList<String> todos = new ArrayList<>();\ntodos.add("Homework");\ntodos.add("Laundry");\ntodos.add("Groceries");\ntodos.add("Gym");\n// Want: just Laundry and Groceries',
    answersList: [
      "List<String> portion = todos.subList(1, 3);",
      "List<String> portion = todos.subList(1, 2);",
      "List<String> portion = todos.get(1, 3);",
      "List<String> portion = todos.getPortion(1, 3);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "subList(fromIndex, toIndex) gets elements from index 1 (Laundry) up to but not including index 3 (Gym)",
      "This would only get Laundry",
      "get() only retrieves single elements",
      "getPortion() isn't a real method",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's the result of searching for elements in this list?",
    code: 'ArrayList<String> names = new ArrayList<>();\nnames.add("Alice");\nnames.add("Bob");\nnames.add("Alice");\nnames.add("Charlie");\n\nSystem.out.println(names.indexOf("Alice"));\nSystem.out.println(names.lastIndexOf("Alice"));',
    answersList: ["0\n2", "0\n0", "2\n2", "-1\n-1"],
    correctAnswerIndex: 0,
    explanationsList: [
      "indexOf finds first occurrence (index 0), lastIndexOf finds last occurrence (index 2)",
      "This would mean both found only the first occurrence",
      "This would mean both found only the last occurrence",
      "This would mean Alice wasn't found at all",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "How would you combine these two guest lists into one?",
    code: 'ArrayList<String> list1 = new ArrayList<>();\nlist1.add("Alice");\nlist1.add("Bob");\n\nArrayList<String> list2 = new ArrayList<>();\nlist2.add("Charlie");\nlist2.add("David");',
    answersList: [
      "list1.addAll(list2);  // list1 now contains all guests",
      "list1.add(list2);  // doesn't work",
      "list1 = list1 + list2;  // doesn't work",
      "list1.concat(list2);  // doesn't exist",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "addAll() adds all elements from one collection to another",
      "add() can't take a whole list as an argument",
      "Can't use + operator with ArrayLists",
      "concat() is for Strings, not ArrayLists",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's wrong with this for loop for printing student names?",
    code: 'ArrayList<String> students = new ArrayList<>();\nstudents.add("Alice");\nstudents.add("Bob");\nstudents.add("Charlie");\n\nfor (int i = 1; i <= students.size(); i++) {\n    System.out.println(students.get(i));\n}',
    answersList: [
      "Loop starts at 1 instead of 0, and uses <= instead of <, causing wrong indexing",
      "The get() method is wrong",
      "The size() method is wrong",
      "The println is wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Two common mistakes: 1) ArrayList indexes start at 0, not 1 2) Using <= with size() will try to access one position too many",
      "get() is the correct method for accessing elements",
      "size() correctly returns number of elements",
      "println correctly prints elements",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "In this diagram of a queue of customers, what happens after each operation?",
    code: "Queue: [Ann  Bob  Cal  Dan]\n\nOperation 1: peek()\nOperation 2: poll()\nOperation 3: peek()",
    answersList: [
      '1: Returns "Ann", queue unchanged\n2: Returns "Ann", queue becomes [Bob  Cal  Dan]\n3: Returns "Bob", queue unchanged',
      '1: Returns "Dan", queue unchanged\n2: Returns "Dan", queue changes\n3: Returns "Cal", queue unchanged',
      '1: Returns "Ann", queue changed\n2: Returns "Bob", queue changes\n3: Returns "Cal", queue unchanged',
      "1: Queue becomes empty\n2: Returns null\n3: Returns null",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "peek() looks at first person (Ann) without removing them, poll() removes Ann, then peek() shows new first person (Bob)",
      "Queue processes from front (Ann) not back (Dan)",
      "peek() doesn't change the queue",
      "Operations don't empty the queue",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 1,
    question:
      "How would you safely add a grade to this list only if it's valid (0-100)?",
    code: "ArrayList<Double> grades = new ArrayList<>();",
    answersList: [
      "if (grade >= 0 && grade <= 100) {\n    grades.add(grade);\n}",
      "grades.add(grade);  // add without checking",
      "if (grade) {\n    grades.add(grade);\n}",
      "grades.addIfValid(grade);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Check the grade range before adding. This prevents invalid grades from being added.",
      "Adding without validation could store invalid grades",
      "This isn't valid Java syntax for checking numbers",
      "addIfValid() isn't a real ArrayList method",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What's the difference between these two ways of copying a list?",
    code: 'ArrayList<String> original = new ArrayList<>();\noriginal.add("A");\noriginal.add("B");\n\n// Method 1:\nArrayList<String> copy1 = new ArrayList<>(original);\n\n// Method 2:\nArrayList<String> copy2 = original;',
    answersList: [
      "Method 1 creates a new list with copied elements, Method 2 just creates another reference to the same list",
      "Method 1 and Method 2 both create separate copies",
      "Method 1 creates a reference, Method 2 creates a copy",
      "There is no difference between the methods",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Method 1 creates an actual copy where changes don't affect original, Method 2 means both variables point to the same list",
      "Method 2 doesn't create a copy",
      "Method 1 creates a copy, not just a reference",
      "The methods have very different effects",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What happens when trying these list operations?",
    code: 'ArrayList<String> names = new ArrayList<>();\nnames.add("Alice").add("Bob");',
    answersList: [
      "Causes an error because add() returns boolean, not the list",
      "Successfully adds both names",
      "Only adds Alice",
      "Only adds Bob",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "add() returns boolean (success/failure), not the list itself, so you can't chain add() calls like this",
      "Method chaining doesn't work with add()",
      "The error occurs before any adding happens",
      "The error occurs before any adding happens",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What's the state of this stack after these book operations?",
    code: 'Stack<String> books = new Stack<>();\n\nbooks.push("Math");\nbooks.peek();\nbooks.push("History");\nbooks.pop();\nbooks.push("Science");\n\n// Draw the stack from top to bottom:',
    answersList: [
      "Science\nMath",
      "Math\nScience",
      "Science\nHistory\nMath",
      "Math\nHistory\nScience",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Let's track it: push Math, peek (no change), push History, pop removes History, push Science. Final state has Science on top of Math.",
      "This shows wrong order",
      "History was removed by pop()",
      "This shows wrong order and extra book",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "How would you safely remove all grades below 60 from this list?",
    code: "ArrayList<Double> grades = new ArrayList<>();\ngrades.add(85.5);\ngrades.add(45.0);\ngrades.add(90.0);\ngrades.add(55.5);",
    answersList: [
      "for (int i = grades.size() - 1; i >= 0; i--) {\n    if (grades.get(i) < 60) {\n        grades.remove(i);\n    }\n}",
      "for (Double grade : grades) {\n    if (grade < 60) {\n        grades.remove(grade);\n    }\n}",
      "while (grades.contains(grade < 60)) {\n    grades.remove(grade);\n}",
      "grades.removeIf(grade < 60);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Removing while iterating is safe when going backwards through the list. Going forward can skip elements after removal.",
      "Can't modify list while using for-each loop",
      "This isn't valid Java syntax",
      "This isn't valid Java syntax for removeIf",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's the difference between these two list comparisons?",
    code: 'ArrayList<String> list1 = new ArrayList<>();\nlist1.add("A"); list1.add("B");\n\nArrayList<String> list2 = new ArrayList<>();\nlist2.add("A"); list2.add("B");\n\nSystem.out.println(list1 == list2);\nSystem.out.println(list1.equals(list2));',
    answersList: [
      "== checks if it's the same list object, equals() checks if contents are the same. Prints: false, true",
      "Both print true",
      "Both print false",
      "== checks contents, equals() checks object. Prints: true, false",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "== compares object references (different lists = false), equals() compares contents (same contents = true)",
      "== will be false for different objects",
      "equals() will be true for same contents",
      "This reverses how == and equals() work",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What happens with these array and ArrayList size checks?",
    code: "String[] array = new String[5];\nArrayList<String> list = new ArrayList<>();\n\nSystem.out.println(array.length);\nSystem.out.println(list.size());",
    answersList: ["5\n0", "0\n0", "5\n5", "null\nnull"],
    correctAnswerIndex: 0,
    explanationsList: [
      "array.length shows capacity (5), list.size() shows actual elements (0 since nothing added)",
      "array.length shows fixed capacity of 5",
      "ArrayList starts empty regardless of any initial capacity",
      "length and size() return numbers, not null",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "In this cafeteria line simulation, what's wrong with the code?",
    code: 'Queue<String> line = new LinkedList<>();\n\n// Someone tries to cut in line:\nline.add("New Person");  // Add to end\nline.add(0, "Line Cutter");  // Try to add at front',
    answersList: [
      "Queue doesn't support adding at specific positions - it's first in, first out only",
      "The add() method is wrong",
      "Should use push() instead",
      "The index 0 is wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Queues maintain strict FIFO order. Can't insert at specific positions even though LinkedList might support it.",
      "First add() is correct for Queue",
      "push() is for Stack, not Queue",
      "The concept of adding at position is wrong for Queue",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's the difference between these two list situations?",
    code: '// Situation 1:\nArrayList<String> list1 = null;\n\n// Situation 2:\nArrayList<String> list2 = new ArrayList<>();\n\nSystem.out.println("Can add to list1? " + (list1 != null));\nSystem.out.println("Can add to list2? " + (list2 != null));\nSystem.out.println("List2 is empty? " + list2.isEmpty());',
    answersList: [
      "list1 is null (not initialized), can't call methods on it\nlist2 is empty but initialized, can call methods on it",
      "Both lists are empty and can be used",
      "Both lists are null and can't be used",
      "list1 is empty, list2 is null",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "null means no object exists yet (will cause NullPointerException if used). Empty means object exists but contains no elements.",
      "list1 will cause errors if used",
      "list2 is properly initialized",
      "This reverses their actual states",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Why does this code cause an error and how would you fix it?",
    code: "ArrayList<int> numbers = new ArrayList<>();\nnumbers.add(5);\nnumbers.add(10);\nSystem.out.println(numbers);",
    answersList: [
      "Error: Can't use primitive type 'int'. Fix: Use ArrayList<Integer> instead",
      "Error: Numbers can't go in ArrayList. Fix: Use String instead",
      "Error: add() method is wrong. Fix: Use push()",
      "Error: println won't work. Fix: Use print()",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Collections can only store objects, not primitives. Integer is the object wrapper for int.",
      "ArrayList can store numbers using proper type",
      "add() is correct for ArrayList",
      "println works fine with ArrayList",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Which list initialization would you use for storing student names and why?",
    code: '// Option 1:\nArrayList<String> names1 = new ArrayList<>();\n\n// Option 2:\nArrayList<String> names2 = new ArrayList<>(20);\n\n// Option 3:\nArrayList<String> names3 = Arrays.asList("Alice", "Bob");\n\n// Option 4:\nArrayList<String> names4 = null;',
    answersList: [
      "Option 1 for small/unknown number of names\nOption 2 if you know you need space for 20 names\nOption 3 for fixed initial names\nOption 4 is incorrect - never initialize as null",
      "Option 4 is best practice",
      "Option 2 limits list to exactly 20 names",
      "Option 3 is only for single names",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each initialization has its use: default for flexibility, capacity for performance, Arrays.asList for initial data. Null initialization should be avoided.",
      "Null initialization leads to errors",
      "Initial capacity is not a limit",
      "Arrays.asList can take multiple elements",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What will this error message mean when running this code?",
    code: 'ArrayList<String> names = new ArrayList<>();\nnames.add("Alice");\nSystem.out.println(names.get(1));\n\n// Error: IndexOutOfBoundsException: Index 1 out of bounds for length 1',
    answersList: [
      "Trying to access index 1 (second element) when list only has 1 element (index 0)",
      "The list is empty",
      "get() method is wrong",
      "Can't store strings in ArrayList",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Common error: forgetting that indexes start at 0, so index 1 is the second position",
      "List has one element",
      "get() is correct method",
      "ArrayList can store strings",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "What's the correct way to convert this array to an ArrayList?",
    code: 'String[] names = {"Alice", "Bob", "Charlie"};\n// Need a modifiable ArrayList',
    answersList: [
      "ArrayList<String> list = new ArrayList<>();\nCollections.addAll(list, names);\n// or\nArrayList<String> list = new ArrayList<>(Arrays.asList(names));",
      "ArrayList<String> list = (ArrayList<String>)names;",
      "ArrayList<String> list = names.toArrayList();",
      "ArrayList<String> list = Arrays.arrayToList(names);",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Both methods properly convert array to modifiable ArrayList. Arrays.asList alone would give unmodifiable list.",
      "Can't cast array to ArrayList",
      "toArrayList() isn't a real method",
      "arrayToList() isn't a real method",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What happens in this queue when processing students for help?",
    code: 'Queue<String> helpQueue = new LinkedList<>();\nhelpQueue.offer("Alice"); // Alice arrives\nhelpQueue.offer("Bob");   // Bob arrives\nString next = helpQueue.peek(); // Who\'s next?\nhelpQueue.offer("Charlie"); // Charlie arrives\nhelpQueue.poll();  // Help first student\nSystem.out.println("Next in line: " + helpQueue.peek());',
    answersList: [
      "Next in line: Bob (Alice was helped, Bob moved to front)",
      "Next in line: Alice (hasn't been helped yet)",
      "Next in line: Charlie (most recent arrival)",
      "Next in line: null (queue is empty)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Track it: Alice,Bob,Charlie added in order, peek shows Alice, poll removes Alice, Bob is now first",
      "Alice was removed by poll()",
      "Queue maintains FIFO order",
      "Queue still has two students",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's wrong with updating grades this way?",
    code: "ArrayList<Double> grades = new ArrayList<>();\ngrades.add(85.5);\ngrades.add(90.0);\n\n// Try to update first grade:\ngrades[0] = 87.5;",
    answersList: [
      "ArrayList doesn't use [] syntax. Should be: grades.set(0, 87.5);",
      "Can't change grades once added",
      "Should use add() instead",
      "Double can't be updated",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "[] syntax is for arrays. ArrayList uses methods like set() to update elements",
      "ArrayList elements can be modified",
      "add() adds new elements, doesn't update existing ones",
      "Double values can be updated",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What would each operation return in this sequence?",
    code: 'Stack<String> books = new Stack<>();\n\nSystem.out.println(books.empty());\nbooks.push("Book1");\nSystem.out.println(books.empty());\nSystem.out.println(books.peek());\nbooks.pop();\nSystem.out.println(books.empty());',
    answersList: [
      "true\nfalse\nBook1\ntrue",
      "false\ntrue\nBook1\nfalse",
      "null\nBook1\nBook1\nnull",
      "empty\nfull\nBook1\nempty",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "empty() returns true for new stack, false after push, peek shows Book1, true after pop removes only book",
      "Initial stack is empty (true)",
      "empty() returns boolean not null",
      "empty() returns boolean not string",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "How would you properly replace a student's name in this list?",
    code: 'ArrayList<String> students = new ArrayList<>();\nstudents.add("Alice");\nstudents.add("Bob");\nstudents.add("Charlie");\n\n// Need to replace "Bob" with "Bobby"',
    answersList: [
      'int index = students.indexOf("Bob");\nif (index != -1) {\n    students.set(index, "Bobby");\n}',
      'students.replace("Bob", "Bobby");',
      'students[1] = "Bobby";',
      'students.update("Bob", "Bobby");',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Find index of 'Bob' first (checking if exists), then use set() to replace at that index",
      "replace() isn't an ArrayList method",
      "[] syntax doesn't work with ArrayList",
      "update() isn't an ArrayList method",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Which method should you use to remove all elements from a collection?",
    code: "ArrayList<String> list = new ArrayList<>();\nStack<Integer> stack = new Stack<>();\nQueue<Double> queue = new LinkedList<>();\n\n// Need to empty all collections",
    answersList: [
      "list.clear();\nstack.clear();\nqueue.clear();\n// All collections have clear()",
      "list.removeAll();\nstack.removeAll();\nqueue.removeAll();",
      "list.empty();\nstack.empty();\nqueue.empty();",
      "list = null;\nstack = null;\nqueue = null;",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "clear() is the standard method for all collections to remove all elements",
      "removeAll() needs a collection parameter",
      "empty() checks if empty, doesn't clear",
      "Setting to null doesn't clear, just loses reference",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Track this Stack's state after each operation. What does it look like?",
    code: 'Stack<String> cards = new Stack<>();\n\n// Draw each state after these operations:\ncards.push("Ace");   // State 1\ncards.push("King");  // State 2\ncards.pop();         // State 3\ncards.push("Queen"); // State 4\ncards.peek();        // State 5',
    answersList: [
      "State 1: [Ace]\nState 2: [Ace, King]\nState 3: [Ace]\nState 4: [Ace, Queen]\nState 5: [Ace, Queen] (peek doesn't change stack)",
      "State 1: [Ace]\nState 2: [King, Ace]\nState 3: [Ace]\nState 4: [Queen, Ace]\nState 5: [Ace]",
      "State 1: [Ace]\nState 2: [Ace, King]\nState 3: [King]\nState 4: [King, Queen]\nState 5: [Queen]",
      "All states empty after pop()",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Track each step: push adds to top, pop removes top item, peek just looks. Bottom element (Ace) stays in place.",
      "Stack keeps elements in LIFO order",
      "pop() removes top element only",
      "pop() only removes one element",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Which collection should you use in these real situations?",
    code: "Situation 1: Students lining up for lunch\nSituation 2: Browser back button history\nSituation 3: Class roster with random access\nSituation 4: Undo operations in a text editor",
    answersList: [
      "1: Queue (FIFO for fair line)\n2: Stack (LIFO for back button)\n3: ArrayList (index access for roster)\n4: Stack (LIFO for undo)",
      "1: Stack\n2: Queue\n3: Stack\n4: Queue",
      "1: ArrayList\n2: ArrayList\n3: Queue\n4: ArrayList",
      "All situations should use ArrayList",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each situation matches a collection's natural behavior: Queue for lines, Stack for history/undo, ArrayList for random access",
      "These matchings don't fit the natural behaviors",
      "Random access isn't needed for most cases",
      "Different situations need different behaviors",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Find the error(s) in this code for managing a playlist:",
    code: 'Stack<String> playlist = new Stack<>();\n\n// Add songs\nplaylist.push("Song1");\nplaylist.push("Song2");\n\n// Try to play next song\nString nextSong = playlist.peek();\nSystem.out.println("Now playing: " + nextSong);\n\n// Remove from playlist\nplaylist.remove(0);  // Try to remove from bottom\n',
    answersList: [
      "Stack is wrong choice for playlist (should be Queue), and remove(0) breaks Stack's LIFO principle - use pop() instead",
      "push() is wrong method for adding songs",
      "peek() is wrong method for getting next song",
      "The print statement is wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Two issues: 1) Playlist should play in order (FIFO/Queue) not reverse order (LIFO/Stack) 2) Stack elements should be removed with pop(), not remove(index)",
      "push() is correct for Stack operations",
      "peek() correctly shows top element",
      "Print statement is fine",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Which error message will this code produce and why?",
    code: 'ArrayList<String> names = new ArrayList<>();\nnames.add("Alice");\nnames.add("Bob");\n\nfor(int i = 0; i <= names.size(); i++) {\n    System.out.println(names.get(i));\n}',
    answersList: [
      "IndexOutOfBoundsException on last iteration because <= means loop tries to access index 2 when only indices 0,1 exist",
      "NullPointerException because names is null",
      "ArrayIndexOutOfBoundsException because array is too small",
      "No error will occur",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Common loop mistake: <= with size() tries to access past last element. Use < instead of <=.",
      "names is properly initialized",
      "ArrayList isn't an array",
      "Will definitely cause exception",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "How would you fix this code for adding grades safely?",
    code: "ArrayList<Double> grades = new ArrayList<>();\n\n// Current code (problematic):\ngrades.add(85.5);\ngrades.add(-10.0);  // Invalid grade\ngrades.add(105.0); // Invalid grade\ngrades.add(92.5);",
    answersList: [
      'public static void addGrade(ArrayList<Double> grades, double grade) {\n    if (grade >= 0 && grade <= 100) {\n        grades.add(grade);\n    } else {\n        System.out.println("Invalid grade: " + grade);\n    }\n}',
      "Just add all grades without checking",
      "Remove ArrayList and use array instead",
      "Use Stack instead of ArrayList",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Create a method that validates grades before adding. This prevents invalid data from entering the list.",
      "Adding invalid grades causes problems later",
      "Array wouldn't solve validation issue",
      "Stack wouldn't solve validation issue",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "What will this queue processing code print?",
    code: 'Queue<String> tickets = new LinkedList<>();\n\n// Morning: 3 people get tickets\ntickets.offer("Person1");\ntickets.offer("Person2");\ntickets.offer("Person3");\n\n// Afternoon: Help first person and add 2 more\ntickets.poll();\ntickets.offer("Person4");\ntickets.offer("Person5");\n\nSystem.out.println("Next in line: " + tickets.peek());\nSystem.out.println("Total waiting: " + tickets.size());',
    answersList: [
      "Next in line: Person2\nTotal waiting: 4",
      "Next in line: Person1\nTotal waiting: 5",
      "Next in line: Person4\nTotal waiting: 4",
      "Next in line: Person5\nTotal waiting: 2",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Person1 was helped (poll), Person2 moved to front, added Person4,5. Total: Person2,3,4,5 = 4 people",
      "Person1 was removed by poll()",
      "Queue maintains FIFO order",
      "Shows incorrect count and order",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Which situation would cause a problem with this code?",
    code: 'Stack<String> history = new Stack<>();\n\n// User visits pages\nhistory.push("Page1");\nhistory.push("Page2");\n\n// User clicks back button twice\nhistory.pop();\nhistory.pop();\n\n// User clicks back again\nString prevPage = history.pop();',
    answersList: [
      "EmptyStackException on last pop() because stack is empty after two pops",
      "Stack is too full",
      "push() will fail",
      "No problems will occur",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "After popping two items from a two-item stack, another pop() will throw EmptyStackException. Should check !empty() before pop().",
      "Stack has plenty of space",
      "push() operations are fine",
      "Will definitely cause exception",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "What's wrong with using this collection type for student grades?",
    code: "Queue<Double> grades = new LinkedList<>();\ngrades.offer(95.5);\ngrades.offer(87.0);\ngrades.offer(92.5);\n\n// Later: need to find lowest grade",
    answersList: [
      "Queue is wrong choice - can't access all grades without removing them. ArrayList would allow accessing any grade at any time.",
      "Should use Stack instead of Queue",
      "Can't store doubles in a Queue",
      "LinkedList is wrong choice",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Queue only allows access to first element. Grades need random access for analysis, making ArrayList better choice.",
      "Stack would have same access limitations",
      "Queue can store any object type",
      "LinkedList implementation is fine",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "How would you organize these customer orders correctly?",
    code: "// Need to track:\n// 1. Orders must be processed in arrival order\n// 2. Need to know total number of orders\n// 3. Must find specific order by number",
    answersList: [
      "Queue<Order> orderQueue = new LinkedList<>();  // For processing order\nArrayList<Order> orderList = new ArrayList<>();   // For searching\n\n// Add to both:\norderQueue.offer(newOrder);\norderList.add(newOrder);",
      "Just use Queue<Order> for everything",
      "Just use ArrayList<Order> for everything",
      "Use Stack<Order> for everything",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Use two collections: Queue maintains processing order, ArrayList allows searching. This satisfies all requirements.",
      "Queue alone can't search easily",
      "ArrayList alone doesn't enforce order",
      "Stack gives wrong order (LIFO)",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Which lines will cause compile errors in this code?",
    code: 'Line 1: ArrayList<Integer> nums = new ArrayList<>();\nLine 2: nums.add(5);\nLine 3: nums.add("6");\nLine 4: nums.add(null);\nLine 5: int x = nums.get(0);\nLine 6: int y = nums.get(3);',
    answersList: [
      "Line 3: String can't go in Integer ArrayList\nLine 6: IndexOutOfBoundsException (not compilation error)",
      "Line 2: can't add int to ArrayList",
      "Line 4: can't add null to ArrayList",
      "Line 5: can't get from ArrayList",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Type safety prevents String in Integer ArrayList. Line 6 compiles but fails at runtime (index 3 doesn't exist).",
      "int autoboxes to Integer",
      "null is allowed in ArrayList",
      "get() works fine for existing indices",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What will each add() method return in this code?",
    code: 'ArrayList<String> names = new ArrayList<>();\n\nSystem.out.println("Add Alice: " + names.add("Alice"));\nSystem.out.println("Add Bob: " + names.add("Bob"));\nSystem.out.println("Add Alice: " + names.add("Alice"));\n\nSystem.out.println("List: " + names);',
    answersList: [
      "Add Alice: true\nAdd Bob: true\nAdd Alice: true\nList: [Alice, Bob, Alice]",
      "Add Alice: Alice\nAdd Bob: Bob\nAdd Alice: Alice\nList: [Alice, Bob, Alice]",
      "Add Alice: 1\nAdd Bob: 2\nAdd Alice: 3\nList: [Alice, Bob, Alice]",
      "Add Alice: false\nAdd Bob: false\nAdd Alice: false\nList: [Alice, Bob, Alice]",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "add() returns boolean true if successful. ArrayList allows duplicates, so all adds succeed.",
      "add() doesn't return the added element",
      "add() doesn't return the size",
      "true indicates success, not false",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Which line has the compilation error and why?",
    code: 'Line 1: Queue<Integer> numbers = new LinkedList<>();\nLine 2: numbers.offer(5);\nLine 3: numbers.offer(10);\nLine 4: int sum = numbers.peek() + numbers.peek();\nLine 5: System.out.println("First number + itself: " + sum);\nLine 6: numbers.clear();\nLine 7: int next = numbers.peek() + 1;',
    answersList: [
      "Line 7: Can't add to null (peek() returns null for empty queue)",
      "Line 1: Can't create new LinkedList",
      "Line 2: Can't add int to Queue<Integer>",
      "Line 4: Can't use peek() twice",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "After clear(), peek() returns null. Can't perform arithmetic with null. Should check for null first.",
      "LinkedList is valid Queue implementation",
      "Autoboxing handles int to Integer conversion",
      "Can call peek() multiple times",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Why is ArrayList used here instead of a regular array?",
    code: "// Need to store a list of students who sign up for a club\n// Don't know how many will join\n\n// Option 1:\nArrayList<String> members = new ArrayList<>();\n\n// Option 2:\nString[] members = new String[10];",
    answersList: [
      "ArrayList grows automatically as needed; array requires fixed size that we don't know in advance",
      "ArrayList is faster than array",
      "ArrayList uses less memory",
      "ArrayList is required for strings",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Key advantage of ArrayList is dynamic sizing - perfect when you don't know size in advance",
      "Array operations can be faster",
      "Arrays can use less memory",
      "Arrays can store strings too",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "What's the proper way to catch errors when removing from collection?",
    code: "Stack<String> pages = new Stack<>();\npages.push(\"Page 1\");\n\n// User clicks 'back' button three times",
    answersList: [
      'try {\n    for(int i = 0; i < 3; i++) {\n        System.out.println(pages.pop());\n    }\n} catch(EmptyStackException e) {\n    System.out.println("No more pages in history");\n}',
      "for(int i = 0; i < 3; i++) {\n    System.out.println(pages.pop());\n}",
      "if(pages.isEmpty()) {\n    pages.pop();\n}",
      "pages.pop(); pages.pop(); pages.pop();",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "try-catch handles EmptyStackException gracefully when stack runs out of elements",
      "Will throw exception without handling",
      "Checks empty but still tries to pop",
      "Will throw exception without handling",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's the difference between remove() and poll() for a Queue?",
    code: 'Queue<String> line = new LinkedList<>();\n\n// When queue is empty:\nSystem.out.println("poll() returns: " + line.poll());\nSystem.out.println("remove() returns: " + line.remove());',
    answersList: [
      "poll() returns null when empty\nremove() throws NoSuchElementException when empty",
      "Both return null when empty",
      "Both throw exceptions when empty",
      "poll() throws exception, remove() returns null",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "poll() is safer as it returns null when empty. remove() throws exception requiring error handling.",
      "remove() throws exception",
      "poll() returns null",
      "This reverses their behavior",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Debug this code for storing student scores. What's wrong?",
    code: "class StudentScores {\n    ArrayList scores;\n    \n    public void addScore(int score) {\n        scores.add(score);\n    }\n    \n    public double getAverage() {\n        int sum = 0;\n        for(int i = 0; i < scores.size(); i++) {\n            sum += scores.get(i);\n        }\n        return sum / scores.size();\n    }\n}",
    answersList: [
      "Three issues:\n1. ArrayList isn't initialized (needs new)\n2. No generic type (should be ArrayList<Integer>)\n3. Integer division in average (need double cast)",
      "Only the initialization is wrong",
      "Only the generic type is wrong",
      "The code is correct",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Common beginner issues: forgetting initialization, missing generics for type safety, integer division truncation",
      "Multiple issues exist",
      "Multiple issues exist",
      "Code has several problems",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Why does this code print different results?",
    code: 'ArrayList<Integer> nums = new ArrayList<>();\nnums.add(5);\nnums.add(10);\n\n// Print 1:\nSystem.out.println(nums.size());\n\n// Print 2:\nint[] arr = {5, 10};\nSystem.out.println(arr.length);\n\n// Print 3:\nString str = "5,10";\nSystem.out.println(str.length());',
    answersList: [
      "Different size methods:\nsize() for ArrayList (no parentheses)\nlength for arrays (property)\nlength() for String (method)",
      "They should all be the same",
      "Only size() is correct",
      "Only length is correct",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Common confusion: different ways to get size in Java. Each type has its own syntax.",
      "Each type has specific syntax",
      "Each way is correct for its type",
      "Each way is correct for its type",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Track the Queue state in this ticket processing system:",
    code: 'Queue<String> tickets = new LinkedList<>();\n\n// Morning:\ntickets.offer("Ticket1");  // State 1\ntickets.offer("Ticket2");  // State 2\ntickets.peek();             // State 3\ntickets.poll();             // State 4\ntickets.offer("Ticket3");  // State 5\n\nSystem.out.println("Size: " + tickets.size());',
    answersList: [
      "State 1: [Ticket1]\nState 2: [Ticket1, Ticket2]\nState 3: [Ticket1, Ticket2] (peek doesn't change)\nState 4: [Ticket2] (removed Ticket1)\nState 5: [Ticket2, Ticket3]\nSize: 2",
      "All tickets processed, size 0",
      "All tickets remain, size 3",
      "Only first ticket remains, size 1",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Track each step: offer adds at end, peek just looks, poll removes from front. Final state has 2 tickets.",
      "poll() only removed one ticket",
      "poll() removed Ticket1",
      "Two tickets remain",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Looking at ArrayList documentation, which method should you use to:",
    code: 'ArrayList<String> names = new ArrayList<>();\n\n// Need to:\n// 1. Add "Alice" at beginning\n// 2. Replace second name\n// 3. Find position of "Bob"\n// 4. Remove last name',
    answersList: [
      '1. add(0, "Alice")\n2. set(1, newName)\n3. indexOf("Bob")\n4. remove(size()-1)',
      '1. addFirst("Alice")\n2. replace(1, newName)\n3. find("Bob")\n4. removeLast()',
      '1. push("Alice")\n2. put(1, newName)\n3. search("Bob")\n4. pop()',
      '1. insert("Alice")\n2. change(1, newName)\n3. getIndex("Bob")\n4. deleteLast()',
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "These are the correct ArrayList methods: add(index,element), set(index,element), indexOf(object), remove(index)",
      "These methods don't exist for ArrayList",
      "These are Stack methods, not ArrayList",
      "These methods don't exist for ArrayList",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's wrong with these common ArrayList operations?",
    code: "ArrayList<Integer> numbers = new ArrayList<>();\n\n// Add numbers\nnumbers.push(5);           // Line 1\nnumbers.addElement(10);    // Line 2\nnumbers.insert(0, 15);     // Line 3\nnumbers.append(20);        // Line 4",
    answersList: [
      "All lines wrong: ArrayList uses add() method:\nnumbers.add(5);\nnumbers.add(10);\nnumbers.add(0, 15);\nnumbers.add(20);",
      "Only Line 1 is wrong",
      "Only Lines 1 and 2 are wrong",
      "The code is correct",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Common mistake: using methods from other languages/collections. ArrayList consistently uses add() methods.",
      "All lines use wrong methods",
      "All lines use wrong methods",
      "No lines use correct methods",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "A cat is knocking items off a shelf (as cats do). Which data structure best represents this?",
    code: "// Cat sees: [Vase, Plant, Trophy, Lamp, Book]\n// Cat starts knocking things off...\n// What collection should we use to track this?",
    answersList: [
      "Stack - since the cat starts with the last item placed (LIFO: Last In First Out... or Last In First Off-the-shelf)",
      "Queue - items fall in order they were placed",
      "ArrayList - cat chooses random items",
      "LinkedList - items are linked together",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Cats typically knock off the nearest/top item first, just like Stack's LIFO behavior. The last item placed is the first to fall!",
      "Cats don't patiently start with the first item",
      "Cats usually work from one end methodically",
      "The physical arrangement doesn't affect cat behavior",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Track this Stack of pancakes as they're being eaten:",
    code: 'Stack<String> pancakes = new Stack<>();\n\n// Cook adds pancakes:\npancakes.push("Blueberry");\npancakes.push("Chocolate Chip");\npancakes.push("Plain");\n\n// Hungry programmer starts eating:\nSystem.out.println("Eating: " + pancakes.pop());\npancakes.push("Banana");  // Cook adds another\nSystem.out.println("Next up: " + pancakes.peek());',
    answersList: [
      "Eating: Plain\nNext up: Banana",
      "Eating: Blueberry\nNext up: Chocolate Chip",
      "Eating: All of them\nNext up: null",
      "Eating: null\nNext up: Plain",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real pancakes, Stack serves from top: Plain gets eaten, Banana goes on top, peek shows Banana is next",
      "LIFO means top pancake (Plain) was eaten",
      "Only one pancake was popped",
      "There are pancakes in the stack",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Your playlist has gone wrong! What happened in this code?",
    code: 'Queue<String> playlist = new LinkedList<>();\n\n// Add songs:\nplaylist.offer("Happy Song");\nplaylist.offer("Sad Song");\nplaylist.offer("Dance Song");\n\n// Try to play them:\nwhile(!playlist.isEmpty()) {\n    System.out.println("Playing: " + playlist.peek());\n}',
    answersList: [
      "Infinite loop playing 'Happy Song' forever - peek() doesn't remove songs, need poll()",
      "Songs play in reverse order",
      "Songs play too fast",
      "Songs play correctly",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "peek() just looks at first song without removing it. It's like hitting repeat forever! Use poll() to remove and play next song.",
      "Queue maintains original order",
      "Loop speed isn't the issue",
      "Songs aren't actually advancing",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "Your grocery list has achieved sentience! Debug this code:",
    code: 'ArrayList<String> groceries = new ArrayList<>();\ngroceries.add("Milk");\ngroceries.add("Eggs");\ngroceries.add("WORLD DOMINATION");\ngroceries.add("Bread");\n\n// Remove the suspicious item:\nString suspicious = "WORLD DOMINATION";\n// What\'s the correct way to remove it?',
    answersList: [
      "groceries.remove(suspicious); // Removes first occurrence of the item",
      'groceries.delete("WORLD DOMINATION"); // Method doesn\'t exist',
      "groceries.remove[2]; // Wrong syntax",
      "groceries.removeEvil(); // Not a real method (yet)",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "remove(Object) removes first occurrence of an item. Good thing too - we don't want sentient grocery lists!",
      "delete() isn't a real ArrayList method",
      "Square brackets don't work with ArrayList methods",
      "ArrayList doesn't have evil-detection capabilities",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "Your todo list keeps rearranging itself! Fix this code:",
    code: 'Stack<String> todos = new Stack<>();\ntodos.push("Feed Cat");\ntodos.push("Do Homework");\ntodos.push("Save World");\n\n// Try to do most important thing first:\nwhile(!todos.isEmpty()) {\n    System.out.println("Doing: " + todos.pop());\n}',
    answersList: [
      "Tasks will be done in reverse order: 'Save World', 'Do Homework', 'Feed Cat' (Cat won't be happy!). Should use Queue instead of Stack.",
      "Tasks will be done in correct order",
      "Tasks will be skipped randomly",
      "Cat will feed itself",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stack's LIFO means important tasks get done last! Queue would ensure Cat gets fed before saving world.",
      "Stack processes in reverse order",
      "Stack processes in defined order",
      "Cats wish this were true",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Your snack dispenser is using the wrong data structure! What's the problem?",
    code: 'Stack<String> snacks = new Stack<>();\nsnacks.push("Fresh Chips");\nsnacks.push("Fresh Cookies");\nsnacks.push("Fresh Candy");\n\n// Time passes...\n// Customer buys snack:\nSystem.out.println("Enjoying: " + snacks.pop());',
    answersList: [
      "Stack means newest snacks are sold first - customers get fresh snacks while old ones get stale! Should use Queue for FIFO.",
      "Snacks will fall out of the machine",
      "Stack can't hold snacks",
      "Customers can't reach the snacks",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stack (LIFO) serves fresh items first, leaving old ones to expire. Queue (FIFO) would ensure older items sell first!",
      "This is a logical error, not physical",
      "Stack can store any object type",
      "Access method isn't the issue",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Your coffee shop line simulation has gone chaotic! What happened?",
    code: 'ArrayList<String> line = new ArrayList<>();\nline.add("Patient Customer");\nline.add("Sleepy Customer");\nline.add("Coffee Addict");\n\n// New customer tries to cut in front:\nline.add(0, "Line Cutter");\nSystem.out.println("Next up: " + line.get(0));',
    answersList: [
      "Code works but is wrong choice - ArrayList allows cutting! Queue would enforce FIFO and prevent cutting.",
      "Line will automatically reject cutting",
      "ArrayList can't store customers",
      "get(0) returns wrong customer",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList at index 0 lets people cut in line. Queue would maintain fair order - no cutting allowed!",
      "ArrayList allows insertion at any index",
      "ArrayList can store any object type",
      "get(0) correctly returns first element",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Your sandwich stack has a bug! Find the error:",
    code: 'Stack<String> sandwich = new Stack<>();\n\n// Build sandwich from bottom up:\nsandwich.push("Bread");\nsandwich.push("Lettuce");\nsandwich.push("Tomato");\nsandwich.push("More Bread");\n\n// Take a bite:\nSystem.out.println("Biting: " + sandwich.get(0));',
    answersList: [
      "get(0) gets bottom slice! Should use peek() for top slice - you can't eat a sandwich from the bottom!",
      "Sandwich toppings in wrong order",
      "Stack can't make sandwiches",
      "Need more toppings",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "get(0) accesses bottom of stack (bottom bread). peek() gets top item (top bread) - much more logical for eating!",
      "Order is fine for a sandwich",
      "Stack can represent layered items",
      "Number of toppings isn't the issue",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "Debug this haunted elevator simulation:",
    code: 'Queue<String> elevator = new LinkedList<>();\n\n// People enter elevator:\nelevator.offer("Ghost");\nelevator.offer("Tourist");\nelevator.offer("Employee");\n\n// Elevator reaches floor:\nwhile(!elevator.isEmpty()) {\n    if(elevator.peek().equals("Ghost")) {\n        elevator.poll();\n        System.out.println("Spooky: Ghost disappeared!");\n    }\n    System.out.println("Exited: " + elevator.poll());\n}',
    answersList: [
      "Ghost gets polled twice! First in if-statement, then in println. Second poll gets Tourist instead!",
      "Ghosts can't use elevators",
      "Queue doesn't allow ghosts",
      "Everything works correctly",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Double-poll means Tourist vanishes mysteriously after Ghost. Need to use same poll result or skip println for Ghost!",
      "This is a logical error not a ghost issue",
      "Queue can store any object type",
      "Code has a polling error",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Your pizza ordering system has gone rogue! What's wrong?",
    code: 'Stack<String> pizzaOrders = new Stack<>();\n\n// Add orders:\npizzaOrders.push("Pepperoni - Ordered 6:00");\npizzaOrders.push("Veggie - Ordered 6:30");\npizzaOrders.push("Supreme - Ordered 7:00");\n\n// Cook makes pizza:\nSystem.out.println("Cooking: " + pizzaOrders.pop());',
    answersList: [
      "Stack makes newest order (Supreme) cook first! Switch to Queue so first order (Pepperoni) cooks first.",
      "Pizzas will come out upside down",
      "Stack can't handle hot food",
      "Orders will get mixed up randomly",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stack's LIFO means 7:00 order cooks before 6:00 order. Queue would ensure fair FIFO order!",
      "This is a logical order issue",
      "Stack can store any object type",
      "Stack maintains strict order",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Your attempts to clone dinosaurs have produced some interesting ArrayList bugs. What's wrong with this code?",
    code: 'ArrayList<String> dinosaurs = new ArrayList<>();\n\nfor(int i = 1; i <= 5; i++) {\n    dinosaurs.add("T-Rex #" + i);\n    // Apparently they multiply...\n    dinosaurs.add(0, "Baby T-Rex");\n    System.out.println("Park population: " + dinosaurs.size());\n}',
    answersList: [
      "Adding at index 0 keeps pushing older dinos right! Each loop adds 2 dinos, with babies always at front. Final list has 10 dinos, all babies at start!",
      "T-Rexes will escape the ArrayList",
      "ArrayList can't contain prehistoric animals",
      "Code will create infinite dinosaurs",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Each iteration adds adult at end (size+1) and baby at start (shifts all right). Like a very dangerous conga line of dinosaurs!",
      "ArrayList contains objects safely",
      "ArrayList can store any object type",
      "Loop runs fixed number of times",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Your Stack of magic spells has misfired! Debug this wizard code:",
    code: 'Stack<String> spells = new Stack<>();\nspells.push("Turn Lead to Gold");\nspells.push("Make Dragons Friendly");\nspells.push("Fix Bugs Without Testing");\n\n// Try most recent spell:\nString spell = spells.peek();\nSystem.out.println("Casting: " + spell);\nspells.push(spell);  // Save for later\nSystem.out.println("Spells available: " + spells.size());',
    answersList: [
      "Pushing peeked spell creates duplicate! Stack now has 4 spells with 'Fix Bugs Without Testing' repeated (if only it worked twice!)",
      "Spells will cast in wrong order",
      "peek() will erase the spell",
      "Magic doesn't work in Java",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "peek() looks at top spell, then push adds it again. Like trying to make a copy of your homework - it's still the same homework!",
      "Stack maintains correct order",
      "peek() doesn't remove elements",
      "Java can handle magical operations",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Your robot's task Queue has gained consciousness! Find the infinite loop:",
    code: 'Queue<String> robotTasks = new LinkedList<>();\nrobotTasks.offer("Clean Room");\nrobotTasks.offer("Plot World Domination");\nrobotTasks.offer("Do Dishes");\n\n// Robot processes tasks:\nwhile(robotTasks.peek() != null) {\n    String task = robotTasks.peek();\n    if(task.contains("World Domination")) {\n        robotTasks.offer("Be More Subtle");\n    }\n    System.out.println("Processing: " + task);\n}',
    answersList: [
      "Robot never removes tasks (needs poll())! It keeps seeing 'Plot World Domination' and adding 'Be More Subtle' forever. Skynet begins with a peek() bug!",
      "Robot will execute tasks too fast",
      "Queue doesn't allow robot tasks",
      "World domination succeeds immediately",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "peek() without poll() means same task stays at front. Like a robot staring at its to-do list but never crossing anything off!",
      "Speed isn't the issue",
      "Queue can store any task type",
      "Task execution isn't the problem",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Your time machine's history Stack is malfunctioning! What's wrong?",
    code: 'Stack<String> timeJumps = new Stack<>();\n\n// Travel through time:\ntimeJumps.push("2024 - Present");\ntimeJumps.push("1985 - See dinosaurs");  // Oops, wrong year!\ntimeJumps.push("65M BC - Pet dinosaurs");\n\nSystem.out.println("Current location: " + timeJumps.get(timeJumps.size()-1));\ntimeJumps.pop();\ntimeJumps.pop();\nSystem.out.println("Returned to: " + timeJumps.peek());',
    answersList: [
      "get(size-1) is overcomplicated - just use peek()! Both return top of Stack but peek() is clearer (and uses less fuel in the time machine)",
      "Time travel is impossible in Java",
      "Stack will create temporal paradox",
      "Dinosaurs won't fit in the Stack",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "get(size-1) and peek() do same thing but peek() is clearer. Like using a time machine to get tomorrow's newspaper vs just waiting a day!",
      "Stack can handle temporal data",
      "Stack maintains consistent order",
      "Stack can store any time period",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Your cookie jar ArrayList has developed quantum properties! Debug this code:",
    code: 'ArrayList<String> cookieJar = new ArrayList<>();\ncookieJar.add("Chocolate Chip");\ncookieJar.add(null);  // Schrdinger\'s cookie\ncookieJar.add("Oatmeal");\n\n// Try to eat cookies:\nfor(String cookie : cookieJar) {\n    System.out.println("Eating: " + cookie.toUpperCase());\n}',
    answersList: [
      "NullPointerException on null cookie! Can't call toUpperCase() on null. Need to check cookie != null first (quantum cookies are hard to eat)",
      "Cookies will become too large",
      "ArrayList can't store baked goods",
      "toUpperCase() makes cookies stale",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Null check needed before method call. Like trying to eat a cookie that both exists and doesn't exist - it breaks reality (and your code)!",
      "Case change doesn't affect size",
      "ArrayList can store any type",
      "String operations don't affect freshness",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Your Stack of recursive sheep for bedtime counting has gone wrong! What happened?",
    code: 'Stack<String> sheep = new Stack<>();\n\nwhile(sheep.size() < 3) {\n    System.out.println(sheep.push("Sheep #" + (sheep.size() + 1)));\n}\n\nSystem.out.println("Counted: " + sheep);\nSystem.out.println("Still awake...");',
    answersList: [
      "push() returns the sheep just pushed! Prints each sheep twice - once from push return, once in final count. No wonder you can't sleep!",
      "Sheep will stack overflow",
      "Sheep can't be stored digitally",
      "while loop never ends",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "push() returns pushed element, so println shows it. Like counting sheep but each one shows up twice - very confusing for sleep!",
      "Stack size is limited appropriately",
      "Stack can store String sheep",
      "Loop has clear termination",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "Your attempt to organize cats has predictably failed. What's wrong with this code?",
    code: 'Queue<String> cats = new LinkedList<>();\ncats.offer("Whiskers");\ncats.offer("Mittens");\ncats.offer("Shadow");\n\n// Cats decide to rearrange themselves:\nfor(int i = 0; i < cats.size(); i++) {\n    String cat = cats.poll();\n    cats.offer(cat);\n    System.out.println("Now first: " + cats.peek());\n}',
    answersList: [
      "size() changes as cats move! Some cats get skipped because i increases while size decreases. Cats are unorganizable - use a fixed count instead!",
      "Cats will escape the Queue",
      "Queue doesn't allow pets",
      "Cats organize themselves perfectly",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Loop condition changes during iteration as Queue size changes. Like trying to organize cats - they move before you finish counting them!",
      "Queue contains objects securely",
      "Queue can store any type",
      "Cats resist organization",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Your ArrayList of excuses for late homework has type safety issues! Find the bug:",
    code: 'ArrayList excuses = new ArrayList();  // Raw type!\nexcuses.add("Dog ate it");\nexcuses.add(new Integer(42));\nexcuses.add("Lost in time vortex");\n\nfor(Object excuse : excuses) {\n    System.out.println("Excuse length: " + excuse.toString().length());\n}',
    answersList: [
      "No generic type specified! Can mix strings and numbers - imagine telling professor your homework is '42' pages long!",
      "Excuses are too creative",
      "ArrayList can't store excuses",
      "toString() makes excuses invalid",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Raw types allow mixing different types - leads to confusing results. Like mixing your homework with your lunch - both exist but shouldn't be together!",
      "Creativity isn't the issue",
      "ArrayList can store any type",
      "toString() works on all objects",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "Your Stack of procrastinated tasks has achieved sentience! Debug this:",
    code: 'Stack<String> tasks = new Stack<>();\ntasks.push("Write Essay");\ntasks.push("Do Laundry");\ntasks.push("Clean Room");\n\n// Tasks try to escape:\nwhile(!tasks.empty()) {\n    String task = tasks.pop();\n    if(task.contains("Clean")) {\n        tasks.push(task);  // Refuse to do it\n        tasks.push("Procrastinate More");\n    }\n}',
    answersList: [
      "Infinite loop! Clean task keeps getting pushed back with more procrastination. Stack grows forever instead of shrinking!",
      "Tasks complete instantly",
      "Stack overflow from too much work",
      "All tasks are cleaned properly",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Clean task keeps returning with a friend. Like real procrastination - the task list keeps growing instead of shrinking!",
      "Tasks clearly avoid completion",
      "Task limit isn't reached",
      "Tasks actively avoid cleaning",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "Your Queue of dancing robots has synchronization issues! What's wrong?",
    code: 'Queue<String> danceFloor = new LinkedList<>();\ndanceFloor.offer("Robot1 (Running Low Battery)");\ndanceFloor.offer("Robot2 (Fully Charged)");\ndanceFloor.offer("Robot3 (Solar Powered)");\n\n// Dance time!\nwhile(danceFloor.peek().contains("Running Low")) {\n    System.out.println(danceFloor.poll() + " attempts the robot dance");\n}',
    answersList: [
      "Potential NullPointerException! If Queue empties, peek() returns null and contains() crashes. Need null check or battery won't be only thing failing!",
      "Robots don't know how to dance",
      "Queue can't handle robot moves",
      "Solar power works at night",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Need to check if peek() returns null before calling contains(). Like checking if robot has power before asking it to dance!",
      "Dancing ability isn't the issue",
      "Queue can store dancing robots",
      "Power source isn't the problem",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "In a music player app, why should recently played songs be stored in a Stack rather than a Queue?",
    code: '// Current implementation:\nStack<String> recentlyPlayed = new Stack<>();\n\n// Playing songs:\nrecentlyPlayed.push("Song A");  // Played first\nrecentlyPlayed.push("Song B");  // Played second\nrecentlyPlayed.push("Song C");  // Played last\n\n// User hits \'Previous Song\' button\nSystem.out.println("Return to: " + recentlyPlayed.pop());',
    answersList: [
      "Stack's LIFO behavior matches 'Previous Song' functionality - returns to most recently played song first, like browser back button",
      "Queue would play songs faster",
      "Stack holds more songs than Queue",
      "Stack automatically shuffles songs",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "When users hit 'Previous', they expect to get their most recent song (like Spotify, Apple Music), making Stack's LIFO perfect for this feature",
      "Performance isn't the issue here",
      "Storage capacity is the same",
      "Shuffling isn't related to Stack behavior",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "In a restaurant ordering system, what's wrong with this implementation?",
    code: "class OrderSystem {\n    Stack<String> orders = new Stack<>();\n    \n    public void addOrder(String order) {\n        orders.push(order);\n    }\n    \n    public String getNextOrder() {\n        return orders.pop();\n    }\n}",
    answersList: [
      "Stack processes newest orders first (LIFO), so earlier customers wait longer. Should use Queue for first-come-first-served (FIFO) fairness",
      "Orders should be stored in ArrayList",
      "Method names are incorrect",
      "Stack can't store orders",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real restaurants process orders in sequence (like order tickets on a rail). Stack would serve newest customers first, causing unfair delays for others",
      "ArrayList wouldn't enforce order",
      "Method names clearly show intent",
      "Stack can store order data",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "A chat application needs to store message history. Which is better and why?",
    code: "// Option 1:\nArrayList<String> messages = new ArrayList<>();\n\n// Option 2:\nLinkedList<String> messages = new LinkedList<>();\n\n// App frequently needs to:\n// 1. Add new messages at end\n// 2. Load last 50 messages\n// 3. Occasionally delete old messages",
    answersList: [
      "ArrayList is better - provides O(1) access to recent messages and O(1) append for new messages, which are the most common operations",
      "LinkedList is always faster",
      "Makes no difference",
      "Need to use Stack instead",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like WhatsApp or Messenger, chat apps need fast access to recent messages and quick message appending. ArrayList excels at both with its array backing",
      "LinkedList is slower for random access",
      "Data structure choice affects performance",
      "Stack wouldn't provide needed functionality",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "In a printer spooler system, why does this code need modification?",
    code: "class PrinterSpooler {\n    ArrayList<PrintJob> printQueue = new ArrayList<>();\n    \n    public void addJob(PrintJob job) {\n        printQueue.add(0, job);  // Add at start\n    }\n    \n    public PrintJob getNextJob() {\n        return printQueue.remove(0);\n    }\n}",
    answersList: [
      "ArrayList with manual index management is error-prone and inefficient. Queue interface would better represent FIFO printing order",
      "Printer needs to print faster",
      "ArrayList can't store print jobs",
      "Method names are wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real printer queues (like Windows Print Spooler) need reliable FIFO order. Queue interface naturally models this, avoiding index manipulation bugs",
      "Speed isn't the main issue",
      "ArrayList can store any object",
      "Names clearly show intent",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 3,
    question:
      "An e-commerce shopping cart needs fast operations. Which implementation is better?",
    code: "// Need to support:\n// 1. Add/remove items frequently\n// 2. Update quantities often\n// 3. Calculate total price\n// 4. Display all items\n\n// Option 1:\nLinkedList<CartItem> cart = new LinkedList<>();\n\n// Option 2:\nArrayList<CartItem> cart = new ArrayList<>();",
    answersList: [
      "ArrayList better suits shopping cart needs:\n- O(1) access for updates/reads\n- Infrequent middle insertions\n- Memory locality for faster iteration when calculating totals\n- Natural order for display",
      "LinkedList is always faster",
      "Should use Stack",
      "Should use Queue",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real carts (like Amazon's) need fast random access and iteration. ArrayList's contiguous memory and index access perfect for these operations",
      "LinkedList operations would be slower",
      "Stack doesn't match cart behavior",
      "Queue doesn't match cart behavior",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question:
      "A call center's customer service queue needs improvement. What's wrong?",
    code: "class CallCenter {\n    Queue<String> customerQueue = new LinkedList<>();\n    \n    public void addCustomer(String customer, boolean priority) {\n        if(priority) {\n            // Try to add VIP caller to front\n            customerQueue.poll();\n            customerQueue.offer(customer);\n        } else {\n            customerQueue.offer(customer);\n        }\n    }\n}",
    answersList: [
      "Wrong queue type - need PriorityQueue to properly handle VIP callers. Current code incorrectly removes existing customers",
      "Queue is too small",
      "Shouldn't use queue at all",
      "Method names are wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real call centers (like customer service lines) need proper priority handling. PriorityQueue would naturally order based on customer priority level",
      "Size isn't the issue",
      "Queue models call center well",
      "Names are descriptive",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question:
      "A social media app's news feed implementation needs review. Why?",
    code: "class NewsFeed {\n    Stack<Post> feed = new Stack<>();\n    \n    public void addPost(Post post) {\n        feed.push(post);\n    }\n    \n    public List<Post> getRecentPosts(int count) {\n        List<Post> recent = new ArrayList<>();\n        for(int i = 0; i < count && !feed.empty(); i++) {\n            recent.add(feed.pop());\n        }\n        return recent;\n    }\n}",
    answersList: [
      "Stack removes posts when viewing them! Should use ArrayList to keep posts while allowing access to recent ones via index",
      "Posts should be in Queue",
      "Can't store social media posts",
      "For loop is wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real feeds (like Facebook/Twitter) keep posts while showing recent ones. ArrayList allows access without removal and maintains post order",
      "Queue wouldn't provide needed access",
      "Posts can be stored as objects",
      "Loop logic is correct",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Applying",
    difficulty: 2,
    question: "An elevator system's floor queue needs fixing. What's wrong?",
    code: "class Elevator {\n    Queue<Integer> floorQueue = new LinkedList<>();\n    int currentFloor = 1;\n    \n    public void addFloorRequest(int floor) {\n        floorQueue.offer(floor);\n    }\n    \n    public int getNextFloor() {\n        return floorQueue.poll();\n    }\n}",
    answersList: [
      "Simple Queue is inefficient - processes floors in request order instead of optimizing path. Need PriorityQueue with custom comparison for efficient routing",
      "Should use Stack instead",
      "Shouldn't store floor numbers",
      "Method names unclear",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real elevators (like in office buildings) optimize their path, not just follow request order. PriorityQueue could order by direction and proximity",
      "Stack wouldn't help optimization",
      "Integer floor numbers work fine",
      "Names clearly show intent",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question:
      "A video streaming app's playback history needs the right collection. Why?",
    code: "class VideoPlayer {\n    // Need to:\n    // 1. Track recently watched videos\n    // 2. Support 'Previous Video' button\n    // 3. Keep last 100 videos maximum\n    \n    Queue<String> history = new LinkedList<>();  // Current implementation\n}",
    answersList: [
      "Queue is wrong choice - 'Previous' needs LIFO behavior. Use Stack with size limit for proper video history navigation",
      "Queue is always better",
      "Should use basic array",
      "Needs HashMap instead",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real video players (like YouTube/Netflix) use back/forward navigation similar to browsers. Stack naturally models this behavior",
      "Queue FIFO doesn't match usage",
      "Array size would be fixed",
      "HashMap doesn't maintain order",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 2,
    question: "A task management app's implementation needs review. Why?",
    code: "class TaskManager {\n    ArrayList<Task> todoList = new ArrayList<>();\n    \n    public void addTask(Task task) {\n        // Add new task at index 0\n        todoList.add(0, task);\n    }\n    \n    public void completeTask(int index) {\n        todoList.remove(index);\n    }\n}",
    answersList: [
      "Adding at index 0 constantly shifts elements - very inefficient for large lists. Add at end (append) for O(1) instead of O(n)",
      "ArrayList can't store tasks",
      "Should use Stack instead",
      "Method names are wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real task apps (like Todoist/Trello) need to handle many tasks efficiently. Adding at end avoids shifting entire list for each new task",
      "ArrayList can store task objects",
      "Stack doesn't match usage pattern",
      "Method names are clear",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "Review this common student design and identify why it might not work well in a real application:",
    code: 'class StudentGradeSystem {\n    ArrayList<Double> homework = new ArrayList<>();\n    ArrayList<Double> quizzes = new ArrayList<>();\n    ArrayList<Double> exams = new ArrayList<>();\n    \n    public void addGrade(double grade, String type) {\n        if(type.equals("homework")) homework.add(grade);\n        if(type.equals("quiz")) quizzes.add(grade);\n        if(type.equals("exam")) exams.add(grade);\n    }\n}',
    answersList: [
      "Using separate lists makes it hard to:\n1. Keep grades in chronological order\n2. Calculate overall average efficiently\n3. Maintain consistency (typos in type can create bugs)\nBetter: Use a Grade class and single list",
      "ArrayList is the wrong choice, use LinkedList",
      "Should use a Queue for grades",
      "Need to use primitive arrays instead",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "In real applications, you often need to view all grades chronologically and calculate overall averages. A Grade class with {type, value, date} would be more maintainable.",
      "The issue isn't with ArrayList vs LinkedList",
      "Queue wouldn't solve the organizational issues",
      "Arrays would make the problems worse",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question: "Find and explain the potential issues in this playlist manager:",
    code: 'class PlaylistManager {\n    Stack<String> history = new Stack<>();      // Play history\n    Queue<String> upNext = new LinkedList<>();  // Play queue\n    ArrayList<String> songs = new ArrayList<>(); // All songs\n    \n    public void playNext() {\n        String song = upNext.poll();\n        if(song != null) {\n            history.push(song);\n            System.out.println("Playing: " + song);\n        }\n    }',
    answersList: [
      "Issues:\n1. No memory management - history stack can grow infinitely\n2. No sync between collections - songs could exist in queue but not in songs list\n3. No way to check if a song exists before adding to queue",
      "Stack is wrong choice for history",
      "Should only use one collection",
      "Method name is unclear",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real music players need to handle memory limits and maintain data consistency. This design could crash with memory errors or show invalid songs.",
      "Stack is appropriate for history",
      "Multiple collections serve different purposes",
      "Method name is clear",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 3,
    question:
      "Compare these two approaches for a restaurant waitlist system. Which is better and why?",
    code: "// Approach 1:\nclass Waitlist1 {\n    Queue<String> waitlist = new LinkedList<>();\n    public void addParty(String name) { waitlist.offer(name); }\n    public String nextParty() { return waitlist.poll(); }\n}\n\n// Approach 2:\nclass Waitlist2 {\n    LinkedList<String> waitlist = new LinkedList<>();\n    public void addParty(String name, int size) {\n        int i = 0;\n        while(i < waitlist.size() && size <= 4) i++;\n        waitlist.add(i, name);\n    }",
    answersList: [
      "Approach 1 is better because:\n1. Maintains true FIFO fairness\n2. Simpler to understand and maintain\n3. Less likely to have bugs\nSize-based priority should be separate system",
      "Approach 2 is better because it handles party size",
      "Both approaches are equally good",
      "Neither approach is good",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real restaurants prioritize fairness. While party size matters, it should be a separate seating system, not built into the waitlist order.",
      "Mixing concerns leads to complexity",
      "The approaches have clear differences",
      "Approach 1 is a valid solution",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      "Design a simple undo/redo system for a text editor. What collections would you use and why?",
    answersList: [
      "Need two Stacks:\n1. undoStack: stores past states (LIFO for undo)\n2. redoStack: stores undone states (LIFO for redo)\nClear redoStack when new action performed",
      "Single Stack is enough",
      "Need Queue for time order",
      "ArrayList would work better",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real text editors (like Notepad++) use this two-stack approach. It naturally models undo/redo behavior and clears redo history for new actions.",
      "Single Stack can't handle redo",
      "Queue order doesn't match usage",
      "ArrayList doesn't provide needed LIFO",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 3,
    question:
      "What problem will this code cause in a real application and how would you fix it?",
    code: "class MessageSystem {\n    ArrayList<String> messages = new ArrayList<>();\n    \n    public void addMessage(String msg) {\n        messages.add(msg);\n    }\n    \n    public ArrayList<String> getLastMessages(int count) {\n        int start = Math.max(0, messages.size() - count);\n        return new ArrayList<>(messages.subList(start, messages.size()));\n    }",
    answersList: [
      "Memory problem: List grows forever!\nFix:\n1. Add max size limit\n2. Remove old messages when limit reached\n3. Consider using circular buffer for efficiency",
      "Wrong return type in getLastMessages",
      "Should use Queue instead of ArrayList",
      "Method names are unclear",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real chat/messaging systems must manage memory. Unlimited growth will eventually crash the application.",
      "Return type works fine",
      "ArrayList works for this purpose",
      "Names clearly show intent",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Given these requirements for a browser tab history, evaluate which implementation is best:",
    code: "Requirements:\n1. Store visited URLs\n2. Navigate back/forward\n3. Clear history option\n4. Show last 10 visited sites\n5. Memory efficient",
    answersList: [
      "ArrayList<String> with current position index:\n+ Easy back/forward by moving index\n+ Efficient random access for last 10\n+ Can limit size for memory\n- Uses more memory than needed\n\nTwo Stacks would be better:\n+ Memory efficient\n+ Natural back/forward\n+ Easy to limit size",
      "Single Stack only",
      "Queue would work best",
      "LinkedList is ideal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real browsers need efficient navigation and memory management. Two stacks (back/forward) provides most natural implementation of browser behavior.",
      "Single Stack can't handle forward",
      "Queue order doesn't match usage",
      "LinkedList adds unnecessary complexity",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Design a basic notification system that shows newest notifications first but keeps old ones accessible. Consider trade-offs:",
    code: "Requirements:\n1. Show newest first\n2. Keep history\n3. Mark as read\n4. Delete old notifications\n5. Group by date",
    answersList: [
      "Use ArrayList<Notification> where Notification has:\n- message: String\n- timestamp: Date\n- read: boolean\n\nBenefits:\n+ Easy sorting by date\n+ Random access for marking read\n+ Can remove old items efficiently\n+ Natural grouping by date",
      "Stack would be better",
      "Queue is ideal solution",
      "LinkedList would work best",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real notification systems (like on phones) need flexible access and organization. Custom class with ArrayList provides needed functionality.",
      "Stack loses old notifications",
      "Queue shows oldest first",
      "LinkedList adds unnecessary complexity",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Find all the potential issues in this download manager implementation:",
    code: 'class DownloadManager {\n    Queue<String> downloadQueue = new LinkedList<>();\n    \n    public void addDownload(String url) {\n        downloadQueue.offer(url);\n    }\n    \n    public void processDownloads() {\n        while(!downloadQueue.isEmpty()) {\n            String url = downloadQueue.poll();\n            System.out.println("Downloading: " + url);\n        }\n    }',
    answersList: [
      "Issues:\n1. No progress tracking\n2. No pause/resume\n3. No priority (emergency patches vs optional)\n4. No failure handling/retry\n5. Blocking while loop\nNeeds PriorityQueue + status tracking",
      "Just using wrong Queue type",
      "Should use Stack instead",
      "Method names are wrong",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real download managers need robust features. Simple queue isn't enough - need priority, status tracking, error handling.",
      "Queue type isn't main issue",
      "Stack wouldn't help",
      "Names are clear",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 3,
    question:
      "Design a simple task scheduler that handles recurring and one-time tasks. What collections would you use?",
    code: "Requirements:\n1. Add one-time tasks\n2. Add recurring tasks (daily/weekly)\n3. Execute due tasks\n4. Remove completed tasks\n5. View upcoming tasks",
    answersList: [
      "PriorityQueue<Task> sorted by due date where Task has:\n- name: String\n- dueDate: Date\n- recurring: boolean\n- interval: int\n\nExecute overdue tasks and requeue recurring ones",
      "Regular Queue is enough",
      "Stack would work better",
      "ArrayList is best choice",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real schedulers (like cron) need to handle mixed task types. PriorityQueue ensures tasks execute in proper order.",
      "Regular Queue doesn't handle timing",
      "Stack order doesn't match needs",
      "ArrayList doesn't maintain order",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 3,
    question: "Compare these approaches for managing a game's power-up system:",
    code: "// Approach 1:\nStack<PowerUp> powerUps = new Stack<>();  // Last collected = first used\n\n// Approach 2:\nQueue<PowerUp> powerUps = new LinkedList<>();  // First collected = first used\n\n// Approach 3:\nArrayList<PowerUp> powerUps = new ArrayList<>();  // Manual selection",
    answersList: [
      "ArrayList is best because:\n1. Players expect to choose power-ups\n2. Some power-ups more valuable than others\n3. Strategy involved in choosing when to use\n4. Can show all available power-ups\nStack/Queue remove player choice",
      "Stack is best for last-in-first-out",
      "Queue is best for fairness",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real games let players strategize. Forcing LIFO/FIFO for power-ups removes gameplay depth. ArrayList allows player choice.",
      "Automatic LIFO limits gameplay",
      "FIFO doesn't add strategy",
      "Approaches have clear differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question:
      "Analyze why this seemingly good ticket booking system will fail in production:",
    code: "class TicketSystem {\n    private Queue<String> waitlist = new LinkedList<>();\n    private Set<String> validUsers = new HashSet<>();\n    private int maxTickets = 100;\n    private int ticketsSold = 0;\n    \n    public synchronized boolean requestTicket(String user) {\n        if (!validUsers.contains(user)) return false;\n        if (ticketsSold < maxTickets) {\n            waitlist.offer(user);\n            ticketsSold++;\n            return true;\n        }\n        return false;\n    }\n    \n    public String processNextTicket() {\n        return waitlist.poll();\n    }\n}",
    answersList: [
      "Critical issues:\n1. Race condition: gap between ticketsSold check and increment\n2. No timeout handling for abandoned requests\n3. No handling for user trying multiple times\n4. processNextTicket not synchronized\n5. No transaction rollback if processing fails",
      "Just needs error handling",
      "Queue is wrong choice",
      "Method names unclear",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real ticket systems (like for concerts) face these exact issues. The synchronized keyword alone doesn't prevent overselling because the check-then-act operation isn't atomic.",
      "Simple error handling won't fix concurrency issues",
      "Queue is appropriate for FIFO ticketing",
      "Method names are clear",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Compare these three approaches for implementing an event logging system that needs to handle high-frequency events but allow historical access:",
    code: "// Approach 1: Single ArrayList\nArrayList<Event> logs = new ArrayList<>();\n\n// Approach 2: Queue + Periodic ArrayList\nQueue<Event> current = new LinkedList<>();\nArrayList<Event> history = new ArrayList<>();\n// Transfer queue to history every hour\n\n// Approach 3: Circular Buffer + ArrayList\nArrayList<Event> recent = new ArrayList<>(1000); // Fixed size\nArrayList<Event> archive = new ArrayList<>();\n// Move to archive when recent fills",
    answersList: [
      "Approach 3 is best because:\n1. Fixed memory usage for recent events\n2. No periodic transfer overhead\n3. Guaranteed response time for new events\n4. Clear separation of concerns\n5. Natural archival process",
      "Approach 1 is best for simplicity",
      "Approach 2 is best for organization",
      "All approaches are equivalent",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real logging systems (like application monitors) must handle sudden event bursts while maintaining performance. Circular buffer provides best balance of speed and memory.",
      "Single ArrayList would grow unbounded",
      "Periodic transfers could miss events",
      "Approaches have significant differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a caching system for a web browser's back/forward navigation that optimizes memory use while maintaining good performance:",
    code: "Requirements:\n1. Store page content for quick back/forward\n2. Limited memory use (max 50MB)\n3. Prioritize recent pages\n4. Handle long navigation chains\n5. Quick response time\n\nConsider:\n- Page sizes vary (100KB - 5MB)\n- Users may jump multiple pages\n- Some pages visited frequently",
    answersList: [
      "Solution:\nclass BrowserCache {\n    LinkedHashMap<String, Page> recentPages;  // URL -> Page, LRU order\n    Stack<String> backStack;    // Only URLs\n    Stack<String> forwardStack; // Only URLs\n    \n    // Load page from cache or network\n    // Remove oldest when memory limit reached\n    // Keep stacks small by pruning old entries\n}",
      "Just use ArrayList of pages",
      "Simple Stack is sufficient",
      "Queue would work best",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real browsers (like Chrome) use similar systems. Separating navigation history from content cache allows memory management without breaking navigation.",
      "ArrayList wouldn't handle memory constraints",
      "Stack alone can't manage memory",
      "Queue doesn't match navigation pattern",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question:
      "Find all potential failure points in this message queue implementation:",
    code: "class MessageQueue {\n    private Queue<Message> messages = new LinkedList<>();\n    private Map<String, Integer> messageCount = new HashMap<>();\n    private int maxRetries = 3;\n    \n    public void addMessage(Message msg) {\n        messages.offer(msg);\n        messageCount.put(msg.getId(), 0);\n    }\n    \n    public void processMessages() {\n        while(!messages.isEmpty()) {\n            Message msg = messages.poll();\n            try {\n                processMessage(msg);\n                messageCount.remove(msg.getId());\n            } catch(Exception e) {\n                int retries = messageCount.get(msg.getId());\n                if(retries < maxRetries) {\n                    messages.offer(msg);\n                    messageCount.put(msg.getId(), retries + 1);\n                }\n            }\n        }\n    }",
    answersList: [
      "Critical issues:\n1. Memory leak if message always fails (never removed from messageCount)\n2. No timeout handling\n3. Lost messages if system crashes during processing\n4. Potential infinite loop with poison messages\n5. No message priority handling\n6. Race condition between count check and increment",
      "Just needs better error handling",
      "Queue is wrong choice",
      "Only needs timeout handling",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real message queues (like RabbitMQ) must handle these edge cases. This implementation would fail under load or with problematic messages.",
      "Simple error handling insufficient",
      "Queue is appropriate base structure",
      "Multiple critical issues exist",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a system to manage tabbed browsing in a web browser, handling these scenarios:",
    code: "Requirements:\n1. Open/close tabs\n2. Switch between tabs\n3. Restore recently closed tabs\n4. Group related tabs\n5. Handle low memory conditions\n6. Restore session after crash\n\nConsiderations:\n- Users often have many tabs (50+)\n- Some tabs inactive for days\n- Memory usage per tab varies greatly\n- Need fast tab switching",
    answersList: [
      "Solution:\nclass TabManager {\n    ArrayList<Tab> activeTabs;        // Current tabs\n    LinkedHashMap<Tab, Long> tabCache; // LRU cache of tab content\n    Stack<Tab> recentlyClosed;        // For restore\n    Map<String, List<Tab>> groups;    // Tab grouping\n    \n    // Unload inactive tabs when memory low\n    // Save tab state to disk periodically\n    // Load tab content on demand\n}",
      "Just use ArrayList of tabs",
      "Stack of tabs is enough",
      "Queue would work best",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real browsers (like Firefox) use similar systems. Multiple collections serve different purposes: fast switching, memory management, restoration.",
      "ArrayList alone can't handle all requirements",
      "Stack doesn't provide needed functionality",
      "Queue doesn't match usage patterns",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question:
      "A collaborative document editor's change tracking system has mysterious bugs. Analyze why:",
    code: "class DocumentHistory {\n    private Stack<Change> undoStack = new Stack<>();\n    private Stack<Change> redoStack = new Stack<>();\n    private List<String> collaborators = new ArrayList<>();\n    \n    public void applyChange(Change change) {\n        if (collaborators.contains(change.getAuthor())) {\n            undoStack.push(change);\n            redoStack.clear();  // Clear redo history\n            applyToDocument(change);\n        }\n    }\n    \n    public void undo() {\n        if (!undoStack.empty()) {\n            Change change = undoStack.pop();\n            redoStack.push(change);\n            revertChange(change);\n        }\n    }",
    answersList: [
      "Critical issues:\n1. No timestamp ordering - parallel changes get wrong order\n2. Undo affects other users' changes\n3. No merge conflict resolution\n4. Changes might revert in wrong order\n5. No handling of failed changes",
      "Just needs error handling",
      "Stack is wrong choice",
      "Only needs timestamps",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real collaborative editors (like Google Docs) need complex change management. Simple stack-based undo/redo breaks with multiple users.",
      "Simple error handling won't fix fundamental issues",
      "Stack is good for single-user undo",
      "Timestamps alone don't solve conflicts",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Compare these approaches for implementing a game save system that needs to handle auto-saves, manual saves, and checkpoints:",
    code: "// Approach 1: Single ArrayList with all saves\nArrayList<GameSave> allSaves;\n\n// Approach 2: Separate collections by type\nQueue<GameSave> autoSaves;    // Limited size, FIFO\nArrayList<GameSave> manualSaves; // User managed\nStack<GameSave> checkpoints;    // Level based\n\n// Approach 3: Priority based single collection\nPriorityQueue<GameSave> saves;  // Ordered by type/time",
    answersList: [
      "Approach 2 is best because:\n1. Natural handling of different save types\n2. Automatic cleanup of old auto-saves\n3. Preserves manual saves indefinitely\n4. Quick checkpoint access for respawning\n5. Clear separation of concerns",
      "Approach 1 is simpler",
      "Approach 3 handles priorities",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real games (like RPGs) need flexible save systems. Different save types have different requirements - separate collections match natural behavior.",
      "Simple list makes management difficult",
      "Priority doesn't match use cases",
      "Approaches have clear differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a system to handle multi-level undo/redo for an image editor that supports layers:",
    code: "Requirements:\n1. Each layer has separate history\n2. Changes can affect multiple layers\n3. Layer operations (add/delete/merge)\n4. Memory efficient for large images\n5. Quick response for undo/redo\n\nConsiderations:\n- Images can be very large\n- Users expect immediate response\n- Limited memory available\n- Need to handle failed operations",
    answersList: [
      "class ImageEditor {\n    Map<Layer, Stack<Change>> layerHistory;     // Per-layer changes\n    Stack<GroupChange> globalHistory;         // Multi-layer changes\n    LRUCache<ChangeID, ImageData> dataCache;  // Cache for quick undo\n    \n    // Store change descriptions separately from pixel data\n    // Cache only most recent changes\n    // Merge consecutive similar changes\n    // Background thread for cleanup\n}",
      "Single Stack per image",
      "Just use ArrayList",
      "Queue would work best",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real image editors (like Photoshop) use similar systems. Separate histories allow efficient undo while managing memory.",
      "Single Stack can't handle complexity",
      "ArrayList doesn't provide needed structure",
      "Queue doesn't match undo/redo pattern",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question: "Find the problems with this auction system bid manager:",
    code: "class BidManager {\n    private PriorityQueue<Bid> bids;\n    private Map<String, Double> highestBids;\n    private final double INCREMENT = 1.0;\n    \n    public boolean placeBid(String item, String bidder, double amount) {\n        Double current = highestBids.get(item);\n        if (current == null || amount >= current + INCREMENT) {\n            bids.offer(new Bid(item, bidder, amount));\n            highestBids.put(item, amount);\n            return true;\n        }\n        return false;\n    }\n    \n    public List<Bid> getWinningBids() {\n        return bids.stream()\n            .filter(bid -> bid.amount == highestBids.get(bid.item))\n            .collect(Collectors.toList());\n    }",
    answersList: [
      "Critical issues:\n1. Race condition on highest bid check\n2. No bid retraction handling\n3. No auction end time enforcement\n4. Memory leak (keeps all bids)\n5. No shill bid detection\n6. Inconsistent state possible between collections",
      "Just needs synchronization",
      "Wrong queue type",
      "Only needs timeouts",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real auction systems (like eBay) must handle these issues. Simple bid tracking isn't enough - need transaction safety and fraud prevention.",
      "Synchronization alone insufficient",
      "Queue type isn't main issue",
      "Multiple critical issues exist",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a playlist system for a music app that supports both automatic (AI-based) and manual song queuing:",
    code: "Requirements:\n1. Mix manual and auto-selected songs\n2. Allow reordering of upcoming songs\n3. Smart insertion of auto songs\n4. Handle user skips/likes/dislikes\n5. Maintain flow of similar songs\n\nConstraints:\n- Don't repeat songs too soon\n- Keep some user-added songs always\n- Balance familiar and new songs\n- Quick response to changes",
    answersList: [
      "class SmartPlaylist {\n    LinkedList<Song> upNext;        // Manually ordered queue\n    PriorityQueue<Song> autoQueue;  // Scored by AI match\n    Set<String> recentlyPlayed;     // Avoid repeats\n    Map<String, Double> userPrefs;  // Track preferences\n    \n    // Insert auto songs between manual ones\n    // Adjust scores based on user actions\n    // Background thread for queue filling\n}",
      "Single Queue sufficient",
      "ArrayList would work",
      "Just use Stack",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real music apps (like Spotify) use similar systems. Multiple collections serve different purposes while maintaining user control.",
      "Single Queue too limiting",
      "ArrayList doesn't provide needed features",
      "Stack wrong for playback order",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Compare approaches for implementing a task scheduler that handles both periodic and priority-based tasks:",
    code: "// Approach 1: Single PriorityQueue\nclass Task implements Comparable<Task> {\n    int priority;\n    long nextRun;\n    // compareTo() combines priority and timing\n}\n\n// Approach 2: Multiple Queues\nQueue<Task> highPriority;\nQueue<Task> periodic;\nQueue<Task> background;\n\n// Approach 3: Scheduled + Priority\nScheduledExecutorService scheduled;\nPriorityQueue<Task> dynamic;",
    answersList: [
      "Approach 3 is best because:\n1. Proper thread handling for periodic tasks\n2. Natural priority for dynamic tasks\n3. Better system resource usage\n4. Handles task cancellation properly\n5. Cleaner separation of concerns",
      "Approach 1 is simpler",
      "Approach 2 more organized",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real schedulers (like job systems) need to handle both timing and priority. Separate handling of periodic and dynamic tasks matches system needs.",
      "Single queue makes timing complex",
      "Multiple queues need coordination",
      "Approaches have clear differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question: "Find the problems in this chat system message handler:",
    code: "class ChatSystem {\n    private Map<String, Queue<Message>> userQueues;\n    private Map<String, List<String>> chatGroups;\n    \n    public void sendMessage(Message msg) {\n        String group = msg.getGroupId();\n        List<String> members = chatGroups.get(group);\n        if (members != null) {\n            for (String user : members) {\n                Queue<Message> queue = userQueues.get(user);\n                if (queue != null) {\n                    queue.offer(msg);\n                }\n            }\n        }\n    }\n    \n    public List<Message> getMessages(String userId) {\n        Queue<Message> queue = userQueues.get(userId);\n        List<Message> messages = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            messages.add(queue.poll());\n        }\n        return messages;\n    }",
    answersList: [
      "Critical issues:\n1. Messages lost if user offline (queue null)\n2. No message persistence\n3. Memory leak with inactive users\n4. Race condition in message retrieval\n5. No delivery confirmation\n6. Group membership changes not handled",
      "Just needs error handling",
      "Queue wrong choice",
      "Only needs synchronization",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real chat systems (like WhatsApp) must handle these edge cases. Messages must be persistent and reliably delivered.",
      "Simple error handling insufficient",
      "Queue appropriate for message order",
      "Multiple critical issues exist",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question: "Design a system for managing database query results caching:",
    code: "Requirements:\n1. Cache frequent queries\n2. Limit memory usage\n3. Handle result invalidation\n4. Support partial results\n5. Quick cache hits\n\nConstraints:\n- Limited memory\n- Results vary in size\n- Some queries very common\n- Results become stale\n- Multiple apps accessing",
    answersList: [
      "class QueryCache {\n    LinkedHashMap<Query, Result> fullCache;     // LRU full results\n    Map<String, Set<Query>> tableToQueries;   // For invalidation\n    PriorityQueue<CacheEntry> memoryManager;  // By size/usage\n    \n    // Evict based on size and frequency\n    // Track table dependencies\n    // Background refresh of common queries\n}",
      "Simple Map sufficient",
      "Just use ArrayList",
      "Queue would work best",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real databases (like Redis) use similar caching. Need to balance memory use with hit rate while maintaining consistency.",
      "Map doesn't handle all requirements",
      "ArrayList doesn't provide needed features",
      "Queue wrong for random access",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Compare approaches for implementing a browser password manager's secure storage:",
    code: "// Approach 1: Single encrypted list\nArrayList<EncryptedPassword> passwords;\n\n// Approach 2: Domain-based organization\nMap<String, List<EncryptedPassword>> domainPasswords;\nQueue<PasswordUpdate> pendingSyncs;\n\n// Approach 3: Hierarchical storage\nMap<String, Map<String, EncryptedPassword>> sitePasswords;\nLinkedList<PasswordChange> changeLog;",
    answersList: [
      "Approach 2 is best because:\n1. Natural organization by domain\n2. Quick lookup when autofilling\n3. Efficient syncing of changes\n4. Better security isolation\n5. Easier backup/restore per site",
      "Approach 1 is simpler",
      "Approach 3 more organized",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real password managers (like LastPass) need quick access and reliable sync. Domain-based storage matches usage patterns.",
      "Single list slows lookups",
      "Hierarchical adds complexity",
      "Approaches have clear differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "A game development team used this inventory system and players are losing items. Why?",
    code: "class Inventory {\n    private ArrayList<Item> backpack = new ArrayList<>(20);\n    private Map<String, Integer> itemCounts = new HashMap<>();\n    \n    public boolean addItem(Item item) {\n        if (backpack.size() < 20) {\n            backpack.add(item);\n            itemCounts.put(item.getId(), \n                itemCounts.getOrDefault(item.getId(), 0) + 1);\n            return true;\n        }\n        return false;\n    }\n    \n    public void removeItem(Item item) {\n        if (backpack.remove(item)) {\n            int count = itemCounts.get(item.getId());\n            if (count <= 1) itemCounts.remove(item.getId());\n            else itemCounts.put(item.getId(), count - 1);\n        }\n    }",
    answersList: [
      "Bugs:\n1. remove() uses equals() - might remove wrong instance\n2. No thread safety for multiplayer trading\n3. Map update not atomic with list change\n4. NullPointerException if item ID null\n5. Inconsistent state if exception during add/remove",
      "Just needs simple error handling",
      "ArrayList is wrong choice",
      "Only needs synchronization",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real game inventories must handle complex cases like item stacking, unique items, and concurrent trades. This implementation would lose items in these scenarios.",
      "Simple error checks won't fix core issues",
      "ArrayList works for inventory slots",
      "Multiple issues beyond concurrency",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design an undo system for a spreadsheet where cells can depend on each other:",
    code: "Requirements:\n1. Track cell formula changes\n2. Handle dependent cell updates\n3. Batch changes as single undo\n4. Prevent circular references\n5. Memory efficient\n\nExample:\nA1 = 5\nB1 = A1 * 2\nC1 = SUM(A1:B1)\n// When A1 changes, B1 and C1 must update",
    answersList: [
      "class SpreadsheetHistory {\n    Stack<Change> undoStack;\n    Map<CellRef, Set<CellRef>> dependencies;\n    Map<CellRef, Set<CellRef>> reverseDeps;\n    Queue<CellRef> updateQueue;\n    \n    // Group related changes in single undo\n    // Track dependency chain for updates\n    // Cache computed values where possible\n}",
      "Single Stack enough",
      "Just use ArrayList",
      "Queue handles all needs",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real spreadsheets (like Excel) need complex change tracking. Dependencies require careful ordering of updates while maintaining undo capability.",
      "Stack alone can't handle dependencies",
      "ArrayList doesn't track relationships",
      "Queue doesn't handle undo/redo",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Compare these implementations for a printer job manager that handles different priorities:",
    code: "// Approach 1: Single PriorityQueue\nPriorityQueue<PrintJob> jobs = new PriorityQueue<>();\n\n// Approach 2: Multiple Queues\nQueue<PrintJob> urgent = new LinkedList<>();\nQueue<PrintJob> normal = new LinkedList<>();\nQueue<PrintJob> batch = new LinkedList<>();\n\n// Approach 3: Priority Levels in List\nArrayList<PrintJob> jobs = new ArrayList<>();\n// Sort by priority when needed",
    answersList: [
      "Approach 2 is best because:\n1. Natural handling of priorities\n2. Fast selection of next job\n3. Easy to modify queue policies\n4. Can process batch jobs differently\n5. Better starvation prevention",
      "Approach 1 is simpler",
      "Approach 3 more flexible",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real print systems (like CUPS) use multiple queues. It's easier to implement policies like 'urgent jobs interrupt batch' with separate queues.",
      "PriorityQueue might cause starvation",
      "Sorting full list is inefficient",
      "Each has significant tradeoffs",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "This code manages a music player's shuffle feature. What problems will users notice?",
    code: "class ShufflePlayer {\n    private List<Song> playlist;\n    private Stack<Song> playHistory;\n    private Random random = new Random();\n    \n    public Song getNextSong() {\n        if (playlist.isEmpty()) {\n            while (!playHistory.isEmpty()) {\n                playlist.add(playHistory.pop());\n            }\n        }\n        int index = random.nextInt(playlist.size());\n        Song next = playlist.remove(index);\n        playHistory.push(next);\n        return next;\n    }",
    answersList: [
      "Problems:\n1. Same song might play twice in short sequence\n2. Last songs of old shuffle affect next shuffle\n3. No weighting for user preferences\n4. Memory inefficient for large playlists\n5. Removing from ArrayList is O(n)",
      "Just needs randomization",
      "Stack is wrong choice",
      "Only needs better Random",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real music players (like Spotify) use complex shuffle algorithms. Simple random selection doesn't feel random to users and can be inefficient.",
      "Better randomization not enough",
      "Stack works for history",
      "Random quality not main issue",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a system to manage real-time game state synchronization between players:",
    code: "Requirements:\n1. Track player actions\n2. Handle network delay\n3. Resolve conflicts\n4. Support replay\n5. Allow rollback\n\nConstraints:\n- Actions must be ordered\n- Low latency needed\n- State must stay consistent\n- Bandwidth limited\n- Support disconnections",
    answersList: [
      "class GameSync {\n    Queue<Action> pendingActions;      // Unconfirmed local\n    Queue<Action> confirmedActions;    // Agreed order\n    Map<Player, Queue<Action>> playerActions; // Per-player\n    Stack<GameState> stateHistory;     // For rollback\n    \n    // Use timestamps for ordering\n    // Keep recent states for resync\n    // Batch small actions\n}",
      "Single Queue enough",
      "Just use ArrayList",
      "Stack handles all cases",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real multiplayer games (like fighters) need sophisticated sync. Multiple collections handle different aspects of the problem.",
      "Queue alone can't handle resync",
      "ArrayList doesn't handle ordering",
      "Stack doesn't handle all cases",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Compare approaches for implementing a browser's download manager with pause/resume:",
    code: "// Approach 1: Queue-based\nQueue<Download> active = new LinkedList<>();\nQueue<Download> paused = new LinkedList<>();\n\n// Approach 2: Status-based\nArrayList<Download> downloads = new ArrayList<>();\n// Filter by status when needed\n\n// Approach 3: Priority + Status\nPriorityQueue<Download> downloads;\n// Priority includes status",
    answersList: [
      "Approach 2 is best because:\n1. Easy to show all downloads\n2. Simple status transitions\n3. Maintains download order\n4. Better UI updates\n5. Easier to save state",
      "Approach 1 is simpler",
      "Approach 3 more powerful",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real download managers (like in Chrome) need to show all downloads regardless of status. Separate queues make this harder.",
      "Multiple queues add complexity",
      "Priority not main concern",
      "Approaches have clear differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question: "Find the issues in this social media feed aggregator:",
    code: "class FeedAggregator {\n    private Map<String, Queue<Post>> sourceFeeds;\n    private List<Post> mergedFeed = new ArrayList<>();\n    \n    public void addPost(String source, Post post) {\n        Queue<Post> feed = sourceFeeds.get(source);\n        if (feed != null) {\n            feed.offer(post);\n            mergedFeed.add(post);\n            Collections.sort(mergedFeed, \n                (a, b) -> b.getTimestamp().compareTo(a.getTimestamp()));\n        }\n    }\n    \n    public List<Post> getRecentPosts(int count) {\n        return mergedFeed.subList(0, \n            Math.min(count, mergedFeed.size()));\n    }",
    answersList: [
      "Issues:\n1. O(n log n) sort on every post\n2. Duplicate posts possible\n3. No memory management\n4. Thread safety issues\n5. Inconsistent if sort fails\n6. No cleanup of old posts",
      "Just needs error handling",
      "Queue is wrong choice",
      "Only needs better sorting",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real feed systems (like Twitter) need efficient merging. Sorting full list on every update doesn't scale.",
      "Error handling won't fix scaling",
      "Queue works for source feeds",
      "Sorting is one of many issues",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a system to handle interactive tutorials in a complex application:",
    code: "Requirements:\n1. Guide user through steps\n2. Handle user deviations\n3. Support back/forward\n4. Skip completed steps\n5. Save progress\n\nChallenges:\n- Users may need different paths\n- Steps might become invalid\n- Need to track completion\n- Handle app state changes\n- Support multiple tutorials",
    answersList: [
      "class TutorialManager {\n    Map<String, Queue<Step>> tutorials;     // All tutorials\n    Stack<Step> currentPath;              // User's progress\n    Set<String> completed;                // Finished steps\n    Queue<Step> remaining;                // Adapted to user\n    \n    // Validate steps before showing\n    // Allow branch points\n    // Track dependencies between steps\n}",
      "Single Stack enough",
      "Just use ArrayList",
      "Queue handles all needs",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real tutorials (like in complex software) need flexible guidance. Different collections handle different aspects of progress tracking.",
      "Stack alone can't handle branches",
      "ArrayList doesn't track progress well",
      "Queue too rigid for navigation",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Compare these implementations for a form validation system with interdependent fields:",
    code: "// Approach 1: Immediate Validation\nclass Form1 {\n    Map<String, Queue<String>> fieldErrors;\n    Map<String, Set<String>> dependencies;\n    // Validate on each change\n}\n\n// Approach 2: Deferred Validation\nclass Form2 {\n    Stack<Change> changes;\n    Map<String, List<Validator>> validators;\n    // Validate on submit\n}\n\n// Approach 3: Progressive Validation\nclass Form3 {\n    PriorityQueue<Field> validationQueue;\n    Map<String, ValidationState> states;\n    // Validate based on dependencies",
    answersList: [
      "Approach 3 is best because:\n1. Efficient handling of dependencies\n2. Early feedback for simple fields\n3. Avoids redundant validation\n4. Better user experience\n5. More maintainable validation logic",
      "Approach 1 is simpler",
      "Approach 2 more efficient",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real forms (like in web apps) need smart validation. Priority-based validation provides best balance of efficiency and user feedback.",
      "Immediate validation wasteful",
      "Deferred validation poor UX",
      "Approaches have clear tradeoffs",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 5,
    question:
      "Design a system for managing application plugin dependencies and loading:",
    code: "Requirements:\n1. Handle plugin dependencies\n2. Manage load order\n3. Support hot-reload\n4. Prevent conflicts\n5. Version compatibility\n\nChallenges:\n- Circular dependencies\n- Optional plugins\n- Resource management\n- Error recovery\n- Performance impact",
    answersList: [
      "class PluginManager {\n    Map<String, Set<String>> dependencies;  // Required plugins\n    Queue<Plugin> loadQueue;               // Ordered loading\n    Stack<PluginAction> undoStack;         // For rollback\n    Map<String, List<String>> provides;    // Features\n    \n    // Use topological sort for load order\n    // Track reverse dependencies\n    // Support graceful degradation\n}",
      "Single Map enough",
      "Just use ArrayList",
      "Queue handles all needs",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real plugin systems (like in IDEs) need sophisticated dependency management. Multiple collections handle different aspects of the problem.",
      "Map alone can't handle ordering",
      "ArrayList doesn't handle dependencies",
      "Queue too simple for relationships",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "This code for a student course registration system has problems. Find them:",
    code: "class CourseRegistration {\n    Map<String, Queue<String>> waitlists;     // course -> student IDs\n    Map<String, ArrayList<String>> enrolled;  // course -> enrolled\n    Map<String, Integer> courseLimits;        // course -> max size\n    \n    public boolean register(String courseId, String studentId) {\n        ArrayList<String> students = enrolled.get(courseId);\n        if (students.size() < courseLimits.get(courseId)) {\n            students.add(studentId);\n            return true;\n        } else {\n            waitlists.get(courseId).offer(studentId);\n            return false;\n        }\n    }\n    \n    public void dropCourse(String courseId, String studentId) {\n        enrolled.get(courseId).remove(studentId);\n        if (!waitlists.get(courseId).isEmpty()) {\n            String next = waitlists.get(courseId).poll();\n            enrolled.get(courseId).add(next);\n        }\n    }",
    answersList: [
      "Problems:\n1. No null checks (course/student might not exist)\n2. Student could enroll multiple times\n3. No check if student already waitlisted\n4. Possible race condition during drop/enroll\n5. Student could be in multiple waitlists",
      "Just needs error handling",
      "Queue wrong choice for waitlist",
      "Only needs null checks",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real registration systems must handle these cases. Students shouldn't be able to exploit system to get multiple spots.",
      "Simple error checks not enough",
      "Queue appropriate for waitlist order",
      "Multiple issues beyond nulls",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Design a task management system for a study group where tasks can have dependencies:",
    code: "Requirements:\n1. Add/remove tasks\n2. Track task dependencies\n3. Show available tasks\n4. Mark tasks complete\n5. Suggest next task\n\nExample:\n'Read Chapter 1' must be done before 'Quiz 1'\n'Practice Problems' depends on 'Watch Lecture'",
    answersList: [
      "class StudyPlanner {\n    Map<String, Set<String>> dependencies;  // task -> required tasks\n    Set<String> completed;                // finished tasks\n    Queue<String> available;              // tasks ready to do\n    \n    // Check dependencies when marking complete\n    // Add tasks to available when dependencies met\n    // Track completion order for suggestions\n}",
      "Single List enough",
      "Just use Queue",
      "Stack would work",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real study planners, need to track what can be done now vs what needs prerequisites. Multiple collections handle different needs.",
      "List can't handle dependencies",
      "Queue alone too simple",
      "Stack wrong for dependencies",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Compare these approaches for implementing a browser's bookmark system:",
    code: "// Approach 1: Folder-based\nclass Folder {\n    Map<String, ArrayList<String>> bookmarks;\n    Map<String, Folder> subfolders;\n}\n\n// Approach 2: Tag-based\nclass BookmarkSystem {\n    ArrayList<String> bookmarks;\n    Map<String, Set<String>> tags;\n}\n\n// Approach 3: Mixed\nclass HybridBookmarks {\n    Map<String, List<String>> folders;\n    Map<String, Set<String>> tags;\n}",
    answersList: [
      "Approach 3 (Hybrid) is best because:\n1. Natural folder organization\n2. Flexible tag searching\n3. Bookmarks can be in multiple categories\n4. Easier to migrate from old systems\n5. Better search options",
      "Approach 1 is simpler",
      "Approach 2 more flexible",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real bookmark systems (like in Chrome) often support both folders and tags. Hybrid approach gives users flexibility.",
      "Pure folders too limiting",
      "Pure tags can be confusing",
      "Approaches have clear differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "A student wrote this code for tracking movie watchlist. What problems will users face?",
    code: "class MovieList {\n    Stack<String> toWatch = new Stack<>();    // Movies to watch\n    ArrayList<String> watched = new ArrayList<>(); // Completed\n    \n    public void addMovie(String movie) {\n        toWatch.push(movie);\n    }\n    \n    public void markWatched() {\n        if (!toWatch.empty()) {\n            watched.add(toWatch.pop());\n        }\n    }\n    \n    public String getNextMovie() {\n        return toWatch.peek();\n    }",
    answersList: [
      "Problems:\n1. Most recent additions watched first (LIFO)\n2. Can't reorder watch list\n3. Duplicates possible in both lists\n4. Can't mark specific movie watched\n5. No way to remove without watching",
      "Stack is wrong choice",
      "Just needs error handling",
      "ArrayList is wrong choice",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real watchlists need more flexibility. Stack forces newest movies to be watched first, which isn't natural.",
      "Stack works but for different purpose",
      "Error handling won't fix usability",
      "ArrayList works for watched movies",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question: "Design a system for managing assignments in a grade book:",
    code: "Requirements:\n1. Add assignments with due dates\n2. Track submissions\n3. Calculate running grades\n4. Allow late submissions\n5. Support extra credit\n\nNeeds:\n- Grade calculation by category\n- Drop lowest grade option\n- Weight different assignments\n- Track missing work",
    answersList: [
      "class GradeBook {\n    Map<String, PriorityQueue<Assignment>> byDueDate;\n    Map<String, List<Grade>> studentGrades;\n    Map<String, Double> categoryWeights;\n    \n    // Use priority queue for upcoming work\n    // Keep all grades for recalculation\n    // Track submission times\n}",
      "Single List enough",
      "Just use Map",
      "Queue handles all needs",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real grade books, need flexible storage and calculation. Different collections handle different aspects (timing, grades, weights).",
      "List too simple for requirements",
      "Map alone can't handle ordering",
      "Queue doesn't handle all cases",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Compare these implementations for a simple word processor's paragraph management:",
    code: "// Approach 1: Linear\nArrayList<String> paragraphs;\n\n// Approach 2: Chunked\nList<ArrayList<String>> sections;\n\n// Approach 3: Double-Ended\nLinkedList<String> paragraphs;\n\nNeeded Operations:\n- Insert/delete paragraphs\n- Move paragraphs\n- Merge/split paragraphs\n- Format sections",
    answersList: [
      "Approach 3 (LinkedList) is best because:\n1. Efficient insertion/deletion\n2. Easy merge/split operations\n3. Natural paragraph reordering\n4. Good for large documents\n5. Simple section management",
      "Approach 1 is simpler",
      "Approach 2 more organized",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like simple word processors, need efficient paragraph operations. LinkedList provides needed flexibility without complexity of chunks.",
      "ArrayList shifts too much",
      "Chunks add unnecessary complexity",
      "Performance differences matter",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 4,
    question:
      "Find the problems with this code for managing a student help queue:",
    code: "class HelpQueue {\n    Queue<String> studentQueue = new LinkedList<>();\n    Map<String, Integer> helpCount = new HashMap<>();\n    \n    public void addStudent(String studentId) {\n        studentQueue.offer(studentId);\n        helpCount.put(studentId, \n            helpCount.getOrDefault(studentId, 0) + 1);\n    }\n    \n    public String helpNextStudent() {\n        return studentQueue.poll();\n    }\n    \n    public void returnToQueue(String studentId) {\n        studentQueue.offer(studentId);\n    }",
    answersList: [
      "Problems:\n1. Students count increases even if already in queue\n2. Can add same student multiple times\n3. No limit on help count\n4. No priority for long-waiting students\n5. Can't remove student who leaves",
      "Queue wrong choice",
      "Just needs error checks",
      "Only needs counting fix",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real help queues need fairness and flexibility. This implementation allows students to game the system.",
      "Queue good for basic ordering",
      "Error checks won't fix fairness",
      "Multiple issues beyond counting",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question: "Design a simple library book tracking system:",
    code: "Requirements:\n1. Track available/checked out books\n2. Handle reservations\n3. Process returns\n4. Show due dates\n5. Handle renewals\n\nNeeds:\n- Late fee calculation\n- Multiple copies of books\n- Hold queue for popular books\n- Check-out history",
    answersList: [
      "class Library {\n    Map<String, List<BookCopy>> inventory;   // book -> copies\n    Map<String, Queue<String>> holds;       // book -> student queue\n    Map<String, Date> dueBooks;           // copy -> due date\n    List<Transaction> history;            // all activity\n    \n    // Track individual copy status\n    // Maintain hold queue order\n    // Update due dates on renewal\n}",
      "Single List enough",
      "Just use Queue",
      "Map handles everything",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real libraries, need to track both books and student requests. Different collections handle different aspects of system.",
      "List too simple for tracking",
      "Queue only handles holds",
      "Map alone too limiting",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 4,
    question:
      "Compare approaches for implementing a simple spell checker's suggestion system:",
    code: "// Approach 1: All Variations\nclass Checker1 {\n    Set<String> dictionary;\n    List<String> generateVariations(String word);\n}\n\n// Approach 2: Common Mistakes\nclass Checker2 {\n    Map<String, List<String>> commonErrors;\n    PriorityQueue<String> suggestions;\n}\n\n// Approach 3: Hybrid\nclass Checker3 {\n    Set<String> dictionary;\n    Map<String, List<String>> common;\n    // Check common first, then generate",
    answersList: [
      "Approach 3 (Hybrid) is best because:\n1. Fast check of common cases\n2. Fallback for unknown errors\n3. Can learn new mistakes\n4. Better suggestion quality\n5. More maintainable",
      "Approach 1 is simpler",
      "Approach 2 more efficient",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real spell checkers, need balance of speed and accuracy. Hybrid approach handles both common and unusual cases well.",
      "Generating all variations slow",
      "Common mistakes alone limiting",
      "Approaches have clear differences",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question: "Design a system for managing a student's homework schedule:",
    code: "Requirements:\n1. Track assignments by class\n2. Show upcoming due dates\n3. Estimate work time needed\n4. Set work priorities\n5. Mark completion\n\nNeeds:\n- Weekly view\n- Time management\n- Progress tracking\n- Workload balancing",
    answersList: [
      "class HomeworkManager {\n    Map<String, PriorityQueue<Assignment>> byClass;\n    Queue<Assignment> thisWeek;\n    Map<String, Integer> workloadHours;\n    List<Assignment> completed;\n    \n    // Prioritize by due date and weight\n    // Track time estimates vs actual\n    // Show daily/weekly load\n}",
      "Single List enough",
      "Just use PriorityQueue",
      "Map handles all needs",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real homework planners, need multiple views of work. Different collections help organize by time, class, and priority.",
      "List too simple for organizing",
      "PriorityQueue alone too limiting",
      "Map misses temporal aspect",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What will happen when this simple playlist code runs?",
    code: 'Queue<String> songs = new LinkedList<>();\nsongs.offer("Song A");           // First\nsongs.offer("Song B");           // Second\nsongs.poll();                     // Play one\nsongs.offer("Song C");           // Add new\nSystem.out.println("Playing: " + songs.peek());\nSystem.out.println("Songs left: " + songs.size());',
    answersList: [
      "Playing: Song B\nSongs left: 2",
      "Playing: Song A\nSongs left: 2",
      "Playing: Song C\nSongs left: 1",
      "Playing: null\nSongs left: 0",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Track it step by step:\n1. Add A and B: [A,B]\n2. poll() removes A: [B]\n3. Add C: [B,C]\n4. peek() shows B (first in queue)",
      "A was removed by poll()",
      "C is at end of queue",
      "Queue still has elements",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Design a flashcard study system that adapts to student performance:",
    code: "Requirements:\n1. Show cards based on confidence level\n2. Repeat missed cards more often\n3. Track improvement over time\n4. Mix in review of old cards\n\nExample:\nStudent marks each answer:\n- Got it easily (review later)\n- Got it with effort (review soon)\n- Missed it (review very soon)",
    answersList: [
      "class FlashcardSystem {\n    PriorityQueue<Card> reviewQueue;      // Ordered by next review time\n    Map<Card, Integer> confidenceLevels;  // Track performance\n    Queue<Card> todayCards;              // Current study set\n    List<StudySession> history;          // Track progress\n    \n    // Adjust review timing based on confidence\n    // Mix new and review cards\n    // Show more difficult cards more often\n}",
      "Just use ArrayList of cards",
      "Single Queue is enough",
      "Map alone will work",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real flashcard apps (e.g., Anki), needs smart scheduling. Different collections handle study queue, performance tracking, and history.",
      "ArrayList can't handle scheduling",
      "Queue can't prioritize cards",
      "Map can't handle ordering",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Which collection should you use for this scenario and why?",
    code: "// Need to: \n1. Add students to class roster\n2. Remove students who drop\n3. Check if student is enrolled\n4. Print all students\n5. No special order needed",
    answersList: [
      "ArrayList - provides:\n1. Easy add/remove\n2. Fast contains() check\n3. Simple iteration\n4. Index access if needed",
      "Stack - LIFO not needed",
      "Queue - FIFO not needed",
      "LinkedList - overhead not needed",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList is simplest choice when order doesn't matter and you need easy access to all elements",
      "Stack ordering would complicate things",
      "Queue ordering not helpful here",
      "LinkedList adds unnecessary complexity",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Analyzing",
    difficulty: 5,
    question:
      "Analyze why this shared note-taking system fails with multiple users:",
    code: 'class SharedNotes {\n    private List<String> notes = new ArrayList<>();\n    private Stack<Change> undoHistory = new Stack<>();\n    \n    public synchronized void addNote(String note) {\n        notes.add(note);\n        undoHistory.push(new Change("add", notes.size()-1, note));\n    }\n    \n    public synchronized void deleteNote(int index) {\n        String note = notes.remove(index);\n        undoHistory.push(new Change("delete", index, note));\n    }\n    \n    public synchronized void undo() {\n        if (!undoHistory.empty()) {\n            Change change = undoHistory.pop();\n            if (change.type.equals("add")) {\n                notes.remove(change.index);\n            } else {\n                notes.add(change.index, change.note);\n            }\n        }\n    }',
    answersList: [
      "Problems:\n1. Index changes as others edit\n2. Undo affects wrong notes\n3. No conflict resolution\n4. Single undo stack shared\n5. Lost updates possible\n6. No user attribution",
      "Just needs more synchronization",
      "ArrayList wrong choice",
      "Only needs user tracking",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real collaborative editors need complex concurrency handling. Basic synchronization isn't enough when edits affect indexes.",
      "Sync won't fix fundamental issues",
      "ArrayList works for notes storage",
      "Multiple critical problems exist",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "Why does this shopping cart code cause errors?",
    code: 'ArrayList items = new ArrayList();  // no type\nitems.add("Milk");\nitems.add(5);\nitems.add(3.99);\n\nfor(String item : items) {  // cast to String\n    System.out.println("Item: " + item.toUpperCase());',
    answersList: [
      "No generic type means:\n1. Can mix types (dangerous)\n2. Needs explicit cast\n3. Runtime error when casting number to String\n4. Should use ArrayList<String>",
      "ArrayList can't store numbers",
      "toUpperCase() is wrong method",
      "for loop is incorrect",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Without generics, type safety is lost. Can add anything but fails when assuming all items are strings.",
      "ArrayList can store any type",
      "Method is fine for strings",
      "Loop syntax is correct",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question:
      "Design a system for managing student group projects with task assignments:",
    code: "Requirements:\n1. Track assigned tasks\n2. Show task dependencies\n3. Update task status\n4. Balance workload\n5. Show progress\n\nNeeds:\n- Fair distribution\n- Dependency handling\n- Progress tracking\n- Deadline management",
    answersList: [
      "class ProjectManager {\n    Map<Student, Queue<Task>> assignments;   // Per student todo\n    Map<Task, Set<Task>> dependencies;     // Task ordering\n    Map<Student, Integer> workload;        // Hours assigned\n    List<TaskUpdate> history;             // Track progress\n    \n    // Check dependencies before assignment\n    // Balance work hours\n    // Track completion rate\n}",
      "Single List per group",
      "Just use Queue",
      "Map alone sufficient",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real project management tools, needs to track multiple aspects: assignments, dependencies, workload, and progress.",
      "List too simple for relationships",
      "Queue can't handle dependencies",
      "Map misses ordering needs",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What happens to the index numbers in this ArrayList operation?",
    code: 'ArrayList<String> names = new ArrayList<>();\nnames.add("Amy");    // index 0\nnames.add("Bob");    // index 1\nnames.add("Cal");    // index 2\nnames.remove(1);     // remove Bob\nnames.add("Dan");    // add new name\n\nSystem.out.println(names.get(1));  // What prints?',
    answersList: [
      "Cal - because:\n1. Remove shifts elements left\n2. Cal moves from index 2 to 1\n3. Dan added at end (index 2)",
      "Bob - wasn't removed",
      "Dan - added at index 1",
      "null - position empty",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "ArrayList maintains consecutive indexes. When an element is removed, everything after shifts left to fill the gap.",
      "Bob was removed by remove(1)",
      "Dan added to end always",
      "Position filled by shift",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Evaluating",
    difficulty: 5,
    question:
      "Compare these approaches for implementing an exam question randomizer:",
    code: "// Approach 1: Shuffle Full List\nclass Exam1 {\n    List<Question> questions;\n    // Shuffle once at start\n}\n\n// Approach 2: Generate Order\nclass Exam2 {\n    Map<Student, List<Integer>> orderMap;\n    List<Question> questions;\n    // Generate unique order per student\n}\n\n// Approach 3: Question Pools\nclass Exam3 {\n    Map<String, Queue<Question>> pools;\n    Map<Student, List<Question>> exams;\n    // Draw from pools by topic",
    answersList: [
      "Approach 3 is best because:\n1. Can control topic distribution\n2. Adjusts difficulty spread\n3. Maintains question variety\n4. Easier to prevent cheating\n5. Better question reuse",
      "Approach 1 is simpler",
      "Approach 2 more fair",
      "All approaches equal",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Real exam systems need smart randomization. Topic pools ensure fair, balanced tests while preventing copying.",
      "Simple shuffle too random",
      "Order mapping complex",
      "Approaches have clear benefits",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Understanding",
    difficulty: 1,
    question: "What's wrong with using a Stack this way?",
    code: '// Trying to maintain list of recent documents\nStack<String> recent = new Stack<>();\n\n// User opens documents:\nrecent.push("doc1.txt");\nrecent.push("doc2.txt");\n\n// Looking for specific document:\nfor(int i = 0; i < recent.size(); i++) {\n    if(recent.get(i).equals("doc1.txt")) {\n        System.out.println("Found it!");\n    }',
    answersList: [
      "Problems:\n1. Using get() defeats Stack purpose\n2. Should use pop() to access\n3. ArrayList better for random access\n4. Stack meant for LIFO only",
      "Stack can't store strings",
      "Loop is wrong",
      "equals() won't work",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Stack is for LIFO (Last In First Out) operations. If you need random access, ArrayList is better choice.",
      "Stack can store any type",
      "Loop syntax is fine",
      "equals() works for strings",
    ],
  },
  {
    topic: "Lists, Queues, and Stacks",
    bloomTaxonomyCategory: "Creating",
    difficulty: 4,
    question: "Design a simple subway fare card system:",
    code: "Requirements:\n1. Track card balance\n2. Handle entry/exit\n3. Calculate trip fare\n4. Support transfers\n5. Detect invalid use\n\nNeeds:\n- Time-based transfers\n- Distance pricing\n- Multiple stations\n- Usage history",
    answersList: [
      "class FareSystem {\n    Map<Card, Double> balances;              // Card funds\n    Map<Card, Queue<Trip>> activeTrips;      // Current travel\n    Map<Card, List<Trip>> history;          // Past trips\n    Set<Card> blocked;                      // Invalid cards\n    \n    // Check balance at entry\n    // Calculate fare at exit\n    // Validate transfer time\n}",
      "Single Map enough",
      "Just use List",
      "Queue handles all",
    ],
    correctAnswerIndex: 0,
    explanationsList: [
      "Like real transit systems, needs to track multiple aspects: money, trips, history, and validity. Different collections handle different needs.",
      "Map too simple alone",
      "List can't handle ordering",
      "Queue missing key features",
    ],
  },
];

export default dataStructures;
