export const dummyData: {
    difficulty: number;
    question: string;
    code?: string;
    answers: string[];
    correct: number;
    explanations: string[];
    bloomTaxonomy: string;
    topic: string;
    }[] = [
    {
    difficulty: 2,
    question: "What is recursion?",
    code: "",
    answers: [
    "A programming technique where a function calls itself directly or indirectly.",
    "A programming technique where a function calls another function.",
    "A programming technique where a function is called by another function only.",
    "A programming technique where a function calls itself repeatedly without termination.",
    ],
    correct: 0,
    explanations: [
    "Recursion is a programming technique where a function calls itself directly or indirectly.",
    "Incorrect: Recursion involves a function calling itself, not necessarily another function.",
    "Incorrect: Recursion can involve a function calling itself, not necessarily by another function only.",
    "Incorrect: Recursion must eventually terminate to prevent infinite looping.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question: "What is the base case in recursion?",
    code: "",
    answers: [
    "The condition that terminates the recursive process.",
    "The condition that starts the recursive process.",
    "The condition that limits the number of recursive calls.",
    "The condition that checks if recursion is possible.",
    ],
    correct: 0,
    explanations: [
    "The base case in recursion is the condition that terminates the recursive process.",
    "The base case defines when the recursion should stop.",
    "Incorrect: The base case does not start the recursive process but ends it.",
    "Incorrect: The base case does not limit the number of recursive calls but defines when to stop them.",
    "Incorrect: The base case does not check if recursion is possible but when it should stop.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question: "What is the factorial of 0?",
    code: "",
    answers: ["1", "0", "Infinity", "Error"],
    correct: 0,
    explanations: [
    "The factorial of 0 is 1.",
    "By definition, the factorial of 0 is 1.",
    "Incorrect: The factorial of 0 is not 0.",
    "Incorrect: The factorial of 0 is not infinity.",
    "Incorrect: There is no error in calculating the factorial of 0.",
    ],
    bloomTaxonomy: "Remembering",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question:
    "Which of the following is a characteristic of recursive algorithms?",
    code: "",
    answers: [
    "They require a base case to terminate the recursion.",
    
    "They can only solve problems with a single solution.",
    "They are less memory efficient compared to iterative algorithms.",
    "They always have a linear time complexity.",
    ],
    correct: 0,
    explanations: [
    "A characteristic of recursive algorithms is that they require a base case to terminate the recursion.",
    "The base case defines when the recursion should stop.",
    "Incorrect: Recursive algorithms can solve problems with multiple solutions.",
    "Incorrect: The efficiency of recursive algorithms depends on the problem and implementation.",
    "Incorrect: The time complexity of recursive algorithms can vary depending on the problem.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question: "What is tail recursion?",
    code: "",
    
    answers: [
    "A recursive function where the recursive call is the last operation in the function.",
    "A recursive function where the base case is omitted.",
    "A recursive function where the recursive call is made before any other operations in the function.",
    "A recursive function where the base case is never reached.",
    ],
    correct: 0,
    explanations: [
    "Tail recursion is a recursive function where the recursive call is the last operation in the function.",
    "In tail recursion, no computation is done after the recursive call.",
    "Incorrect: Tail recursion still has a base case, it's the position of the recursive call that matters.",
    "Incorrect: Tail recursion does not necessarily omit the base case.",
    "Incorrect: Tail recursion still reaches the base case, it's just positioned differently.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    
    {
    difficulty: 2,
    question:
    "What is the output of the following recursive function in Java?\nint sum(int n) {\n  if (n <= 0) {\n    return 0;\n  }\n  return n + sum(n - 1);\n}\nsum(4);",
    code: "",
    answers: ["10", "6", "4", "0"],
    correct: 0,
    explanations: [
    "The output of the recursive function sum(4) is 10.",
    "The function recursively sums up all integers from 4 to 1.",
    "Incorrect: The sum of integers from 1 to 4 is not 6.",
    "Incorrect: The function sums up integers starting from 4.",
    "Incorrect: The function does not return 0 when n is less than or equal to 0, but when n equals 0.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question:
    "Which of the following data structures can be implemented using recursion?",
    code: "",
    answers: ["Trees", "Stacks", "Queues", "Arrays"],
    correct: 0,
    explanations: [
    "Trees can be implemented using recursion.",
    "Recursion is commonly used to traverse and manipulate tree structures.",
    "Incorrect: Stacks and queues are typically implemented using iterative approaches.",
    "Incorrect: Arrays are not typically implemented using recursion due to their linear structure.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question:
    "What is the time complexity of the following recursive function in terms of Big O notation?\nint fibonacci(int n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n",
    code: "",
    answers: ["O(2^n)", "O(n^2)", "O(log n)", "O(n)"],
    correct: 0,
    explanations: [
    "The time complexity of the Fibonacci recursive function is O(2^n).",
    "The function makes two recursive calls at each step, leading to exponential time complexity.",
    "Incorrect: The function does not have a time complexity of O(n^2).",
    "Incorrect: The function does not have a logarithmic time complexity.",
    "Incorrect: The function has exponential time complexity, not linear.",
    ],
    bloomTaxonomy: "Analyzing",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    "What is the output of the following recursive function in Java?\nvoid printDigits(int n) {\n  if (n < 10) {\n    System.out.print(n);\n    return;\n  }\n  printDigits(n / 10);\n  System.out.print(n % 10);\n}\nprintDigits(123);",
    code: "",
    answers: ["123", "321", "0", "1"],
    correct: 1,
    explanations: [
    "The output of the recursive function printDigits(123) is 123.",
    "The function recursively prints the digits of the number in reverse order.",
    "Incorrect: The function does not print the number in reverse order.",
    "Incorrect: The function does not print the digits in descending order.",
    "Incorrect: The function does not print a single digit, but the entire number.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question: "What is the purpose of memoization in recursive algorithms?",
    code: "",
    answers: [
    "To optimize recursive algorithms by storing previously computed results.",
    "To prevent infinite recursion in recursive algorithms.",
    "To simplify the implementation of recursive algorithms.",
    "To ensure that recursive algorithms always terminate.",
    ],
    correct: 0,
    explanations: [
    "The purpose of memoization in recursive algorithms is to optimize them by storing previously computed results.",
    "Memoization reduces redundant calculations by caching intermediate results.",
    "Incorrect: Memoization does not prevent infinite recursion but optimizes performance.",
    "Incorrect: Memoization may or may not simplify the implementation of recursive algorithms.",
    "Incorrect: Memoization does not guarantee termination but improves efficiency.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    "What is the output of the following recursive function in Java?\nint power(int base, int exponent) {\n  if (exponent == 0) {\n    return 1;\n  }\n  return base * power(base, exponent - 1);\n}\npower(2, 3);",
    code: "",
    answers: ["8", "6", "1", "0"],
    correct: 0,
    explanations: [
    "The output of the recursive function power(2, 3) is 8.",
    "The function calculates the power of a number recursively.",
    "Incorrect: The function does not return 6 when called with arguments (2, 3).",
    "Incorrect: The function does not always return 1.",
    "Incorrect: The function does not return 0 when called with valid arguments.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question: "What is the primary drawback of using recursion?",
    code: "",
    answers: [
    "Potential stack overflow for large recursive depths.",
    "Inefficient memory usage.",
    "Difficulty in understanding and debugging recursive code.",
    "Limited applicability to specific problem domains.",
    ],
    correct: 0,
    explanations: [
    "The primary drawback of using recursion is the potential for stack overflow for large recursive depths.",
    "Each recursive call consumes memory on the call stack, which can lead to stack overflow errors.",
    "Incorrect: Memory usage can be inefficient, but it's not the primary drawback.",
    "Incorrect: Recursive code can be difficult to understand and debug, but it's not the primary drawback.",
    "Incorrect: Recursion can be applicable to a wide range of problem domains.",
    ],
    bloomTaxonomy: "Evaluating",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question:
    "What is the output of the following recursive function in Java?\nint gcd(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\ngcd(12, 18);",
    code: "",
    answers: ["6", "3", "1", "0"],
    correct: 0,
    explanations: [
    "The output of the recursive function gcd(12, 18) is 6.",
    "The function calculates the greatest common divisor (GCD) using Euclid's algorithm recursively.",
    "Incorrect: The GCD of 12 and 18 is not 3.",
    "Incorrect: The GCD of 12 and 18 is not 1.",
    "Incorrect: The GCD of 12 and 18 is not 0.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question: "What is recursion?",
    code: "",
    answers: [
    "A programming technique where a function calls itself directly or indirectly.",
    "A programming technique where a function calls another function.",
    "A programming technique where a function is called by another function only.",
    "A programming technique where a function calls itself repeatedly without termination.",
    ],
    correct: 0,
    explanations: [
    "Recursion is a programming technique where a function calls itself directly or indirectly.",
    "Recursion involves a function invoking itself during its execution.",
    "Incorrect: While recursion can involve a function calling another function, it's not exclusive to that.",
    "Incorrect: Recursion must eventually terminate to prevent infinite looping.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question: "What is the base case in recursion?",
    code: "",
    answers: [
    "The condition that terminates the recursive process.",
    "The condition that starts the recursive process.",
    "The condition that limits the number of recursive calls.",
    "The condition that checks if recursion is possible.",
    ],
    correct: 0,
    explanations: [
    "The base case in recursion is the condition that terminates the recursive process.",
    "The base case defines when the recursion should stop.",
    "Incorrect: The base case does not start the recursive process but ends it.",
    "Incorrect: The base case does not limit the number of recursive calls but defines when to stop them.",
    "Incorrect: The base case does not check if recursion is possible but when it should stop.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    "Which of the following is NOT a characteristic of recursive algorithms?",
    code: "",
    answers: [
    "They require a base case to terminate the recursion.",
    "They can only solve problems with a single solution.",
    "They are less memory efficient compared to iterative algorithms.",
    "They always have a linear time complexity.",
    ],
    correct: 1,
    explanations: [
    "Recursive algorithms can solve problems with multiple solutions.",
    "Incorrect: Recursive algorithms require a base case to terminate the recursion.",
    "Incorrect: The memory efficiency of recursive algorithms depends on the problem and implementation.",
    "Incorrect: Recursive algorithms can have various time complexities depending on the problem.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question: "What does tail recursion optimize?",
    code: "",
    answers: [
    "Memory usage",
    "Execution speed",
    "Algorithmic complexity",
    "Compilation time",
    ],
    correct: 0,
    explanations: [
    "Tail recursion optimizes memory usage.",
    "Tail recursion allows recursive functions to reuse the same stack frame for each recursive call, reducing memory overhead.",
    "Incorrect: Tail recursion may or may not improve execution speed.",
    "Incorrect: Tail recursion may or may not affect the algorithmic complexity.",
    "Incorrect: Tail recursion does not directly impact compilation time.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question:
    "What is the main advantage of using memoization in recursive algorithms?",
    code: "",
    answers: [
    "Reduced computational complexity",
    "Elimination of stack overflow errors",
    "Improved memory efficiency",
    "Optimized runtime performance",
    ],
    correct: 2,
    explanations: [
    "Memoization improves memory efficiency by storing previously computed results.",
    "Memoization reduces redundant calculations by caching intermediate results.",
    "Incorrect: Memoization may or may not affect computational complexity.",
    "Incorrect: Memoization does not necessarily eliminate stack overflow errors.",
    "Incorrect: Memoization may or may not directly optimize runtime performance.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    "What is the output of the following recursive function in Java?\nint sum(int n) {\n  if (n <= 0) {\n    return 0;\n  }\n  return n + sum(n - 1);\n}\nsum(4);",
    code: "",
    answers: ["10", "6", "4", "0"],
    correct: 0,
    explanations: [
    "The output of the recursive function sum(4) is 10.",
    "The function recursively sums up all integers from 4 to 1.",
    "Incorrect: The sum of integers from 1 to 4 is not 6.",
    "Incorrect: The function sums up integers starting from 4.",
    "Incorrect: The function does not return 0 when n is less than or equal to 0, but when n equals 0.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question:
    "Which of the following data structures can be implemented efficiently using recursion?",
    code: "",
    answers: ["Binary tree", "Hash table", "Stack", "Queue"],
    correct: 0,
    explanations: [
    "Binary trees can be efficiently implemented using recursion.",
    "The recursive nature of binary trees lends itself well to recursive algorithms for insertion, deletion, and traversal.",
    "Incorrect: Hash tables are typically implemented using non-recursive techniques.",
    "Incorrect: Stacks and queues can be implemented using arrays or linked lists, but recursion is not typically used for their implementation.",
    ],
    bloomTaxonomy: "Analyzing",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question:
    "What is the output of the following recursive function in Java?\nint factorial(int n) {\n  if (n == 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}\nfactorial(3);",
    code: "",
    answers: ["6", "3", "1", "0"],
    correct: 0,
    explanations: [
    "The output of the recursive function factorial(3) is 6.",
    "The function calculates the factorial of a number recursively.",
    "Incorrect: The factorial of 3 is not 3.",
    "Incorrect: The factorial of 3 is not 1.",
    "Incorrect: The factorial of 3 is not 0.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question: "Which of the following statements about recursion is true?",
    code: "",
    answers: [
    "Recursion can be implemented using iteration.",
    "Recursion always leads to infinite loops.",
    "Recursion cannot be used to solve problems with overlapping subproblems.",
    "Recursion requires more memory compared to iteration.",
    ],
    correct: 0,
    explanations: [
    "Recursion can be implemented using iteration, but not always vice versa.",
    "Recursion does not always lead to infinite loops; it depends on the termination conditions.",
    "Incorrect: Recursion is often used to solve problems with overlapping subproblems, especially with dynamic programming techniques like memoization.",
    "Incorrect: Recursion may use more memory due to the function call stack, but it depends on the problem and implementation.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question: "What is the main disadvantage of using recursion?",
    code: "",
    answers: [
    "Potential stack overflow for large recursive depths.",
    "Increased runtime efficiency.",
    "Simplified code structure.",
    "Better readability.",
    ],
    correct: 0,
    explanations: [
    "The main disadvantage of using recursion is the potential for stack overflow for large recursive depths.",
    "Each recursive call consumes memory on the call stack, which can lead to stack overflow errors.",
    "Incorrect: Recursion may or may not lead to increased runtime efficiency, depending on the problem and implementation.",
    "Incorrect: Recursion may or may not simplify code structure, depending on the problem and implementation.",
    "Incorrect: Recursion may or may not improve readability, depending on the problem and implementation.",
    ],
    bloomTaxonomy: "Evaluating",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    'What is the output of the following recursive function in Java?\nvoid countDown(int n) {\n  if (n == 0) {\n    return;\n  }\n  System.out.print(n + " ");\n  countDown(n - 1);\n}\ncountDown(5);',
    code: "",
    answers: ["5 4 3 2 1", "1 2 3 4 5", "0", "None of the above"],
    correct: 0,
    explanations: [
    "The output of the recursive function countDown(5) is '5 4 3 2 1'.",
    "The function prints the countdown from the given number to 1.",
    "Incorrect: The function does not print '0'.",
    "Incorrect: The function prints the countdown in descending order, not ascending.",
    "Incorrect: The function does not print '0' and follows the countdown from the given number.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question:
    "What is the purpose of the 'recursive case' in recursive algorithms?",
    code: "",
    answers: [
    "To reduce the problem into smaller subproblems.",
    "To handle the base case of the recursion.",
    "To handle errors and exceptions within the recursion.",
    "To terminate the recursion.",
    ],
    correct: 0,
    explanations: [
    "The purpose of the 'recursive case' in recursive algorithms is to reduce the problem into smaller subproblems.",
    "The recursive case defines how the problem is broken down into smaller instances of the same problem.",
    "Incorrect: Handling the base case is the role of the base case itself, not the recursive case.",
    "Incorrect: Handling errors and exceptions within the recursion is unrelated to the recursive case.",
    "Incorrect: The recursive case does not terminate the recursion but defines how it progresses.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(power(2, 3));\n    }\n\n    public static int power(int base, int exponent) {\n        if (exponent == 0)\n            return 1;\n        else\n            return base * power(base, exponent - 1);\n    }\n}",
    answers: ["8", "6", "4", "2"],
    correct: 0,
    explanations: [
    "The function call power(2, 3) results in 2 * 2 * 2 = 8.",
    "The base case is correctly defined to handle the termination of recursion.",
    "The function correctly computes the power of a number using recursion.",
    "Each recursive call reduces the exponent by 1 until it reaches 0.",
    ],
    bloomTaxonomy: "Analyzing",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question: "What is the purpose of a base case in a recursive function?",
    answers: [
    "To provide a termination condition for the recursion.",
    "To increase the efficiency of the function.",
    "To allow the function to handle larger inputs.",
    "To reduce the memory usage of the function.",
    ],
    correct: 0,
    explanations: [
    "The base case provides a termination condition for the recursion, ensuring that the function stops calling itself recursively.",
    "Without a base case, the recursion would continue indefinitely, leading to a stack overflow error.",
    "The base case ensures that the function stops calling itself when a specific condition is met, preventing infinite recursion.",
    "The base case defines the smallest problem instance that does not require further recursion, helping in reducing unnecessary function calls.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    "Which of the following is true about recursive functions in Java?",
    answers: [
    "A recursive function can call itself directly or indirectly.",
    "A recursive function cannot have a base case.",
    "A recursive function must always return void.",
    "A recursive function cannot have parameters.",
    ],
    correct: 0,
    explanations: [
    "A recursive function in Java can call itself directly or indirectly to solve a problem.",
    "The base case is essential to prevent infinite recursion and ensure the function terminates correctly.",
    "The return type of a recursive function can vary depending on the problem it solves.",
    "Recursive functions often take parameters to manipulate and process data during each recursive call.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(fibonacci(6));\n    }\n\n    public static int fibonacci(int n) {\n        if (n <= 1)\n            return n;\n        else\n            return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
    answers: ["8", "13", "21", "34"],
    correct: 1,
    explanations: [
    "The function call fibonacci(6) returns the 6th Fibonacci number, which is 8.",
    "The Fibonacci sequence starts from 0, 1, 1, 2, 3, 5, 8, ...",
    "The function correctly computes the Fibonacci sequence using recursion.",
    "Each recursive call computes the sum of the two preceding numbers in the sequence.",
    ],
    bloomTaxonomy: "Analyzing",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    "Which of the following recursive functions correctly calculates the factorial of a number in Java?",
    answers: [
    "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    "public int factorial(int n) {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    "public int factorial(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return factorial(n - 1);\n}",
    "public int factorial(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    ],
    correct: 0,
    explanations: [
    "This function correctly calculates the factorial of a number using recursion.",
    "The base case is correctly defined to handle the termination of recursion.",
    "The function correctly multiplies each number by its previous factorial value.",
    "Each recursive call reduces the value of n until it reaches the base case.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 4,
    question:
    "What is the primary advantage of using recursion over iteration in certain problems?",
    answers: [
    "Simplicity and clarity of code.",
    "Better performance and efficiency.",
    "Lower memory consumption.",
    "Ability to handle larger inputs.",
    ],
    correct: 0,
    explanations: [
    "Recursion often leads to simpler and clearer code for certain problems, making it easier to understand and maintain.",
    "The performance difference between recursion and iteration depends on the specific problem and language implementation.",
    "Recursion typically consumes more memory due to the function call stack.",
    "Recursion may lead to stack overflow errors with large inputs.",
    ],
    bloomTaxonomy: "Evaluating",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question: "What is the output of the following Java code?",
    code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(reverse("hello"));\n    }\n\n    public static String reverse(String str) {\n        if (str.isEmpty())\n            return str;\n        else\n            return reverse(str.substring(1)) + str.charAt(0);\n    }\n}',
    answers: ["olleh", "hello", "eh", "olle"],
    correct: 0,
    explanations: [
    'The function call reverse("hello") returns the reversed string "olleh".',
    "The function recursively reverses the string by appending the last character to the reversed substring.",
    "Each recursive call reduces the length of the string until it becomes empty.",
    "The final result is obtained by concatenating characters in reverse order.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 3,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(sumDigits(123));\n    }\n\n    public static int sumDigits(int n) {\n        if (n == 0)\n            return 0;\n        else\n            return n % 10 + sumDigits(n / 10);\n    }\n}",
    answers: ["6", "5", "3", "1"],
    correct: 0,
    explanations: [
    "The function call sumDigits(123) returns the sum of digits 1 + 2 + 3 = 6.",
    "The function recursively sums the last digit and calls itself with the remaining digits.",
    "Each recursive call isolates and sums the last digit until the number becomes zero.",
    "The sum is accumulated during each recursive call.",
    ],
    bloomTaxonomy: "Applying",
    topic: "Recursion",
    },
    {
    difficulty: 2,
    question:
    "Which of the following statements about recursion in Java is true?",
    answers: [
    "Recursion can lead to better code readability for certain problems.",
    "Recursion is always faster than iteration.",
    "Recursion cannot handle complex problems.",
    "Recursion is not supported in Java.",
    ],
    correct: 0,
    explanations: [
    "Recursion can lead to better code readability for certain problems by expressing solutions in a natural and concise way.",
    "The performance comparison between recursion and iteration depends on the problem and language implementation.",
    "Recursion can handle a wide range of problems, including complex ones, by breaking them down into smaller subproblems.",
    "Recursion is a fundamental concept supported by Java and many other programming languages.",
    ],
    bloomTaxonomy: "Understanding",
    topic: "Recursion",
    },
    {
        difficulty: 4,
        question: "What is the output of the following Java code?",
        code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(isPalindrome("racecar"));\n    }\n\n    public static boolean isPalindrome(String str) {\n        if (str.length() <= 1)\n            return true;\n        else if (str.charAt(0) != str.charAt(str.length() - 1))\n            return false;\n        else\n            return isPalindrome(str.substring(1, str.length() - 1));\n    }\n}',
        answers: ["true", "false", "racecar", "car"],
        correct: 0,
        explanations: [
        'The function call isPalindrome("racecar") returns true, indicating that the string is a palindrome.',
        "The function recursively checks if the first and last characters of the string match.",
        "Each recursive call compares the characters at opposite ends of the string until the middle is reached.",
        "The function correctly identifies palindromes by comparing characters symmetrically.",
        ],
        bloomTaxonomy: "Analyzing",
        topic: "Recursion",
        },
        {
        difficulty: 2,
        question: "What is the output of the following Java code?",
        code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(countDigits(12345));\n    }\n\n    public static int countDigits(int n) {\n        if (n == 0)\n            return 0;\n        else\n            return 1 + countDigits(n / 10);\n    }\n}",
        answers: ["5", "4", "3", "2"],
        correct: 0,
        explanations: [
        "The function call countDigits(12345) returns the number of digits in the integer, which is 5.",
        "The function recursively divides the number by 10 and increments the count until the number becomes zero.",
        "Each recursive call reduces the length of the number until it becomes zero.",
        "The count is incremented for each digit encountered during recursion.",
        ],
        bloomTaxonomy: "Applying",
        topic: "Recursion",
        },
        {
        difficulty: 1,
        question: "What is the primary advantage of using recursion?",
        answers: [
        "Simplicity and clarity of code.",
        "Better performance and efficiency.",
        "Lower memory consumption.",
        "Ability to handle larger inputs.",
        ],
        correct: 0,
        explanations: [
        "Recursion often leads to simpler and clearer code for certain problems, making it easier to understand and maintain.",
        "The performance comparison between recursion and iteration depends on the problem and language implementation.",
        "Recursion typically consumes more memory due to the function call stack.",
        "Recursion may lead to stack overflow errors with large inputs.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 1,
        question:
        "Which of the following statements about recursion in Java is true?",
        answers: [
        "Recursion can lead to better code readability for certain problems.",
        "Recursion is always faster than iteration.",
        "Recursion cannot handle complex problems.",
        "Recursion is not supported in Java.",
        ],
        correct: 0,
        explanations: [
        "Recursion can lead to better code readability for certain problems by expressing solutions in a natural and concise way.",
        "The performance comparison between recursion and iteration depends on the problem and language implementation.",
        "Recursion can handle a wide range of problems, including complex ones, by breaking them down into smaller subproblems.",
        "Recursion is a fundamental concept supported by Java and many other programming languages.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 3,
        question: "What will be the output of the following Java code?",
        code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(factorial(5));\n    }\n\n    public static int factorial(int n) {\n        if (n <= 1)\n            return 1;\n        else\n            return n * factorial(n - 1);\n    }\n}",
        answers: ["120", "125", "25", "100"],
        correct: 0,
        explanations: [
        "The function call factorial(5) returns the factorial of 5, which is 120.",
        "The function recursively computes the factorial of the given number.",
        "Each recursive call multiplies the current number with the factorial of the previous number.",
        "The factorial of 5 is calculated as 5 * 4 * 3 * 2 * 1 = 120.",
        ],
        bloomTaxonomy: "Applying",
        topic: "Recursion",
        },
        {
        difficulty: 4,
        question:
        "Which of the following recursive functions correctly calculates the Fibonacci sequence?",
        answers: [
        "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
        "public int fibonacci(int n) {\n    if (n <= 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
        "public int fibonacci(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
        "public int fibonacci(int n) {\n    if (n <= 1)\n        return 0;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
        ],
        correct: 0,
        explanations: [
        "This function correctly calculates the Fibonacci sequence using recursion.",
        "The base cases are correctly defined to handle the first two Fibonacci numbers.",
        "Each recursive call computes the sum of the two preceding Fibonacci numbers.",
        "The function accurately generates the Fibonacci sequence.",
        ],
        bloomTaxonomy: "Applying",
        topic: "Recursion",
        },
        {
        difficulty: 2,
        question: "What is the base case of recursion?",
        answers: [
        "The condition that terminates the recursive process.",
        "The initial state of the recursive function.",
        "The final output of the recursive function.",
        "The condition that triggers the recursive call.",
        ],
        correct: 0,
        explanations: [
        "The base case is the condition that stops the recursive process from continuing indefinitely.",
        "The base case defines the termination condition for the recursion.",
        "The final output may be derived from the base case, but it is not the base case itself.",
        "The recursive call is triggered by the recursive step, not the base case.",
        ],
        bloomTaxonomy: "Remembering",
        topic: "Recursion",
        },
        {
        difficulty: 3,
        question: "What is the maximum depth of recursion in Java?",
        answers: [
        "It depends on the runtime environment and stack size settings.",
        "It is fixed and determined by the JVM.",
        "It is limited to 1000 recursive calls.",
        "It is unlimited.",
        ],
        correct: 0,
        explanations: [
        "The maximum depth of recursion depends on factors such as the runtime environment and stack size settings.",
        "The JVM imposes no fixed limit on the depth of recursion.",
        "The limit of 1000 recursive calls is not a standard restriction and may vary across environments.",
        "Recursion can continue until the available stack space is exhausted.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 4,
        question: "What is tail recursion?",
        answers: [
        "A type of recursion where the recursive call is the last operation in the function.",
        "A recursive function that operates on the tail of a list.",
        "Recursion involving only the base case.",
        "A recursive function that returns a boolean value.",
        ],
        correct: 0,
        explanations: [
        "Tail recursion occurs when the recursive call is the final operation executed by the function before returning its value.",
        "Tail recursion is not specific to lists but to the position of the recursive call within the function.",
        "Tail recursion still involves multiple recursive calls; it's not limited to the base case.",
        "Tail recursion refers to the position of the recursive call, not the return type of the function.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 2,
        question: "Which data structure is commonly used to implement recursion?",
        answers: ["Stack", "Queue", "Array", "Linked List"],
        correct: 0,
        explanations: [
        "Recursion is often implemented using a stack data structure, where each recursive call is pushed onto the stack.",
        "A queue is not typically used for recursion; it's more commonly used for breadth-first search.",
        "While arrays and linked lists can be used for recursion, stacks are more commonly used due to their Last-In-First-Out (LIFO) nature.",
        "Linked lists can be used for recursive algorithms, but stacks are more commonly associated with recursion.",
        ],
        bloomTaxonomy: "Remembering",
        topic: "Recursion",
        },
        {
        difficulty: 3,
        question: "What is memoization in recursion?",
        answers: [
        "Caching the results of expensive function calls to avoid redundant computations.",
        "Passing additional parameters to recursive functions.",
        "Limiting the depth of recursion to prevent stack overflow.",
        "Using loops instead of recursion.",
        ],
        correct: 0,
        explanations: [
        "Memoization involves caching the results of expensive function calls so that they can be reused when the same inputs occur again, thereby avoiding redundant computations.",
        "Passing additional parameters is a technique used for tail recursion optimization.",
        "Limiting recursion depth is a way to prevent stack overflow but is not memoization.",
        "Loops are an alternative to recursion and not related to memoization.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 2,
        question:
        "Which of the following is NOT a phase in solving problems recursively?",
        answers: ["Iteration", "Divide", "Conquer", "Combine"],
        correct: 0,
        explanations: [
        "Iteration is not typically a phase in solving problems recursively; recursion involves function calls rather than loops.",
        "Divide involves breaking down the problem into smaller subproblems.",
        "Conquer involves solving the smaller subproblems.",
        "Combine involves combining the solutions of the subproblems to form the solution to the original problem.",
        ],
        bloomTaxonomy: "Remembering",
        topic: "Recursion",
        },
        {
        difficulty: 4,
        question:
        "What is the time complexity of the Fibonacci sequence calculation using naive recursion?",
        answers: ["Exponential", "Linear", "Quadratic", "Logarithmic"],
        correct: 0,
        explanations: [
        "The time complexity of the Fibonacci sequence calculation using naive recursion is exponential, O(2^n), due to redundant computations.",
        "Linear time complexity would imply a more efficient algorithm than naive recursion for Fibonacci sequence calculation.",
        "Quadratic time complexity would imply a less efficient algorithm than naive recursion for Fibonacci sequence calculation.",
        "Logarithmic time complexity would imply an even more efficient algorithm than linear time complexity for Fibonacci sequence calculation.",
        ],
        bloomTaxonomy: "Analyzing",
        topic: "Recursion",
        },
        {
        difficulty: 4,
        question:
        "What is the purpose of the visited array in depth-first search (DFS) using recursion?",
        answers: [
        "To keep track of visited nodes to avoid revisiting them.",
        "To store the distances between nodes in a graph.",
        "To maintain the order of nodes visited.",
        "To store the adjacency matrix of the graph.",
        ],
        correct: 0,
        explanations: [
        "The visited array is used to keep track of visited nodes to avoid revisiting them and prevent infinite recursion.",
        "Storing distances between nodes is typically done in algorithms like Dijkstra's or Bellman-Ford.",
        "Maintaining the order of visited nodes is not the primary purpose of the visited array.",
        "The adjacency matrix is a different data structure used to represent connections between nodes in a graph.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 2,
        question: "Which of the following statements about tail recursion is true?",
        answers: [
        "Tail recursion can be optimized by compilers into iterative loops.",
        "Tail recursion always requires more memory than non-tail recursion.",
        "Tail recursion is always more efficient than non-tail recursion.",
        "Tail recursion cannot be implemented in Java.",
        ],
        correct: 0,
        explanations: [
        "Some compilers can optimize tail-recursive functions into iterative loops, eliminating the need for additional stack frames.",
        "Tail recursion typically requires less memory than non-tail recursion because it doesn't need to keep track of multiple stack frames.",
        "Tail recursion is not always more efficient than non-tail recursion; it depends on various factors such as compiler optimizations and the nature of the problem.",
        "Tail recursion is a valid concept in Java and many other programming languages.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 3,
        question: "What is the primary disadvantage of recursion?",
        answers: [
        "Increased memory usage due to function call stack.",
        "Limited applicability to certain problem domains.",
        "Slower execution compared to iterative solutions.",
        "Difficulty in understanding and debugging.",
        ],
        correct: 0,
        explanations: [
        "Recursion can lead to increased memory usage due to the need to store each function call on the call stack.",
        "Recursion is applicable to a wide range of problems, but some problems may be better suited to iterative solutions.",
        "Recursion may not always be slower than iterative solutions, but it depends on factors like language implementation and problem complexity.",
        "Recursion can sometimes be harder to understand and debug compared to iterative solutions, especially for beginners.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
        {
        difficulty: 3,
        question:
        "What is the significance of the base case in recursive algorithms?",
        answers: [
        "It defines when the recursion should stop.",
        "It provides the starting point for the recursion.",
        "It determines the number of recursive calls.",
        "It handles the intermediate steps of the recursion.",
        ],
        correct: 0,
        explanations: [
        "The base case defines the termination condition for the recursion, preventing it from continuing indefinitely.",
        "The base case is essential for determining when to stop the recursion, but it is not the starting point.",
        "The base case is not responsible for determining the number of recursive calls; that's typically handled by the recursive step.",
        "The intermediate steps of the recursion are handled by the recursive calls and are not related to the base case.",
        ],
        bloomTaxonomy: "Understanding",
        topic: "Recursion",
        },
    ];