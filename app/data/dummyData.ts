export const dummyData: {
  difficulty: number;
  question: string;
  code?: string;
  answers: string[];
  correct: number;
  explanations: string[];
  bloomTaxonomy: string;
  timeTakenSeconds: number;
  topic: string;
}[] = [
  {
    difficulty: 0.3,
    question: "What is recursion?",
    code: "",
    answers: [
      "A programming technique where a function calls itself directly or indirectly.",
      "A programming technique where a function calls another function.",
      "A programming technique where a function is called by another function only.",
      "A programming technique where a function calls itself repeatedly without termination.",
    ],
    correct: 0,
    explanations: [
      "Recursion is a programming technique where a function calls itself directly or indirectly.",
      "Incorrect: Recursion involves a function calling itself, not necessarily another function.",
      "Incorrect: Recursion can involve a function calling itself, not necessarily by another function only.",
      "Incorrect: Recursion must eventually terminate to prevent infinite looping.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question: "What is the base case in recursion?",
    code: "",
    answers: [
      "The condition that terminates the recursive process.",
      "The condition that starts the recursive process.",
      "The condition that limits the number of recursive calls.",
      "The condition that checks if recursion is possible.",
    ],
    correct: 0,
    explanations: [
      "The base case in recursion is the condition that terminates the recursive process.",
      "The base case defines when the recursion should stop.",
      "Incorrect: The base case does not start the recursive process but ends it.",
      "Incorrect: The base case does not limit the number of recursive calls but defines when to stop them.",
      "Incorrect: The base case does not check if recursion is possible but when it should stop.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the factorial of 0?",
    code: "",
    answers: ["1", "0", "Infinity", "Error"],
    correct: 0,
    explanations: [
      "The factorial of 0 is 1.",
      "By definition, the factorial of 0 is 1.",
      "Incorrect: The factorial of 0 is not 0.",
      "Incorrect: The factorial of 0 is not infinity.",
      "Incorrect: There is no error in calculating the factorial of 0.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "Which of the following is a characteristic of recursive algorithms?",
    code: "",
    answers: [
      "They require a base case to terminate the recursion.",
      "They can only solve problems with a single solution.",
      "They are less memory efficient compared to iterative algorithms.",
      "They always have a linear time complexity.",
    ],
    correct: 0,
    explanations: [
      "A characteristic of recursive algorithms is that they require a base case to terminate the recursion.",
      "The base case defines when the recursion should stop.",
      "Incorrect: Recursive algorithms can solve problems with multiple solutions.",
      "Incorrect: The efficiency of recursive algorithms depends on the problem and implementation.",
      "Incorrect: The time complexity of recursive algorithms can vary depending on the problem.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question: "What is tail recursion?",
    code: "",
    answers: [
      "A recursive function where the recursive call is the last operation in the function.",
      "A recursive function where the base case is omitted.",
      "A recursive function where the recursive call is made before any other operations in the function.",
      "A recursive function where the base case is never reached.",
    ],
    correct: 0,
    explanations: [
      "Tail recursion is a recursive function where the recursive call is the last operation in the function.",
      "In tail recursion, no computation is done after the recursive call.",
      "Incorrect: Tail recursion still has a base case, it's the position of the recursive call that matters.",
      "Incorrect: Tail recursion does not necessarily omit the base case.",
      "Incorrect: Tail recursion still reaches the base case, it's just positioned differently.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "What is the output of the following recursive function in Java?\nint sum(int n) {\n  if (n <= 0) {\n    return 0;\n  }\n  return n + sum(n - 1);\n}\nsum(4);",
    code: "",
    answers: ["10", "6", "4", "0"],
    correct: 0,
    explanations: [
      "The output of the recursive function sum(4) is 10.",
      "The function recursively sums up all integers from 4 to 1.",
      "Incorrect: The sum of integers from 1 to 4 is not 6.",
      "Incorrect: The function sums up integers starting from 4.",
      "Incorrect: The function does not return 0 when n is less than or equal to 0, but when n equals 0.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Which of the following data structures can be implemented using recursion?",
    code: "",
    answers: ["Trees", "Stacks", "Queues", "Arrays"],
    correct: 0,
    explanations: [
      "Trees can be implemented using recursion.",
      "Recursion is commonly used to traverse and manipulate tree structures.",
      "Incorrect: Stacks and queues are typically implemented using iterative approaches.",
      "Incorrect: Arrays are not typically implemented using recursion due to their linear structure.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      "What is the time complexity of the following recursive function in terms of Big O notation?\nint fibonacci(int n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n",
    code: "",
    answers: ["O(2^n)", "O(n^2)", "O(log n)", "O(n)"],
    correct: 0,
    explanations: [
      "The time complexity of the Fibonacci recursive function is O(2^n).",
      "The function makes two recursive calls at each step, leading to exponential time complexity.",
      "Incorrect: The function does not have a time complexity of O(n^2).",
      "Incorrect: The function does not have a logarithmic time complexity.",
      "Incorrect: The function has exponential time complexity, not linear.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "What is the output of the following recursive function in Java?\nvoid printDigits(int n) {\n  if (n < 10) {\n    System.out.print(n);\n    return;\n  }\n  printDigits(n / 10);\n  System.out.print(n % 10);\n}\nprintDigits(123);",
    code: "",
    answers: ["123", "321", "0", "1"],
    correct: 1,
    explanations: [
      "The output of the recursive function printDigits(123) is 123.",
      "The function recursively prints the digits of the number in reverse order.",
      "Incorrect: The function does not print the number in reverse order.",
      "Incorrect: The function does not print the digits in descending order.",
      "Incorrect: The function does not print a single digit, but the entire number.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question: "What is the purpose of memoization in recursive algorithms?",
    code: "",
    answers: [
      "To optimize recursive algorithms by storing previously computed results.",
      "To prevent infinite recursion in recursive algorithms.",
      "To simplify the implementation of recursive algorithms.",
      "To ensure that recursive algorithms always terminate.",
    ],
    correct: 0,
    explanations: [
      "The purpose of memoization in recursive algorithms is to optimize them by storing previously computed results.",
      "Memoization reduces redundant calculations by caching intermediate results.",
      "Incorrect: Memoization does not prevent infinite recursion but optimizes performance.",
      "Incorrect: Memoization may or may not simplify the implementation of recursive algorithms.",
      "Incorrect: Memoization does not guarantee termination but improves efficiency.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "What is the output of the following recursive function in Java?\nint power(int base, int exponent) {\n  if (exponent == 0) {\n    return 1;\n  }\n  return base * power(base, exponent - 1);\n}\npower(2, 3);",
    code: "",
    answers: ["8", "6", "1", "0"],
    correct: 0,
    explanations: [
      "The output of the recursive function power(2, 3) is 8.",
      "The function calculates the power of a number recursively.",
      "Incorrect: The function does not return 6 when called with arguments (2, 3).",
      "Incorrect: The function does not always return 1.",
      "Incorrect: The function does not return 0 when called with valid arguments.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question: "What is the primary drawback of using recursion?",
    code: "",
    answers: [
      "Potential stack overflow for large recursive depths.",
      "Inefficient memory usage.",
      "Difficulty in understanding and debugging recursive code.",
      "Limited applicability to specific problem domains.",
    ],
    correct: 0,
    explanations: [
      "The primary drawback of using recursion is the potential for stack overflow for large recursive depths.",
      "Each recursive call consumes memory on the call stack, which can lead to stack overflow errors.",
      "Incorrect: Memory usage can be inefficient, but it's not the primary drawback.",
      "Incorrect: Recursive code can be difficult to understand and debug, but it's not the primary drawback.",
      "Incorrect: Recursion can be applicable to a wide range of problem domains.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "What is the output of the following recursive function in Java?\nint gcd(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\ngcd(12, 18);",
    code: "",
    answers: ["6", "3", "1", "0"],
    correct: 0,
    explanations: [
      "The output of the recursive function gcd(12, 18) is 6.",
      "The function calculates the greatest common divisor (GCD) using Euclid's algorithm recursively.",
      "Incorrect: The GCD of 12 and 18 is not 3.",
      "Incorrect: The GCD of 12 and 18 is not 1.",
      "Incorrect: The GCD of 12 and 18 is not 0.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "What is recursion?",
    code: "",
    answers: [
      "A programming technique where a function calls itself directly or indirectly.",
      "A programming technique where a function calls another function.",
      "A programming technique where a function is called by another function only.",
      "A programming technique where a function calls itself repeatedly without termination.",
    ],
    correct: 0,
    explanations: [
      "Recursion is a programming technique where a function calls itself directly or indirectly.",
      "Recursion involves a function invoking itself during its execution.",
      "Incorrect: While recursion can involve a function calling another function, it's not exclusive to that.",
      "Incorrect: Recursion must eventually terminate to prevent infinite looping.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question: "What is the base case in recursion?",
    code: "",
    answers: [
      "The condition that terminates the recursive process.",
      "The condition that starts the recursive process.",
      "The condition that limits the number of recursive calls.",
      "The condition that checks if recursion is possible.",
    ],
    correct: 0,
    explanations: [
      "The base case in recursion is the condition that terminates the recursive process.",
      "The base case defines when the recursion should stop.",
      "Incorrect: The base case does not start the recursive process but ends it.",
      "Incorrect: The base case does not limit the number of recursive calls but defines when to stop them.",
      "Incorrect: The base case does not check if recursion is possible but when it should stop.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following is NOT a characteristic of recursive algorithms?",
    code: "",
    answers: [
      "They require a base case to terminate the recursion.",
      "They can only solve problems with a single solution.",
      "They are less memory efficient compared to iterative algorithms.",
      "They always have a linear time complexity.",
    ],
    correct: 1,
    explanations: [
      "Recursive algorithms can solve problems with multiple solutions.",
      "Incorrect: Recursive algorithms require a base case to terminate the recursion.",
      "Incorrect: The memory efficiency of recursive algorithms depends on the problem and implementation.",
      "Incorrect: Recursive algorithms can have various time complexities depending on the problem.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question: "What does tail recursion optimize?",
    code: "",
    answers: [
      "Memory usage",
      "Execution speed",
      "Algorithmic complexity",
      "Compilation time",
    ],
    correct: 0,
    explanations: [
      "Tail recursion optimizes memory usage.",
      "Tail recursion allows recursive functions to reuse the same stack frame for each recursive call, reducing memory overhead.",
      "Incorrect: Tail recursion may or may not improve execution speed.",
      "Incorrect: Tail recursion may or may not affect the algorithmic complexity.",
      "Incorrect: Tail recursion does not directly impact compilation time.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question:
      "What is the main advantage of using memoization in recursive algorithms?",
    code: "",
    answers: [
      "Reduced computational complexity",
      "Elimination of stack overflow errors",
      "Improved memory efficiency",
      "Optimized runtime performance",
    ],
    correct: 2,
    explanations: [
      "Memoization improves memory efficiency by storing previously computed results.",
      "Memoization reduces redundant calculations by caching intermediate results.",
      "Incorrect: Memoization may or may not affect computational complexity.",
      "Incorrect: Memoization does not necessarily eliminate stack overflow errors.",
      "Incorrect: Memoization may or may not directly optimize runtime performance.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "What is the output of the following recursive function in Java?\nint sum(int n) {\n  if (n <= 0) {\n    return 0;\n  }\n  return n + sum(n - 1);\n}\nsum(4);",
    code: "",
    answers: ["10", "6", "4", "0"],
    correct: 0,
    explanations: [
      "The output of the recursive function sum(4) is 10.",
      "The function recursively sums up all integers from 4 to 1.",
      "Incorrect: The sum of integers from 1 to 4 is not 6.",
      "Incorrect: The function sums up integers starting from 4.",
      "Incorrect: The function does not return 0 when n is less than or equal to 0, but when n equals 0.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Which of the following data structures can be implemented efficiently using recursion?",
    code: "",
    answers: ["Binary tree", "Hash table", "Stack", "Queue"],
    correct: 0,
    explanations: [
      "Binary trees can be efficiently implemented using recursion.",
      "The recursive nature of binary trees lends itself well to recursive algorithms for insertion, deletion, and traversal.",
      "Incorrect: Hash tables are typically implemented using non-recursive techniques.",
      "Incorrect: Stacks and queues can be implemented using arrays or linked lists, but recursion is not typically used for their implementation.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      "What is the output of the following recursive function in Java?\nint factorial(int n) {\n  if (n == 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}\nfactorial(3);",
    code: "",
    answers: ["6", "3", "1", "0"],
    correct: 0,
    explanations: [
      "The output of the recursive function factorial(3) is 6.",
      "The function calculates the factorial of a number recursively.",
      "Incorrect: The factorial of 3 is not 3.",
      "Incorrect: The factorial of 3 is not 1.",
      "Incorrect: The factorial of 3 is not 0.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "Which of the following statements about recursion is true?",
    code: "",
    answers: [
      "Recursion can be implemented using iteration.",
      "Recursion always leads to infinite loops.",
      "Recursion cannot be used to solve problems with overlapping subproblems.",
      "Recursion requires more memory compared to iteration.",
    ],
    correct: 0,
    explanations: [
      "Recursion can be implemented using iteration, but not always vice versa.",
      "Recursion does not always lead to infinite loops; it depends on the termination conditions.",
      "Incorrect: Recursion is often used to solve problems with overlapping subproblems, especially with dynamic programming techniques like memoization.",
      "Incorrect: Recursion may use more memory due to the function call stack, but it depends on the problem and implementation.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question: "What is the main disadvantage of using recursion?",
    code: "",
    answers: [
      "Potential stack overflow for large recursive depths.",
      "Increased runtime efficiency.",
      "Simplified code structure.",
      "Better readability.",
    ],
    correct: 0,
    explanations: [
      "The main disadvantage of using recursion is the potential for stack overflow for large recursive depths.",
      "Each recursive call consumes memory on the call stack, which can lead to stack overflow errors.",
      "Incorrect: Recursion may or may not lead to increased runtime efficiency, depending on the problem and implementation.",
      "Incorrect: Recursion may or may not simplify code structure, depending on the problem and implementation.",
      "Incorrect: Recursion may or may not improve readability, depending on the problem and implementation.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      'What is the output of the following recursive function in Java?\nvoid countDown(int n) {\n  if (n == 0) {\n    return;\n  }\n  System.out.print(n + " ");\n  countDown(n - 1);\n}\ncountDown(5);',
    code: "",
    answers: ["5 4 3 2 1", "1 2 3 4 5", "0", "None of the above"],
    correct: 0,
    explanations: [
      "The output of the recursive function countDown(5) is '5 4 3 2 1'.",
      "The function prints the countdown from the given number to 1.",
      "Incorrect: The function does not print '0'.",
      "Incorrect: The function prints the countdown in descending order, not ascending.",
      "Incorrect: The function does not print '0' and follows the countdown from the given number.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "What is the purpose of the 'recursive case' in recursive algorithms?",
    code: "",
    answers: [
      "To reduce the problem into smaller subproblems.",
      "To handle the base case of the recursion.",
      "To handle errors and exceptions within the recursion.",
      "To terminate the recursion.",
    ],
    correct: 0,
    explanations: [
      "The purpose of the 'recursive case' in recursive algorithms is to reduce the problem into smaller subproblems.",
      "The recursive case defines how the problem is broken down into smaller instances of the same problem.",
      "Incorrect: Handling the base case is the role of the base case itself, not the recursive case.",
      "Incorrect: Handling errors and exceptions within the recursion is unrelated to the recursive case.",
      "Incorrect: The recursive case does not terminate the recursion but defines how it progresses.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(power(2, 3));\n    }\n\n    public static int power(int base, int exponent) {\n        if (exponent == 0)\n            return 1;\n        else\n            return base * power(base, exponent - 1);\n    }\n}",
    answers: ["8", "6", "4", "2"],
    correct: 0,
    explanations: [
      "The function call power(2, 3) results in 2 * 2 * 2 = 8.",
      "The base case is correctly defined to handle the termination of recursion.",
      "The function correctly computes the power of a number using recursion.",
      "Each recursive call reduces the exponent by 1 until it reaches 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "What is the purpose of a base case in a recursive function?",
    answers: [
      "To provide a termination condition for the recursion.",
      "To increase the efficiency of the function.",
      "To allow the function to handle larger inputs.",
      "To reduce the memory usage of the function.",
    ],
    correct: 0,
    explanations: [
      "The base case provides a termination condition for the recursion, ensuring that the function stops calling itself recursively.",
      "Without a base case, the recursion would continue indefinitely, leading to a stack overflow error.",
      "The base case ensures that the function stops calling itself when a specific condition is met, preventing infinite recursion.",
      "The base case defines the smallest problem instance that does not require further recursion, helping in reducing unnecessary function calls.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following is true about recursive functions in Java?",
    answers: [
      "A recursive function can call itself directly or indirectly.",
      "A recursive function cannot have a base case.",
      "A recursive function must always return void.",
      "A recursive function cannot have parameters.",
    ],
    correct: 0,
    explanations: [
      "A recursive function in Java can call itself directly or indirectly to solve a problem.",
      "The base case is essential to prevent infinite recursion and ensure the function terminates correctly.",
      "The return type of a recursive function can vary depending on the problem it solves.",
      "Recursive functions often take parameters to manipulate and process data during each recursive call.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(fibonacci(6));\n    }\n\n    public static int fibonacci(int n) {\n        if (n <= 1)\n            return n;\n        else\n            return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
    answers: ["8", "13", "21", "34"],
    correct: 1,
    explanations: [
      "The function call fibonacci(6) returns the 6th Fibonacci number, which is 8.",
      "The Fibonacci sequence starts from 0, 1, 1, 2, 3, 5, 8, ...",
      "The function correctly computes the Fibonacci sequence using recursion.",
      "Each recursive call computes the sum of the two preceding numbers in the sequence.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following recursive functions correctly calculates the factorial of a number in Java?",
    answers: [
      "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
      "public int factorial(int n) {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
      "public int factorial(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return factorial(n - 1);\n}",
      "public int factorial(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    ],
    correct: 0,
    explanations: [
      "This function correctly calculates the factorial of a number using recursion.",
      "The base case is correctly defined to handle the termination of recursion.",
      "The function correctly multiplies each number by its previous factorial value.",
      "Each recursive call reduces the value of n until it reaches the base case.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      "What is the primary advantage of using recursion over iteration in certain problems?",
    answers: [
      "Simplicity and clarity of code.",
      "Better performance and efficiency.",
      "Lower memory consumption.",
      "Ability to handle larger inputs.",
    ],
    correct: 0,
    explanations: [
      "Recursion often leads to simpler and clearer code for certain problems, making it easier to understand and maintain.",
      "The performance difference between recursion and iteration depends on the specific problem and language implementation.",
      "Recursion typically consumes more memory due to the function call stack.",
      "Recursion may lead to stack overflow errors with large inputs.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question: "What is the output of the following Java code?",
    code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(reverse("hello"));\n    }\n\n    public static String reverse(String str) {\n        if (str.isEmpty())\n            return str;\n        else\n            return reverse(str.substring(1)) + str.charAt(0);\n    }\n}',
    answers: ["olleh", "hello", "eh", "olle"],
    correct: 0,
    explanations: [
      'The function call reverse("hello") returns the reversed string "olleh".',
      "The function recursively reverses the string by appending the last character to the reversed substring.",
      "Each recursive call reduces the length of the string until it becomes empty.",
      "The final result is obtained by concatenating characters in reverse order.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(sumDigits(123));\n    }\n\n    public static int sumDigits(int n) {\n        if (n == 0)\n            return 0;\n        else\n            return n % 10 + sumDigits(n / 10);\n    }\n}",
    answers: ["6", "5", "3", "1"],
    correct: 0,
    explanations: [
      "The function call sumDigits(123) returns the sum of digits 1 + 2 + 3 = 6.",
      "The function recursively sums the last digit and calls itself with the remaining digits.",
      "Each recursive call isolates and sums the last digit until the number becomes zero.",
      "The sum is accumulated during each recursive call.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following statements about recursion in Java is true?",
    answers: [
      "Recursion can lead to better code readability for certain problems.",
      "Recursion is always faster than iteration.",
      "Recursion cannot handle complex problems.",
      "Recursion is not supported in Java.",
    ],
    correct: 0,
    explanations: [
      "Recursion can lead to better code readability for certain problems by expressing solutions in a natural and concise way.",
      "The performance comparison between recursion and iteration depends on the problem and language implementation.",
      "Recursion can handle a wide range of problems, including complex ones, by breaking them down into smaller subproblems.",
      "Recursion is a fundamental concept supported by Java and many other programming languages.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question: "What is the output of the following Java code?",
    code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(isPalindrome("racecar"));\n    }\n\n    public static boolean isPalindrome(String str) {\n        if (str.length() <= 1)\n            return true;\n        else if (str.charAt(0) != str.charAt(str.length() - 1))\n            return false;\n        else\n            return isPalindrome(str.substring(1, str.length() - 1));\n    }\n}',
    answers: ["true", "false", "racecar", "car"],
    correct: 0,
    explanations: [
      'The function call isPalindrome("racecar") returns true, indicating that the string is a palindrome.',
      "The function recursively checks if the first and last characters of the string match.",
      "Each recursive call compares the characters at opposite ends of the string until the middle is reached.",
      "The function correctly identifies palindromes by comparing characters symmetrically.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(countDigits(12345));\n    }\n\n    public static int countDigits(int n) {\n        if (n == 0)\n            return 0;\n        else\n            return 1 + countDigits(n / 10);\n    }\n}",
    answers: ["5", "4", "3", "2"],
    correct: 0,
    explanations: [
      "The function call countDigits(12345) returns the number of digits in the integer, which is 5.",
      "The function recursively divides the number by 10 and increments the count until the number becomes zero.",
      "Each recursive call reduces the length of the number until it becomes zero.",
      "The count is incremented for each digit encountered during recursion.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question: "What is the primary advantage of using recursion?",
    answers: [
      "Simplicity and clarity of code.",
      "Better performance and efficiency.",
      "Lower memory consumption.",
      "Ability to handle larger inputs.",
    ],
    correct: 0,
    explanations: [
      "Recursion often leads to simpler and clearer code for certain problems, making it easier to understand and maintain.",
      "The performance comparison between recursion and iteration depends on the problem and language implementation.",
      "Recursion typically consumes more memory due to the function call stack.",
      "Recursion may lead to stack overflow errors with large inputs.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What will happen if a recursive function lacks a base case?",
    answers: [
      "The recursion will continue indefinitely, eventually leading to a stack overflow error.",
      "The recursion will terminate immediately, resulting in no output.",
      "The recursion will execute once and then terminate.",
      "The recursion will return a value of null.",
    ],
    correct: 0,
    explanations: [
      "Without a base case, the recursion will continue indefinitely, eventually exhausting the stack space and causing a stack overflow error.",
      "The absence of a base case prevents the recursion from terminating.",
      "The recursion will not terminate after a single execution without a base case to provide a termination condition.",
      "The absence of a base case does not affect the return value of the recursion.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following scenarios is best suited for using recursion?",
    answers: [
      "Traversing a directory structure to find all files and subdirectories.",
      "Calculating the sum of elements in an array using a loop.",
      "Sorting an array of integers using the bubble sort algorithm.",
      "Iterating over a linked list to find a specific element.",
    ],
    correct: 0,
    explanations: [
      "Recursion is well-suited for traversing hierarchical structures like directory trees as it simplifies the problem by breaking it into smaller subproblems.",
      "Calculating the sum of elements in an array using recursion can lead to inefficient code compared to using a loop.",
      "Bubble sort is typically implemented iteratively rather than recursively.",
      "Iterating over a linked list can be efficiently achieved using iterative approaches.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question: "What is the output of the following Java code?",
    code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(reverse("hello"));\n    }\n\n    public static String reverse(String str) {\n        if (str.isEmpty())\n            return str;\n        else\n            return reverse(str.substring(1)) + str.charAt(0);\n    }\n}',
    answers: ["olleh", "hello", "eh", "olle"],
    correct: 0,
    explanations: [
      'The function call reverse("hello") returns the reversed string "olleh".',
      "The function recursively reverses the string by appending the last character to the reversed substring.",
      "Each recursive call reduces the length of the string until it becomes empty.",
      "The final result is obtained by concatenating characters in reverse order.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question: "What is the output of the following Java code?",
    code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(isPalindrome("racecar"));\n    }\n\n    public static boolean isPalindrome(String str) {\n        if (str.length() <= 1)\n            return true;\n        else if (str.charAt(0) != str.charAt(str.length() - 1))\n            return false;\n        else\n            return isPalindrome(str.substring(1, str.length() - 1));\n    }\n}',
    answers: ["true", "false", "racecar", "car"],
    correct: 0,
    explanations: [
      'The function call isPalindrome("racecar") returns true, indicating that the string is a palindrome.',
      "The function recursively checks if the first and last characters of the string match.",
      "Each recursive call compares the characters at opposite ends of the string until the middle is reached.",
      "The function correctly identifies palindromes by comparing characters symmetrically.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      "What is the primary advantage of using recursion over iteration?",
    answers: [
      "Simplicity and clarity of code.",
      "Better performance and efficiency.",
      "Lower memory consumption.",
      "Ability to handle larger inputs.",
    ],
    correct: 0,
    explanations: [
      "Recursion often leads to simpler and clearer code for certain problems, making it easier to understand and maintain.",
      "The performance comparison between recursion and iteration depends on the problem and language implementation.",
      "Recursion typically consumes more memory due to the function call stack.",
      "Recursion may lead to stack overflow errors with large inputs.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Which of the following recursive functions correctly calculates the factorial of a number in Java?",
    answers: [
      "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
      "public int factorial(int n) {\n    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
      "public int factorial(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return factorial(n - 1);\n}",
      "public int factorial(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    ],
    correct: 0,
    explanations: [
      "This function correctly calculates the factorial of a number using recursion.",
      "The base case is correctly defined to handle the termination of recursion.",
      "The function correctly multiplies each number by its previous factorial value.",
      "Each recursive call reduces the value of n until it reaches the base case.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(countDigits(12345));\n    }\n\n    public static int countDigits(int n) {\n        if (n == 0)\n            return 0;\n        else\n            return 1 + countDigits(n / 10);\n    }\n}",
    answers: ["5", "4", "3", "2"],
    correct: 0,
    explanations: [
      "The function call countDigits(12345) returns the number of digits in the integer, which is 5.",
      "The function recursively divides the number by 10 and increments the count until the number becomes zero.",
      "Each recursive call reduces the length of the number until it becomes zero.",
      "The count is incremented for each digit encountered during recursion.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "What is the primary advantage of using recursion?",
    answers: [
      "Simplicity and clarity of code.",
      "Better performance and efficiency.",
      "Lower memory consumption.",
      "Ability to handle larger inputs.",
    ],
    correct: 0,
    explanations: [
      "Recursion often leads to simpler and clearer code for certain problems, making it easier to understand and maintain.",
      "The performance comparison between recursion and iteration depends on the problem and language implementation.",
      "Recursion typically consumes more memory due to the function call stack.",
      "Recursion may lead to stack overflow errors with large inputs.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Which of the following statements about recursion in Java is true?",
    answers: [
      "Recursion can lead to better code readability for certain problems.",
      "Recursion is always faster than iteration.",
      "Recursion cannot handle complex problems.",
      "Recursion is not supported in Java.",
    ],
    correct: 0,
    explanations: [
      "Recursion can lead to better code readability for certain problems by expressing solutions in a natural and concise way.",
      "The performance comparison between recursion and iteration depends on the problem and language implementation.",
      "Recursion can handle a wide range of problems, including complex ones, by breaking them down into smaller subproblems.",
      "Recursion is a fundamental concept supported by Java and many other programming languages.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "What will be the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(factorial(5));\n    }\n\n    public static int factorial(int n) {\n        if (n <= 1)\n            return 1;\n        else\n            return n * factorial(n - 1);\n    }\n}",
    answers: ["120", "125", "25", "100"],
    correct: 0,
    explanations: [
      "The function call factorial(5) returns the factorial of 5, which is 120.",
      "The function recursively computes the factorial of the given number.",
      "Each recursive call multiplies the current number with the factorial of the previous number.",
      "The factorial of 5 is calculated as 5 * 4 * 3 * 2 * 1 = 120.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question:
      "Which of the following recursive functions correctly calculates the Fibonacci sequence?",
    answers: [
      "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
      "public int fibonacci(int n) {\n    if (n <= 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
      "public int fibonacci(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
      "public int fibonacci(int n) {\n    if (n <= 1)\n        return 0;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    ],
    correct: 0,
    explanations: [
      "This function correctly calculates the Fibonacci sequence using recursion.",
      "The base cases are correctly defined to handle the first two Fibonacci numbers.",
      "Each recursive call computes the sum of the two preceding Fibonacci numbers.",
      "The function accurately generates the Fibonacci sequence.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "What is the base case of recursion?",
    answers: [
      "The condition that terminates the recursive process.",
      "The initial state of the recursive function.",
      "The final output of the recursive function.",
      "The condition that triggers the recursive call.",
    ],
    correct: 0,
    explanations: [
      "The base case is the condition that stops the recursive process from continuing indefinitely.",
      "The base case defines the termination condition for the recursion.",
      "The final output may be derived from the base case, but it is not the base case itself.",
      "The recursive call is triggered by the recursive step, not the base case.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "What is the maximum depth of recursion in Java?",
    answers: [
      "It depends on the runtime environment and stack size settings.",
      "It is fixed and determined by the JVM.",
      "It is limited to 1000 recursive calls.",
      "It is unlimited.",
    ],
    correct: 0,
    explanations: [
      "The maximum depth of recursion depends on factors such as the runtime environment and stack size settings.",
      "The JVM imposes no fixed limit on the depth of recursion.",
      "The limit of 1000 recursive calls is not a standard restriction and may vary across environments.",
      "Recursion can continue until the available stack space is exhausted.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question: "What is tail recursion?",
    answers: [
      "A type of recursion where the recursive call is the last operation in the function.",
      "A recursive function that operates on the tail of a list.",
      "Recursion involving only the base case.",
      "A recursive function that returns a boolean value.",
    ],
    correct: 0,
    explanations: [
      "Tail recursion occurs when the recursive call is the final operation executed by the function before returning its value.",
      "Tail recursion is not specific to lists but to the position of the recursive call within the function.",
      "Tail recursion still involves multiple recursive calls; it's not limited to the base case.",
      "Tail recursion refers to the position of the recursive call, not the return type of the function.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "Which data structure is commonly used to implement recursion?",
    answers: ["Stack", "Queue", "Array", "Linked List"],
    correct: 0,
    explanations: [
      "Recursion is often implemented using a stack data structure, where each recursive call is pushed onto the stack.",
      "A queue is not typically used for recursion; it's more commonly used for breadth-first search.",
      "While arrays and linked lists can be used for recursion, stacks are more commonly used due to their Last-In-First-Out (LIFO) nature.",
      "Linked lists can be used for recursive algorithms, but stacks are more commonly associated with recursion.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question: "What is memoization in recursion?",
    answers: [
      "Caching the results of expensive function calls to avoid redundant computations.",
      "Passing additional parameters to recursive functions.",
      "Limiting the depth of recursion to prevent stack overflow.",
      "Using loops instead of recursion.",
    ],
    correct: 0,
    explanations: [
      "Memoization involves caching the results of expensive function calls so that they can be reused when the same inputs occur again, thereby avoiding redundant computations.",
      "Passing additional parameters is a technique used for tail recursion optimization.",
      "Limiting recursion depth is a way to prevent stack overflow but is not memoization.",
      "Loops are an alternative to recursion and not related to memoization.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following is NOT a phase in solving problems recursively?",
    answers: ["Iteration", "Divide", "Conquer", "Combine"],
    correct: 0,
    explanations: [
      "Iteration is not typically a phase in solving problems recursively; recursion involves function calls rather than loops.",
      "Divide involves breaking down the problem into smaller subproblems.",
      "Conquer involves solving the smaller subproblems.",
      "Combine involves combining the solutions of the subproblems to form the solution to the original problem.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question:
      "What is the time complexity of the Fibonacci sequence calculation using naive recursion?",
    answers: ["Exponential", "Linear", "Quadratic", "Logarithmic"],
    correct: 0,
    explanations: [
      "The time complexity of the Fibonacci sequence calculation using naive recursion is exponential, O(2^n), due to redundant computations.",
      "Linear time complexity would imply a more efficient algorithm than naive recursion for Fibonacci sequence calculation.",
      "Quadratic time complexity would imply a less efficient algorithm than naive recursion for Fibonacci sequence calculation.",
      "Logarithmic time complexity would imply an even more efficient algorithm than linear time complexity for Fibonacci sequence calculation.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      "What is the purpose of the visited array in depth-first search (DFS) using recursion?",
    answers: [
      "To keep track of visited nodes to avoid revisiting them.",
      "To store the distances between nodes in a graph.",
      "To maintain the order of nodes visited.",
      "To store the adjacency matrix of the graph.",
    ],
    correct: 0,
    explanations: [
      "The visited array is used to keep track of visited nodes to avoid revisiting them and prevent infinite recursion.",
      "Storing distances between nodes is typically done in algorithms like Dijkstra's or Bellman-Ford.",
      "Maintaining the order of visited nodes is not the primary purpose of the visited array.",
      "The adjacency matrix is a different data structure used to represent connections between nodes in a graph.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "Which of the following statements about tail recursion is true?",
    answers: [
      "Tail recursion can be optimized by compilers into iterative loops.",
      "Tail recursion always requires more memory than non-tail recursion.",
      "Tail recursion is always more efficient than non-tail recursion.",
      "Tail recursion cannot be implemented in Java.",
    ],
    correct: 0,
    explanations: [
      "Some compilers can optimize tail-recursive functions into iterative loops, eliminating the need for additional stack frames.",
      "Tail recursion typically requires less memory than non-tail recursion because it doesn't need to keep track of multiple stack frames.",
      "Tail recursion is not always more efficient than non-tail recursion; it depends on various factors such as compiler optimizations and the nature of the problem.",
      "Tail recursion is a valid concept in Java and many other programming languages.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "What is the primary disadvantage of recursion?",
    answers: [
      "Increased memory usage due to function call stack.",
      "Limited applicability to certain problem domains.",
      "Slower execution compared to iterative solutions.",
      "Difficulty in understanding and debugging.",
    ],
    correct: 0,
    explanations: [
      "Recursion can lead to increased memory usage due to the need to store each function call on the call stack.",
      "Recursion is applicable to a wide range of problems, but some problems may be better suited to iterative solutions.",
      "Recursion may not always be slower than iterative solutions, but it depends on factors like language implementation and problem complexity.",
      "Recursion can sometimes be harder to understand and debug compared to iterative solutions, especially for beginners.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "What is the significance of the base case in recursive algorithms?",
    answers: [
      "It defines when the recursion should stop.",
      "It provides the starting point for the recursion.",
      "It determines the number of recursive calls.",
      "It handles the intermediate steps of the recursion.",
    ],
    correct: 0,
    explanations: [
      "The base case defines the termination condition for the recursion, preventing it from continuing indefinitely.",
      "The base case is essential for determining when to stop the recursion, but it is not the starting point.",
      "The base case is not responsible for determining the number of recursive calls; that's typically handled by the recursive step.",
      "The intermediate steps of the recursion are handled by the recursive calls and are not related to the base case.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "What is the primary advantage of using recursion?",
    answers: [
      "Simplicity and clarity of code.",
      "Better performance and efficiency.",
      "Lower memory consumption.",
      "Ability to handle larger inputs.",
    ],
    correct: 0,
    explanations: [
      "Recursion often leads to simpler and clearer code for certain problems, making it easier to understand and maintain.",
      "The performance comparison between recursion and iteration depends on the problem and language implementation.",
      "Recursion typically consumes more memory due to the function call stack.",
      "Recursion may lead to stack overflow errors with large inputs.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Which of the following statements about recursion in Java is true?",
    answers: [
      "Recursion can lead to better code readability for certain problems.",
      "Recursion is always faster than iteration.",
      "Recursion cannot handle complex problems.",
      "Recursion is not supported in Java.",
    ],
    correct: 0,
    explanations: [
      "Recursion can lead to better code readability for certain problems by expressing solutions in a natural and concise way.",
      "The performance comparison between recursion and iteration depends on the problem and language implementation.",
      "Recursion can handle a wide range of problems, including complex ones, by breaking them down into smaller subproblems.",
      "Recursion is a fundamental concept supported by Java and many other programming languages.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "What will be the output of the following Java code?",
    code: "public class Main {\n    public static void main(String[] args) {\n        System.out.println(factorial(5));\n    }\n\n    public static int factorial(int n) {\n        if (n <= 1)\n            return 1;\n        else\n            return n * factorial(n - 1);\n    }\n}",
    answers: ["120", "125", "25", "100"],
    correct: 0,
    explanations: [
      "The function call factorial(5) returns the factorial of 5, which is 120.",
      "The function recursively computes the factorial of the given number.",
      "Each recursive call multiplies the current number with the factorial of the previous number.",
      "The factorial of 5 is calculated as 5 * 4 * 3 * 2 * 1 = 120.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question:
      "Which of the following recursive functions correctly calculates the Fibonacci sequence?",
    answers: [
      "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
      "public int fibonacci(int n) {\n    if (n <= 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
      "public int fibonacci(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
      "public int fibonacci(int n) {\n    if (n <= 1)\n        return 0;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    ],
    correct: 1,
    explanations: [
      "This function correctly calculates the Fibonacci sequence by recursively summing the previous two numbers.",
      "This function also calculates the Fibonacci sequence correctly, but it has an additional condition to handle the base cases.",
      "This function returns incorrect values for the base cases where n is 0 or negative.",
      "This function returns incorrect values for the base cases where n is 1 or 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "What is the significance of the 'return' statement in recursive functions?",
    answers: [
      "It returns the value calculated by the recursive call to the calling function.",
      "It stops the execution of the function and returns control to the caller.",
      "It is not required in recursive functions.",
      "It indicates the end of the recursive call.",
    ],
    correct: 0,
    explanations: [
      "The 'return' statement in recursive functions is crucial as it returns the value calculated by the recursive call to the calling function.",
      "While 'return' does return control to the caller, its primary purpose in recursive functions is to return the calculated value.",
      "The 'return' statement is essential in recursive functions to propagate values back up the call stack.",
      "The 'return' statement does not indicate the end of the recursive call; it merely returns a value to the caller.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question: "What is the primary reason for using recursion over iteration?",
    answers: [
      "To solve problems more naturally and elegantly.",
      "To improve performance and efficiency.",
      "To handle problems that cannot be solved iteratively.",
      "To avoid stack overflow errors.",
    ],
    correct: 0,
    explanations: [
      "Recursion is often chosen over iteration for its ability to express solutions more naturally and elegantly for certain problems.",
      "While recursion can sometimes be more efficient, performance considerations alone are not the primary reason for choosing recursion over iteration.",
      "While recursion can handle certain problems more effectively, many problems can be solved using both recursion and iteration.",
      "Recursion may actually lead to stack overflow errors if not managed properly.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      "Which of the following problems is NOT well-suited for recursion?",
    answers: [
      "Iterative search through a large database.",
      "Calculating the factorial of a number.",
      "Traversing a binary tree.",
      "Sorting a list of integers.",
    ],
    correct: 0,
    explanations: [
      "Searching through a large database is typically done iteratively due to efficiency and resource considerations.",
      "Calculating the factorial of a number is well-suited for recursion due to its naturally recursive definition.",
      "Traversing a binary tree is often done recursively because of its hierarchical structure.",
      "Sorting a list of integers can be done using recursive algorithms like quicksort or mergesort.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the primary drawback of tail recursion?",
    answers: [
      "Limited support in some programming languages and environments.",
      "Increased memory usage due to additional stack frames.",
      "Difficulty in understanding and debugging.",
      "Inability to handle certain types of problems.",
    ],
    correct: 0,
    explanations: [
      "While tail recursion can improve performance and memory usage, it has limited support in some programming languages and environments.",
      "Tail recursion typically reduces memory usage by reusing stack frames, unlike non-tail recursion.",
      "Difficulty in understanding and debugging is not a primary drawback of tail recursion.",
      "Tail recursion is a general-purpose technique and can handle a wide range of problems.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "What is the primary role of the stack in recursive function calls?",
    answers: [
      "To keep track of function calls and local variables.",
      "To store global variables used by the functions.",
      "To allocate memory for the functions.",
      "To control the flow of execution within the functions.",
    ],
    correct: 0,
    explanations: [
      "The stack is used to keep track of function calls and store local variables for each invocation of the function.",
      "Global variables are typically stored in a separate memory area and are not directly related to the function call stack.",
      "Memory allocation is handled by the runtime environment and is not the primary responsibility of the function call stack.",
      "While the stack does control the flow of execution to some extent, its primary role is managing function calls and local variables.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "Which of the following statements about recursion is true?",
    answers: [
      "Recursion can lead to elegant and concise code for certain problems.",
      "Recursion is always more efficient than iteration.",
      "Recursion is limited to certain programming languages.",
      "Recursion cannot handle large inputs.",
    ],
    correct: 0,
    explanations: [
      "Recursion can often result in more elegant and concise code for problems that have a recursive structure.",
      "The efficiency of recursion versus iteration depends on the problem and language implementation.",
      "Recursion is a fundamental programming concept and is supported by many programming languages.",
      "Recursion can handle large inputs as long as proper termination conditions are defined.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "What is recursion?",
    answers: [
      "A programming technique where a function calls itself.",
      "A programming technique where a function calls another function.",
      "A programming technique where a function calls a built-in library function.",
      "A programming technique where a function calls a variable.",
    ],
    correct: 0,
    explanations: [
      "Recursion is a programming technique where a function calls itself.",
      "This is not correct because recursion involves a function calling itself, not another function.",
      "This is not correct because recursion does not necessarily involve built-in library functions.",
      "This is not correct because recursion involves a function calling itself, not a variable.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the base case in recursion?",
    answers: [
      "The terminating condition that stops the recursive calls.",
      "The first step of the recursive function.",
      "The function that is called recursively.",
      "The variable used inside the recursive function.",
    ],
    correct: 0,
    explanations: [
      "The base case is the terminating condition that stops the recursive calls.",
      "This is not correct because the base case is not the first step but the condition that stops the recursion.",
      "This is not correct because the base case is not a separate function but a condition within the recursive function.",
      "This is not correct because the base case is a condition, not a variable.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "Which data structure is commonly used to implement recursion?",
    answers: ["Stack", "Queue", "Array", "Linked List"],
    correct: 0,
    explanations: [
      "Stack is commonly used to implement recursion due to its Last In First Out (LIFO) nature.",
      "This is not correct because a queue is not typically used for recursion.",
      "This is not correct because an array is not commonly used for recursion.",
      "This is not correct because a linked list is not commonly used for recursion.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "What is the main advantage of using recursion?",
    answers: [
      "Simplifies the problem-solving approach.",
      "Requires less memory.",
      "Results in faster execution time.",
      "Avoids the use of loops.",
    ],
    correct: 0,
    explanations: [
      "Recursion simplifies the problem-solving approach by breaking down complex problems into simpler ones.",
      "This is not correct because recursion may sometimes require more memory due to function call overhead.",
      "This is not correct because recursion may sometimes result in slower execution time due to function call overhead.",
      "This is not correct because recursion is a different approach rather than an alternative to loops.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the typical drawback of using recursion?",
    answers: [
      "May lead to stack overflow for large inputs.",
      "Requires more memory.",
      "Results in slower execution time.",
      "Is difficult to implement.",
    ],
    correct: 0,
    explanations: [
      "One typical drawback of recursion is that it may lead to stack overflow for large inputs.",
      "This is not correct because recursion may sometimes require less memory depending on the implementation.",
      "This is not correct because recursion may sometimes result in faster execution time depending on the problem.",
      "This is not correct because while recursion may be challenging for some, it's not universally difficult to implement.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "Which of the following is true about recursive functions?",
    answers: [
      "They must have a base case to terminate.",
      "They cannot call themselves.",
      "They always result in an infinite loop.",
      "They cannot return a value.",
    ],
    correct: 0,
    explanations: [
      "Recursive functions must have a base case to terminate, otherwise, they may result in infinite recursion.",
      "This is not correct because recursive functions indeed call themselves.",
      "This is not correct because while recursive functions may result in infinite loops without a base case, it's not always the case.",
      "This is not correct because recursive functions can return values.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "Which of the following is an example of a recursive function?",
    answers: [
      "Calculating the factorial of a number.",
      "Sorting an array using a loop.",
      "Iterating through a linked list using recursion.",
      "Finding the maximum element in an array using a loop.",
    ],
    correct: 0,
    explanations: [
      "Calculating the factorial of a number is an example of a recursive function as it calls itself with a smaller argument.",
      "This is not correct because sorting an array using a loop is an example of an iterative approach.",
      "This is not correct because iterating through a linked list using recursion is an example of a recursive approach.",
      "This is not correct because finding the maximum element in an array using a loop is an example of an iterative approach.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question: "What is the key characteristic of a recursive function?",
    answers: [
      "It calls itself.",
      "It uses a loop.",
      "It has multiple return statements.",
      "It does not have parameters.",
    ],
    correct: 0,
    explanations: [
      "The key characteristic of a recursive function is that it calls itself.",
      "This is not correct because a recursive function doesn't necessarily involve loops.",
      "This is not correct because the presence of multiple return statements is not a defining characteristic of recursion.",
      "This is not correct because recursive functions commonly have parameters.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Which of the following is essential for a recursive function to terminate?",
    answers: [
      "Base case",
      "Recursive case",
      "Global variables",
      "Function arguments",
    ],
    correct: 0,
    explanations: [
      "A base case is essential for a recursive function to terminate.",
      "This is not correct because while a recursive case is necessary, it's not sufficient for termination.",
      "This is not correct because global variables are not directly related to the termination of recursive functions.",
      "This is not correct because function arguments are used within the recursive calls but are not directly related to termination.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question: "What is recursion useful for in programming?",
    answers: [
      "Solving problems with repeated subproblems.",
      "Performing arithmetic operations.",
      "Manipulating strings.",
      "Creating user interfaces.",
    ],
    correct: 0,
    explanations: [
      "Recursion is useful for solving problems with repeated subproblems by breaking them down into smaller instances.",
      "This is not correct because recursion is not limited to arithmetic operations.",
      "This is not correct because recursion is not limited to string manipulation.",
      "This is not correct because recursion is not typically used for creating user interfaces.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question: "What does the term 'tail recursion' refer to?",
    answers: [
      "When the recursive call is the last operation in a function.",
      "When the recursive function has multiple base cases.",
      "When the recursive function returns a value.",
      "When the recursive function uses a stack data structure.",
    ],
    correct: 0,
    explanations: [
      "Tail recursion refers to a situation where the recursive call is the last operation in a function.",
      "This is not correct because tail recursion is not about having multiple base cases.",
      "This is not correct because tail recursion is about the position of the recursive call, not about returning a value.",
      "This is not correct because the use of a stack data structure is not specific to tail recursion.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "Which of the following statements best describes recursion?",
    answers: [
      "A function that calls itself in its definition.",
      "A function that calls another function.",
      "A function that uses a loop to iterate.",
      "A function that returns a value.",
    ],
    correct: 0,
    explanations: [
      "Recursion is best described as a function that calls itself in its definition.",
      "This is not correct because recursion involves a function calling itself, not another function.",
      "This is not correct because recursion doesn't necessarily involve loops.",
      "This is not correct because recursion may or may not return a value.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 50,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "What is the primary purpose of a base case in a recursive function?",
    answers: [
      "To stop the recursion.",
      "To initiate the recursion.",
      "To handle edge cases.",
      "To perform arithmetic operations.",
    ],
    correct: 0,
    explanations: [
      "The primary purpose of a base case in a recursive function is to stop the recursion.",
      "This is not correct because the base case doesn't initiate the recursion; it stops it.",
      "This is not correct because while a base case may handle edge cases, its primary purpose is to terminate the recursion.",
      "This is not correct because the base case typically involves comparison or condition checks, not arithmetic operations.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 55,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the risk of infinite recursion in a recursive function?",
    answers: [
      "It can cause a stack overflow error.",
      "It results in a null pointer exception.",
      "It leads to memory leaks.",
      "It causes the program to crash.",
    ],
    correct: 0,
    explanations: [
      "Infinite recursion can cause a stack overflow error as the call stack grows excessively.",
      "This is not correct because infinite recursion does not necessarily result in a null pointer exception.",
      "This is not correct because infinite recursion itself does not lead to memory leaks; it's rather a resource exhaustion issue.",
      "This is not correct because infinite recursion may not always cause an immediate program crash.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question: "How does recursion differ from iteration in programming?",
    answers: [
      "Recursion uses function calls, while iteration uses loops.",
      "Recursion always requires a base case, while iteration does not.",
      "Recursion is slower than iteration.",
      "Recursion cannot be used for arithmetic operations.",
    ],
    correct: 0,
    explanations: [
      "Recursion differs from iteration in that recursion uses function calls to repeat a set of instructions, while iteration uses loops.",
      "This is not correct because both recursion and iteration can have termination conditions; it's not unique to recursion.",
      "This is not correct because the performance of recursion versus iteration depends on the specific problem and implementation.",
      "This is not correct because recursion can be used for arithmetic operations just like iteration.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the concept of 'divide and conquer' related to recursion?",
    answers: [
      "Breaking a problem into smaller, more manageable subproblems.",
      "Combining multiple problems into one.",
      "Using a single base case to handle all scenarios.",
      "Ignoring the base case altogether.",
    ],
    correct: 0,
    explanations: [
      "'Divide and conquer' in recursion involves breaking a problem into smaller, more manageable subproblems.",
      "This is not correct because 'divide and conquer' involves splitting problems, not combining them.",
      "This is not correct because using a single base case for all scenarios is not part of 'divide and conquer'.",
      "This is not correct because ignoring the base case would lead to infinite recursion or incorrect results.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question: "In a recursive function, what is the role of the call stack?",
    answers: [
      "To keep track of function calls and their local variables.",
      "To store the base case.",
      "To prevent infinite recursion.",
      "To store global variables.",
    ],
    correct: 0,
    explanations: [
      "The call stack in a recursive function keeps track of function calls and their local variables, enabling the function to return to the correct execution point after a recursive call.",
      "This is not correct because the call stack does not store the base case itself; it tracks function calls.",
      "This is not correct because the call stack itself does not prevent infinite recursion; it's the base case that does.",
      "This is not correct because the call stack primarily deals with function calls and local variables, not global variables.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "What is the significance of the stack in recursive function calls?",
    answers: [
      "It manages the sequence of function calls and their local variables.",
      "It stores the base case.",
      "It ensures the recursive function returns null.",
      "It handles exceptions thrown by the recursive function.",
    ],
    correct: 0,
    explanations: [
      "The stack in recursive function calls manages the sequence of function calls and their local variables, allowing proper execution and return.",
      "This is not correct because the stack does not store the base case; it's the structure that facilitates function call sequencing.",
      "This is not correct because the stack's purpose is not related to ensuring the function returns null.",
      "This is not correct because the stack's primary role is not handling exceptions but managing function calls and local variables.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Why is it essential to have a base case in a recursive function?",
    answers: [
      "To provide a termination condition for the recursion.",
      "To handle exceptions thrown by the recursive calls.",
      "To initialize the function parameters.",
      "To ensure the function always returns a value.",
    ],
    correct: 0,
    explanations: [
      "Having a base case in a recursive function is essential to provide a termination condition, preventing infinite recursion.",
      "This is not correct because while exceptions should be handled, the base case is specifically for termination conditions.",
      "This is not correct because the base case is not about initializing parameters but providing a termination condition.",
      "This is not correct because the base case ensures termination; it's not directly related to the return value.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question: "How does recursion help in solving problems more elegantly?",
    answers: [
      "By breaking down complex problems into simpler subproblems.",
      "By using fewer function calls.",
      "By avoiding the use of loops entirely.",
      "By reducing the need for base cases.",
    ],
    correct: 0,
    explanations: [
      "Recursion helps in solving problems more elegantly by breaking down complex problems into simpler subproblems, which can then be solved individually.",
      "This is not correct because the elegance of recursion comes from its ability to break down problems, not from the number of function calls.",
      "This is not correct because recursion can coexist with loops and sometimes may even be implemented using loops.",
      "This is not correct because the presence of base cases is crucial for recursion to work correctly; it doesn't reduce the need for them.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 55,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question: "Which of the following best describes the process of recursion?",
    answers: [
      "A function calls itself until a base condition is met.",
      "A function calls another function.",
      "A function iterates over a collection using a loop.",
      "A function performs arithmetic operations.",
    ],
    correct: 0,
    explanations: [
      "Recursion involves a function calling itself until a base condition is met.",
      "This is not correct because recursion involves a function calling itself, not another function.",
      "This is not correct because recursion is distinct from iteration.",
      "This is not correct because recursion is not limited to arithmetic operations.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the primary purpose of a base case in a recursive function?",
    answers: [
      "To provide a termination condition for recursion.",
      "To initialize variables.",
      "To call other functions.",
      "To handle exceptions.",
    ],
    correct: 0,
    explanations: [
      "The base case in a recursive function provides a termination condition for recursion.",
      "This is not correct because the base case is not primarily for variable initialization.",
      "This is not correct because the base case is not meant for calling other functions.",
      "This is not correct because the base case is not primarily for handling exceptions.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Which data structure is typically used to manage recursive function calls?",
    answers: ["Call stack", "Queue", "Linked list", "Array"],
    correct: 0,
    explanations: [
      "The call stack is typically used to manage recursive function calls.",
      "This is not correct because a queue is not typically used for managing recursive calls.",
      "This is not correct because a linked list is not typically used for managing recursive calls.",
      "This is not correct because an array is not typically used for managing recursive calls.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question: "What is a potential downside of using recursion in programming?",
    answers: [
      "Risk of stack overflow for large inputs.",
      "Increased performance.",
      "Simplified code structure.",
      "Better memory management.",
    ],
    correct: 0,
    explanations: [
      "A potential downside of using recursion is the risk of stack overflow for large inputs due to excessive function calls.",
      "This is not correct because recursion may sometimes result in decreased performance.",
      "This is not correct because recursion may not always result in a simplified code structure.",
      "This is not correct because recursion may not always lead to better memory management.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "Which of the following is true about tail recursion?",
    answers: [
      "The recursive call is the last operation in the function.",
      "The recursive call is the first operation in the function.",
      "Tail recursion always leads to stack overflow.",
      "Tail recursion requires multiple base cases.",
    ],
    correct: 0,
    explanations: [
      "In tail recursion, the recursive call is the last operation in the function.",
      "This is not correct because tail recursion involves the recursive call being the last operation, not the first.",
      "This is not correct because tail recursion does not always lead to stack overflow.",
      "This is not correct because tail recursion doesn't necessarily require multiple base cases.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "How does recursion help in solving problems with repeated subproblems?",
    answers: [
      "By breaking down the problem into smaller instances.",
      "By executing loops iteratively.",
      "By using global variables.",
      "By ignoring the base case.",
    ],
    correct: 0,
    explanations: [
      "Recursion helps in solving problems with repeated subproblems by breaking down the problem into smaller instances.",
      "This is not correct because recursion is distinct from iterative looping constructs.",
      "This is not correct because recursion typically avoids the use of global variables.",
      "This is not correct because ignoring the base case would lead to incorrect results or infinite recursion.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 55,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "What is the potential consequence of a recursive function lacking a base case?",
    answers: [
      "It may result in infinite recursion.",
      "It always throws an exception.",
      "It automatically returns null.",
      "It leads to a stack overflow error.",
    ],
    correct: 0,
    explanations: [
      "If a recursive function lacks a base case, it may result in infinite recursion, where the function calls itself indefinitely without termination.",
      "This is not correct because the absence of a base case doesn't always result in an immediate exception.",
      "This is not correct because the absence of a base case does not automatically imply a null return.",
      "This is not correct because while infinite recursion is a risk, the immediate consequence is not necessarily a stack overflow error.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive function in Java to calculate the factorial of a non-negative integer.",
    code: "public class Factorial {\n    public int calculateFactorial(int n) {\n        if (n == 0)\n            return 1;\n        else\n            return n * calculateFactorial(n - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the factorial of a non-negative integer.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the factorial.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the factorial of a non-negative integer by calling itself with a smaller argument.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code does indeed calculate the factorial.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive function in Java to compute the nth Fibonacci number.",
    code: "public class Fibonacci {\n    public int calculateFibonacci(int n) {\n        if (n <= 1)\n            return n;\n        else\n            return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to compute the nth Fibonacci number.",
      "The given code contains logic errors.",
      "The given code implements an iterative solution.",
      "The given code does not compute the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to compute the nth Fibonacci number by calling itself recursively with smaller arguments.",
      "This is not correct because the given code is logically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed computes the Fibonacci sequence.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 70,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a Java method that recursively calculates the sum of all elements in an integer array.",
    code: "public class ArraySum {\n    public int calculateSum(int[] arr, int index) {\n        if (index < 0)\n            return 0;\n        else\n            return arr[index] + calculateSum(arr, index - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to calculate the sum of all elements in an integer array.",
      "The given code contains compilation errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the sum of array elements.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to calculate the sum of all elements in an integer array by calling itself with a decreasing index.",
      "This is not correct because the given code is free of compilation errors.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the sum of array elements.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 80,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question: "Implement a recursive function in Java to reverse a string.",
    code: "public class StringReverse {\n    public String reverseString(String str) {\n        if (str.isEmpty())\n            return str;\n        else\n            return reverseString(str.substring(1)) + str.charAt(0);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to reverse a string.",
      "The given code has logical flaws.",
      "The given code implements an iterative solution.",
      "The given code does not reverse the string.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to reverse a string by calling itself recursively with a substring.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed reverses the string.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Write a recursive Java method to find the maximum element in an integer array.",
    code: "public class MaxElement {\n    public int findMax(int[] arr, int index) {\n        if (index == arr.length - 1)\n            return arr[index];\n        else\n            return Math.max(arr[index], findMax(arr, index + 1));\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to find the maximum element in an integer array.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not find the maximum element.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to find the maximum element in an integer array by calling itself recursively with an incremented index.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed finds the maximum element in the array.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 100,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive Java function to calculate the power of a number.",
    code: "public class Power {\n    public int calculatePower(int base, int exponent) {\n        if (exponent == 0)\n            return 1;\n        else\n            return base * calculatePower(base, exponent - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the power of a number.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the power.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the power of a number by repeatedly multiplying the base.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the power.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive Java method to check if a given number is prime.",
    code: "public class PrimeChecker {\n    public boolean isPrime(int num, int divisor) {\n        if (divisor <= 1)\n            return true;\n        else if (num % divisor == 0)\n            return false;\n        else\n            return isPrime(num, divisor - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to check if a given number is prime.",
      "The given code has logical errors.",
      "The given code implements an iterative solution.",
      "The given code does not check for prime numbers.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to check if a given number is prime by recursively checking divisibility.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed checks for prime numbers.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 70,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a Java method that recursively calculates the nth term of the Fibonacci sequence.",
    code: "public class Fibonacci {\n    public int calculateFibonacci(int n) {\n        if (n <= 1)\n            return n;\n        else\n            return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to calculate the nth term of the Fibonacci sequence.",
      "The given code contains compilation errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to calculate the nth term of the Fibonacci sequence by calling itself with smaller arguments.",
      "This is not correct because the given code is free of compilation errors.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the Fibonacci sequence.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 80,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "Implement a recursive Java function to find the GCD (Greatest Common Divisor) of two integers.",
    code: "public class GCD {\n    public int findGCD(int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return findGCD(b, a % b);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to find the GCD of two integers.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not find the GCD.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to find the GCD of two integers using Euclid's algorithm.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed finds the GCD.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Write a recursive Java method to generate all permutations of a given string.",
    code: "public class Permutations {\n    public void generatePermutations(String prefix, String str) {\n        int n = str.length();\n        if (n == 0)\n            System.out.println(prefix);\n        else {\n            for (int i = 0; i < n; i++)\n                generatePermutations(prefix + str.charAt(i), str.substring(0, i) + str.substring(i + 1, n));\n        }\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to generate all permutations of a given string.",
      "The given code has logical flaws.",
      "The given code implements an iterative solution.",
      "The given code does not generate permutations.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to generate all permutations of a given string by generating permutations recursively.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed generates permutations.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 100,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive Java function to calculate the sum of digits of a positive integer.",
    code: "public class DigitSum {\n    public int calculateDigitSum(int n) {\n        if (n < 10)\n            return n;\n        else\n            return n % 10 + calculateDigitSum(n / 10);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the sum of digits of a positive integer.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the sum of digits.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the sum of digits of a positive integer by recursively adding the last digit.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the sum of digits.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive Java function to calculate the number of trailing zeroes in the factorial of a positive integer.",
    code: "public class TrailingZeroes {\n    public int countTrailingZeroes(int n) {\n        if (n < 5)\n            return 0;\n        else\n            return n / 5 + countTrailingZeroes(n / 5);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the number of trailing zeroes in the factorial of a positive integer.",
      "The given code has logical errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate trailing zeroes.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the number of trailing zeroes in the factorial of a positive integer using the concept of prime factorization.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates trailing zeroes.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 70,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a recursive Java method to find the nth term of the arithmetic sequence.",
    code: "public class ArithmeticSequence {\n    public int calculateNthTerm(int firstTerm, int difference, int n) {\n        if (n == 1)\n            return firstTerm;\n        else\n            return calculateNthTerm(firstTerm + difference, difference, n - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to find the nth term of the arithmetic sequence.",
      "The given code contains compilation errors.",
      "The given code implements an iterative solution.",
      "The given code does not find the nth term.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to find the nth term of the arithmetic sequence by recursively adding the common difference.",
      "This is not correct because the given code is free of compilation errors.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed finds the nth term.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 80,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "Implement a recursive Java function to check if a given string is a palindrome.",
    code: "public class PalindromeChecker {\n    public boolean isPalindrome(String str) {\n        if (str.length() <= 1)\n            return true;\n        else if (str.charAt(0) != str.charAt(str.length() - 1))\n            return false;\n        else\n            return isPalindrome(str.substring(1, str.length() - 1));\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to check if a given string is a palindrome.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not check for palindromes.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to check if a given string is a palindrome by comparing characters from both ends.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed checks for palindromes.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      'Consider the following recursive function in Java. What will be the output when calling mystery(3)?\n\n```java\npublic class Mystery {\n    public static void mystery(int n) {\n        if (n > 0) {\n            mystery(n - 1);\n            System.out.print(n + " ");\n        }\n    }\n\n    public static void main(String[] args) {\n        mystery(3);\n    }\n}\n```',
    code: 'public class Mystery {\n    public static void mystery(int n) {\n        if (n > 0) {\n            mystery(n - 1);\n            System.out.print(n + " ");\n        }\n    }\n\n    public static void main(String[] args) {\n        mystery(3);\n    }\n}',
    answers: [
      "The output will be '1 2 3'.",
      "The output will be '3 2 1'.",
      "The output will be '3 2 1 1 2 3'.",
      "The output will be '1 1 2 1 2 3'.",
    ],
    correct: 0,
    explanations: [
      "The function mystery(n) recursively calls itself with n - 1 until n becomes 0. Then, it prints the value of n when returning from the recursive calls. So, when calling mystery(3), it prints '1 2 3'.",
      "This is incorrect because the function prints the value of n after the recursive call, resulting in '1 2 3'.",
      "This is incorrect because it includes the intermediate outputs of recursive calls, resulting in '1 2 3'.",
      "This is incorrect because it includes extra repetitions of '1' and misses '3', resulting in '1 1 2 1 2 3'.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What will be the time complexity of the following recursive function in terms of Big O notation?\n\n```java\npublic int recursiveFunction(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunction(n - 1) + recursiveFunction(n - 2);\n}\n```",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The given recursive function is the Fibonacci sequence algorithm using recursion. Its time complexity is exponential, O(2^n), because each function call results in two more calls.",
      "This is incorrect because the time complexity is not linear; it's exponential.",
      "This is incorrect because the time complexity is not logarithmic; it's exponential.",
      "This is incorrect because the time complexity is not quadratic; it's exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Consider the following recursive function in Java. What will be the value of x after calling mystery(5)?\n\n```java\nint mystery(int n) {\n    if (n == 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}\n```",
    code: "int mystery(int n) {\n    if (n == 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}",
    answers: [
      "The value of x will be 15.",
      "The value of x will be 5.",
      "The value of x will be 10.",
      "The value of x will be 20.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the sum of integers from 1 to n recursively. So, the value of x after calling mystery(5) will be 15.",
      "This is incorrect because the function calculates the sum of integers from 1 to n, not just n itself.",
      "This is incorrect because the value of x is the sum of integers from 1 to 5, which is 15.",
      "This is incorrect because the value of x is not doubled; it's the sum of integers from 1 to 5, which is 15.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      'What will be the output of the following Java code?\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(mystery("hello", 0));\n    }\n    \n    public static String mystery(String s, int index) {\n        if (index == s.length())\n            return "";\n        else\n            return mystery(s, index + 1) + s.charAt(index);\n    }\n}\n```',
    code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(mystery("hello", 0));\n    }\n    \n    public static String mystery(String s, int index) {\n        if (index == s.length())\n            return "";\n        else\n            return mystery(s, index + 1) + s.charAt(index);\n    }\n}',
    answers: [
      "The output will be 'olleh'.",
      "The output will be 'hello'.",
      "The output will be 'eh'.",
      "The output will be 'lo'.",
    ],
    correct: 0,
    explanations: [
      "The function 'mystery' recursively reverses the string 's'. So, the output will be 'olleh'.",
      "This is incorrect because the function recursively reverses the string 's'.",
      "This is incorrect because the function recursively reverses the entire string 's'.",
      "This is incorrect because the function recursively reverses the entire string 's'.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}",
    answers: [
      "The output will be 24.",
      "The output will be 120.",
      "The output will be 720.",
      "The output will be 5040.",
    ],
    correct: 1,
    explanations: [
      "The function calculates the factorial of a given number. So, calling mystery(4) will result in 4 * 3 * 2 * 1 = 24.",
      "This is incorrect because the function calculates the factorial of the input.",
      "This is incorrect because the function calculates the factorial of the input.",
      "This is incorrect because the function calculates the factorial of the input.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the time complexity of the following recursive function in terms of Big O notation?\n\n```java\npublic int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}\n```",
    code: "public int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The function implements the Fibonacci sequence using recursion, resulting in exponential time complexity O(2^n).",
      "This is incorrect because the time complexity of the function is not linear.",
      "This is incorrect because the time complexity of the function is not logarithmic.",
      "This is incorrect because the time complexity of the function is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Consider the recursive function below. What will be the output when calling mystery(5)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 2);\n}",
    answers: [
      "The output will be 9.",
      "The output will be 10.",
      "The output will be 11.",
      "The output will be 12.",
    ],
    correct: 2,
    explanations: [
      "The function calculates the sum of all odd numbers up to the given input. So, calling mystery(5) will result in 1 + 3 + 5 = 9.",
      "This is incorrect because the function calculates the sum of all odd numbers up to the given input.",
      "This is the correct answer because calling mystery(5) will result in 1 + 3 + 5 = 9.",
      "This is incorrect because the function calculates the sum of all odd numbers up to the given input.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "What will be the output of the following recursive function in Java when calling mystery(3)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n * mystery(n - 3);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n * mystery(n - 3);\n}",
    answers: [
      "The output will be 0.",
      "The output will be 6.",
      "The output will be 18.",
      "The output will be 27.",
    ],
    correct: 0,
    explanations: [
      "The function returns 0 for n <= 0. So, calling mystery(3) will result in 0.",
      "This is incorrect because the function returns 0 for n <= 0.",
      "This is incorrect because the function returns 0 for n <= 0.",
      "This is incorrect because the function returns 0 for n <= 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}",
    answers: [
      "The output will be 1.",
      "The output will be 2.",
      "The output will be 3.",
      "The output will be 4.",
    ],
    correct: 0,
    explanations: [
      "The function recursively calls itself with n / 2 until n becomes 0. So, calling mystery(4) will result in 1.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(3)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}",
    answers: [
      "The output will be 6.",
      "The output will be 3.",
      "The output will be 0.",
      "The output will be 15.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the sum of integers from 1 to n. So, calling mystery(3) will result in 6.",
      "This is incorrect because the function calculates the sum of integers from 1 to n.",
      "This is incorrect because the function calculates the sum of integers from 1 to n.",
      "This is incorrect because the function calculates the sum of integers from 1 to n.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the time complexity of the following recursive function in terms of Big O notation?\n\n```java\npublic int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}\n```",
    code: "public int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The function implements the Fibonacci sequence using recursion, resulting in exponential time complexity O(2^n).",
      "This is incorrect because the time complexity of the function is not linear.",
      "This is incorrect because the time complexity of the function is not logarithmic.",
      "This is incorrect because the time complexity of the function is not quadratic.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Consider the recursive function below. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}",
    answers: [
      "The output will be 24.",
      "The output will be 10.",
      "The output will be 0.",
      "The output will be 1.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the factorial of a given number. So, calling mystery(4) will result in 24.",
      "This is incorrect because the function calculates the factorial of a given number.",
      "This is incorrect because the function calculates the factorial of a given number.",
      "This is incorrect because the function calculates the factorial of a given number.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "What will be the output of the following recursive function in Java when calling mystery(5)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 2);\n}",
    answers: [
      "The output will be 15.",
      "The output will be 120.",
      "The output will be 0.",
      "The output will be 1.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the factorial of odd numbers. So, calling mystery(5) will result in 15.",
      "This is incorrect because the function calculates the factorial of odd numbers.",
      "This is incorrect because the function calculates the factorial of odd numbers.",
      "This is incorrect because the function calculates the factorial of odd numbers.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}",
    answers: [
      "The output will be 1.",
      "The output will be 2.",
      "The output will be 3.",
      "The output will be 4.",
    ],
    correct: 0,
    explanations: [
      "The function recursively calls itself with n / 2 until n becomes 0. So, calling mystery(4) will result in 1.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.05,
    question:
      "Write a recursive function in Java to calculate the factorial of a given number.",
    code: "public int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: [
      "The provided code is a correct implementation of the factorial function.",
      "The provided code contains syntax errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the factorial function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Implement a recursive function in Java to calculate the nth Fibonacci number.",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: [
      "The provided code is a correct implementation of the Fibonacci function.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the Fibonacci function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles base cases correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Create a recursive function in Java to find the sum of digits of a given number.",
    code: "public int digitSum(int n) {\n    if (n == 0)\n        return 0;\n    else\n        return n % 10 + digitSum(n / 10);\n}",
    answers: [
      "The provided code is a correct implementation to find the sum of digits of a number.",
      "The provided code contains syntax errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the sum of digits function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a recursive function in Java to calculate the sum of all even numbers up to a given limit.",
    code: "public int evenSum(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return (n % 2 == 0 ? n : 0) + evenSum(n - 1);\n}",
    answers: [
      "The provided code is a correct implementation to calculate the sum of even numbers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the sum of even numbers function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive function in Java to check if a given string is a palindrome.",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The provided code correctly checks if the string is a palindrome.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the palindrome checking function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles single character and empty strings correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive function in Java to compute the exponentiation of a number.",
    code: "public int power(int base, int exponent) {\n    if (exponent == 0)\n        return 1;\n    else\n        return base * power(base, exponent - 1);\n}",
    answers: [
      "The provided code correctly computes the exponentiation.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative exponents.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the exponentiation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 exponent correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a recursive function in Java to generate all permutations of a given string.",
    code: "public void permute(String s, int left, int right) {\n    if (left == right)\n        System.out.println(s);\n    else {\n        for (int i = left; i <= right; i++) {\n            s = swap(s, left, i);\n            permute(s, left + 1, right);\n            s = swap(s, left, i);\n        }\n    }\n}\n\nprivate String swap(String s, int i, int j) {\n    char[] charArray = s.toCharArray();\n    char temp = charArray[i];\n    charArray[i] = charArray[j];\n    charArray[j] = temp;\n    return String.valueOf(charArray);\n}",
    answers: [
      "The provided code correctly generates all permutations of the given string.",
      "The provided code contains syntax errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the permutation generation function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles permutations correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "Implement a recursive function in Java to find the greatest common divisor (GCD) of two integers.",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The provided code correctly calculates the GCD of two integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative integers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the GCD calculation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Write a recursive function in Java to generate all possible subsets of a given set.",
    code: "public void generateSubsets(int[] nums, int index, List<Integer> subset, List<List<Integer>> result) {\n    result.add(new ArrayList<>(subset));\n    for (int i = index; i < nums.length; i++) {\n        subset.add(nums[i]);\n        generateSubsets(nums, i + 1, subset, result);\n        subset.remove(subset.size() - 1);\n    }\n}",
    answers: [
      "The provided code correctly generates all possible subsets of the given set.",
      "The provided code contains syntax errors.",
      "The provided code does not handle empty sets.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the subset generation function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles empty set correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Write a recursive function in Java to find the factorial of a given number.",
    code: "public int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: [
      "The provided code correctly calculates the factorial of a given number.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the factorial function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.45,
    question:
      "Implement a recursive function in Java to calculate the sum of all elements in an integer array.",
    code: "public int arraySum(int[] arr, int index) {\n    if (index < 0)\n        return 0;\n    else\n        return arr[index] + arraySum(arr, index - 1);\n}",
    answers: [
      "The provided code correctly calculates the sum of all elements in an integer array.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the array sum function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles negative index correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Write a recursive function in Java to generate all permutations of a given array of integers.",
    code: "public void generatePermutations(int[] arr, int index) {\n    if (index == arr.length - 1) {\n        System.out.println(Arrays.toString(arr));\n        return;\n    }\n    for (int i = index; i < arr.length; i++) {\n        swap(arr, index, i);\n        generatePermutations(arr, index + 1);\n        swap(arr, index, i);\n    }\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}",
    answers: [
      "The provided code correctly generates all permutations of a given array of integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the permutation generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Implement a recursive function in Java to find the greatest common divisor (GCD) of two integers.",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The provided code correctly calculates the greatest common divisor (GCD) of two integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the GCD calculation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "Write a recursive function in Java to check if a given string is a palindrome.",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The provided code correctly checks if the string is a palindrome.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the palindrome checking function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "Write a recursive function in Java to calculate the sum of all elements in an integer array.",
    code: "public int arraySum(int[] arr, int index) {\n    if (index < 0)\n        return 0;\n    else\n        return arr[index] + arraySum(arr, index - 1);\n}",
    answers: [
      "The provided code correctly calculates the sum of all elements in an integer array.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the array sum function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles negative index correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.42,
    question:
      "Implement a recursive function in Java to find the greatest common divisor (GCD) of two integers.",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The provided code correctly calculates the greatest common divisor (GCD) of two integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the GCD calculation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.48,
    question:
      "Write a recursive function in Java to check if a given string is a palindrome.",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The provided code correctly checks if the string is a palindrome.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the palindrome checking function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.53,
    question:
      "Implement a recursive function in Java to find the length of the longest increasing subsequence in an array of integers.",
    code: "public int longestIncreasingSubsequence(int[] arr, int index, int prev) {\n    if (index == arr.length)\n        return 0;\n    int include = 0;\n    if (arr[index] > prev)\n        include = 1 + longestIncreasingSubsequence(arr, index + 1, arr[index]);",
    answers: [
      "The provided code correctly calculates the length of the longest increasing subsequence.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the longest increasing subsequence function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.57,
    question: "Write a recursive function in Java to merge two sorted arrays.",
    code: "public int[] mergeSortedArrays(int[] arr1, int[] arr2, int index1, int index2) {\n    if (index1 == arr1.length)\n        return arr2;\n    else if (index2 == arr2.length)\n        return arr1;\n    int[] merged = new int[arr1.length + arr2.length];\n    if (arr1[index1] < arr2[index2]) {\n        merged[index1 + index2] = arr1[index1];\n        return mergeSortedArrays(arr1, arr2, index1 + 1, index2);\n    }",
    answers: [
      "The provided code correctly merges two sorted arrays.",
      "The provided code contains syntax errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the array merging function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base cases correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Write a recursive function in Java to generate all permutations of a given array of integers.",
    code: "public void generatePermutations(int[] arr, int start, List<List<Integer>> result) {\n    if (start == arr.length) {\n        List<Integer> permutation = new ArrayList<>();\n        for (int num : arr) {\n            permutation.add(num);\n        }\n        result.add(permutation);\n        return;\n    }\n    for (int i = start; i < arr.length; i++) {\n        swap(arr, start, i);\n        generatePermutations(arr, start + 1, result);\n        swap(arr, start, i);\n    }\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}",
    answers: [
      "The provided code correctly generates all permutations of the given array of integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the permutation generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.45,
    question:
      "Implement a recursive function in Java to generate all possible combinations of a given string.",
    code: "public void generateCombinations(String s, int index, String current, List<String> result) {\n    if (index == s.length()) {\n        result.add(current);\n        return;\n    }\n    generateCombinations(s, index + 1, current + s.charAt(index), result);\n    generateCombinations(s, index + 1, current, result);\n}",
    answers: [
      "The provided code correctly generates all possible combinations of the given string.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large strings.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the combination generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Write a recursive function in Java to generate all possible subsets of a given set.",
    code: "public void generateSubsets(int[] nums, int index, List<Integer> subset, List<List<Integer>> result) {\n    if (index == nums.length) {\n        result.add(new ArrayList<>(subset));\n        return;\n    }\n    subset.add(nums[index]);\n    generateSubsets(nums, index + 1, subset, result);\n    subset.remove(subset.size() - 1);\n    generateSubsets(nums, index + 1, subset, result);\n}",
    answers: [
      "The provided code correctly generates all subsets of the given set.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty sets.",
      "The provided code will result in a stack overflow for large sets.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the subset generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 150,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Implement a recursive function in Java to generate all valid parentheses combinations for a given n.",
    code: "public void generateParentheses(int n, int open, int close, String current, List<String> result) {\n    if (current.length() == 2 * n) {\n        result.add(current);\n        return;\n    }\n    if (open < n)\n        generateParentheses(n, open + 1, close, current + '(', result);\n    if (close < open)\n        generateParentheses(n, open, close + 1, current + ')', result);\n}",
    answers: [
      "The provided code correctly generates all valid parentheses combinations for a given n.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty input.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the parentheses generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 150,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "Analyzing the given Java code snippet, what is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.42,
    question:
      "Analyze the given Java code snippet. What will happen if the input value for the recursive function is negative?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: [
      "The function will return 1 for negative input values.",
      "The function will result in a stack overflow due to infinite recursion.",
      "The function will throw an exception.",
      "The function will return -1 for negative input values.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly handles negative input values by returning 1 for such cases.",
      "This is incorrect because the function handles negative input values appropriately.",
      "This is incorrect because the function does not throw any exception for negative input values.",
      "This is incorrect because the function returns 1, not -1, for negative input values.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.47,
    question:
      "Analyze the given Java code snippet. What is the base case for the recursive function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The base case is when the length of the string is less than or equal to 1.",
      "The base case is when the length of the string is exactly 1.",
      "The base case is when the length of the string is exactly 2.",
      "The base case is when the string is empty.",
    ],
    correct: 0,
    explanations: [
      "The base case is correctly identified as when the length of the string is less than or equal to 1, indicating either an empty string or a single-character string.",
      "This is incorrect because the base case also includes empty strings.",
      "This is incorrect because the base case includes strings of length 1.",
      "This is incorrect because the base case includes strings of length 1 and empty strings.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.51,
    question:
      "Analyze the given Java code snippet. What is the purpose of the recursive function?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The purpose is to calculate the greatest common divisor (GCD) of two integers.",
      "The purpose is to calculate the least common multiple (LCM) of two integers.",
      "The purpose is to calculate the factorial of a given integer.",
      "The purpose is to find the nth term of the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The purpose of the provided code is correctly identified as calculating the greatest common divisor (GCD) of two integers.",
      "This is incorrect because the function is not related to calculating the least common multiple (LCM).",
      "This is incorrect because the function is not related to calculating factorials.",
      "This is incorrect because the function is not related to finding Fibonacci numbers.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.56,
    question:
      "Analyze the given Java code snippet. What is the purpose of the recursive function?",
    code: "public void reverseArray(int[] arr, int start, int end) {\n    if (start >= end)\n        return;\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);\n}",
    answers: [
      "The purpose is to reverse an array in-place.",
      "The purpose is to sort an array in ascending order.",
      "The purpose is to compute the factorial of a given number.",
      "The purpose is to find the nth term of the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The purpose of the provided code is correctly identified as reversing an array in-place using recursion.",
      "This is incorrect because the function is not related to sorting arrays.",
      "This is incorrect because the function is not related to calculating factorials.",
      "This is incorrect because the function is not related to finding Fibonacci numbers.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.75,
    question:
      "Analyze the given Java code snippet. What is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.78,
    question:
      "Analyze the given Java code snippet. What is the space complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code utilizes O(n) space complexity due to the recursive function calls being stored in the call stack until reaching the base case.",
      "This is incorrect because the space complexity is linear.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question:
      "Analyze the given Java code snippet. How many recursive calls are made by the function for an input of size n?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The number of recursive calls is logarithmic in the input size n.",
      "The number of recursive calls is linear in the input size n.",
      "The number of recursive calls is constant for all input sizes.",
      "The number of recursive calls is exponential in the input size n.",
    ],
    correct: 0,
    explanations: [
      "The number of recursive calls made by the provided code is logarithmic in the input size n, as it reduces the problem size by approximately half with each recursive call.",
      "This is incorrect because the number of recursive calls is not linear.",
      "This is incorrect because the number of recursive calls varies with the input size.",
      "This is incorrect because the number of recursive calls is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.82,
    question:
      "Analyze the given Java code snippet. What is the worst-case time complexity of the function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: ["O(n)", "O(log n)", "O(n^2)", "O(2^n)"],
    correct: 0,
    explanations: [
      "The worst-case time complexity of the provided code is linear, as it iterates through half of the characters in the string to check for palindromicity.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
      "This is incorrect because the time complexity is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.85,
    question:
      "Analyze the given Java code snippet. What is the space complexity of the function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The space complexity of the provided code is linear, as it requires additional memory proportional to the input size to store intermediate results in the call stack.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.88,
    question:
      "Analyze the given Java code snippet. What is the time complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The time complexity of the provided code is linear, as the recursive function is called n times until reaching the base case.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not constant.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.85,
    question:
      "Analyze the provided Java code snippet. What is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.88,
    question:
      "Analyze the provided Java code snippet. What is the space complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code utilizes O(n) space complexity due to the recursive function calls being stored in the call stack until reaching the base case.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.87,
    question:
      "Analyze the provided Java code snippet. How many recursive calls are made by the function for an input of size n?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The number of recursive calls is logarithmic in the input size n.",
      "The number of recursive calls is linear in the input size n.",
      "The number of recursive calls is constant for all input sizes.",
      "The number of recursive calls is exponential in the input size n.",
    ],
    correct: 0,
    explanations: [
      "The number of recursive calls made by the provided code is logarithmic in the input size n, as it reduces the problem size by approximately half with each recursive call.",
      "This is incorrect because the number of recursive calls is not linear.",
      "This is incorrect because the number of recursive calls varies with the input size.",
      "This is incorrect because the number of recursive calls is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.89,
    question:
      "Analyze the provided Java code snippet. What is the worst-case time complexity of the function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: ["O(n)", "O(log n)", "O(n^2)", "O(2^n)"],
    correct: 0,
    explanations: [
      "The worst-case time complexity of the provided code is linear, as it iterates through half of the characters in the string to check for palindromicity.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
      "This is incorrect because the time complexity is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.86,
    question:
      "Analyze the provided Java code snippet. What is the space complexity of the function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The space complexity of the provided code is linear, as it requires additional memory proportional to the input size to store intermediate results in the call stack.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.87,
    question:
      "Analyze the provided Java code snippet. What is the time complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The time complexity of the provided code is linear, as the recursive function is called n times until reaching the base case.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not constant.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.92,
    question:
      "Analyze the following Java code snippet. What is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.94,
    question:
      "Analyze the following Java code snippet. What is the space complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code utilizes O(n) space complexity due to the recursive function calls being stored in the call stack until reaching the base case.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.93,
    question:
      "Analyze the following Java code snippet. How many recursive calls are made by the function for an input of size n?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The number of recursive calls is logarithmic in the input size n.",
      "The number of recursive calls is linear in the input size n.",
      "The number of recursive calls is constant for all input sizes.",
      "The number of recursive calls is exponential in the input size n.",
    ],
    correct: 0,
    explanations: [
      "The number of recursive calls made by the provided code is logarithmic in the input size n, as it reduces the problem size by approximately half with each recursive call.",
      "This is incorrect because the number of recursive calls is not linear.",
      "This is incorrect because the number of recursive calls varies with the input size.",
      "This is incorrect because the number of recursive calls is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.95,
    question:
      "Analyze the following Java code snippet. What is the worst-case time complexity of the function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: ["O(n)", "O(log n)", "O(n^2)", "O(2^n)"],
    correct: 0,
    explanations: [
      "The worst-case time complexity of the provided code is linear, as it iterates through half of the characters in the string to check for palindromicity.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
      "This is incorrect because the time complexity is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.91,
    question:
      "Analyze the following Java code snippet. What is the space complexity of the function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The space complexity of the provided code is linear, as it requires additional memory proportional to the input size to store intermediate results in the call stack.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.92,
    question:
      "Analyze the following Java code snippet. What is the time complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The time complexity of the provided code is linear, as the recursive function is called n times until reaching the base case.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not constant.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.85,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(5));",
    answers: ["120", "24", "720", "5040"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 5, which equals 120.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.88,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 4?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(4));",
    answers: ["3", "5", "8", "13"],
    correct: 0,
    explanations: [
      "The function computes the 4th Fibonacci number, which is 3.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.86,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 3?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}\n\nSystem.out.println(gcd(12, 8));",
    answers: ["4", "8", "12", "24"],
    correct: 0,
    explanations: [
      "The function computes the greatest common divisor of 12 and 8, which is 4.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.9,
    question:
      'Evaluate the given Java code snippet. What will be the output of the function call for input "racecar"?',
    code: 'public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}\n\nSystem.out.println(isPalindrome("racecar"));',
    answers: ["true", "false", "Error", "racecar"],
    correct: 0,
    explanations: [
      "The function checks if the input string is a palindrome, which it is, so the output is true.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.92,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 3?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(3));",
    answers: ["2", "3", "5", "8"],
    correct: 0,
    explanations: [
      "The function computes the 3rd Fibonacci number, which is 2.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.94,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(5));",
    answers: ["120", "24", "720", "5040"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 5, which equals 120.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "Evaluate the following Java code snippet. What will be the output of the function call for input 3?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(3));",
    answers: ["6", "3", "9", "12"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 3, which equals 6.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 4?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(4));",
    answers: ["3", "5", "8", "13"],
    correct: 0,
    explanations: [
      "The function computes the 4th Fibonacci number, which is 3.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.65,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}\n\nSystem.out.println(gcd(12, 8));",
    answers: ["4", "8", "12", "24"],
    correct: 0,
    explanations: [
      "The function computes the greatest common divisor of 12 and 8, which is 4.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      'Evaluate the given Java code snippet. What will be the output of the function call for input "racecar"?',
    code: 'public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}\n\nSystem.out.println(isPalindrome("racecar"));',
    answers: ["true", "false", "Error", "racecar"],
    correct: 0,
    explanations: [
      "The function checks if the input string is a palindrome, which it is, so the output is true.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 3?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(3));",
    answers: ["2", "3", "5", "8"],
    correct: 0,
    explanations: [
      "The function computes the 3rd Fibonacci number, which is 2.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(5));",
    answers: ["120", "24", "720", "5040"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 5, which equals 120.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following recursive function in Java:\n\n```\npublic int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n```\n\nWhat is the base case of this function?",
    answers: ["n == 0", "n == 1", "n <= 1", "n <= 0"],
    correct: 0,
    explanations: [
      "The base case of the factorial function is when n equals 0, as it returns 1.",
      "This is incorrect. The base case is when n equals 0, not 1.",
      "This is incorrect. The base case is when n equals 0, not when n is less than or equal to 1.",
      "This is incorrect. The base case is when n equals 0, not when n is less than or equal to 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the purpose of a base case in a recursive function?",
    answers: [
      "To provide a termination condition for the recursion.",
      "To increase the efficiency of the function.",
      "To allow the function to handle larger inputs.",
      "To reduce the memory usage of the function.",
    ],
    correct: 0,
    explanations: [
      "The base case provides a termination condition for the recursion, ensuring that the function stops calling itself recursively.",
      "This is incorrect. The base case does not directly affect the efficiency of the function.",
      "This is incorrect. The base case does not affect the input size the function can handle.",
      "This is incorrect. The base case does not directly affect the memory usage of the function.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What happens if a recursive function does not have a base case?",
    answers: [
      "It will result in infinite recursion.",
      "It will terminate immediately.",
      "It will return an error.",
      "It will execute only once.",
    ],
    correct: 0,
    explanations: [
      "Without a base case, the recursive function will continue to call itself indefinitely, resulting in infinite recursion.",
      "This is incorrect. Without a base case, the function does not terminate immediately.",
      "This is incorrect. Without a base case, the function does not necessarily return an error.",
      "This is incorrect. Without a base case, the function does not necessarily execute only once.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "In a recursive function, what is typically done in the recursive step?",
    answers: [
      "The function calls itself with a modified input.",
      "The function returns the result immediately.",
      "The function performs an iterative loop.",
      "The function evaluates the base case.",
    ],
    correct: 0,
    explanations: [
      "In the recursive step, the function calls itself with a modified input, moving towards the base case.",
      "This is incorrect. The recursive step involves calling the function itself again, not returning the result immediately.",
      "This is incorrect. Recursive functions do not typically involve iterative loops within the function.",
      "This is incorrect. The recursive step is separate from evaluating the base case.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "What is the significance of the stack in recursive function execution?",
    answers: [
      "It keeps track of function calls and their local variables.",
      "It stores the base case of the function.",
      "It ensures that the function always returns a value.",
      "It manages the iteration of the recursive function.",
    ],
    correct: 0,
    explanations: [
      "The stack keeps track of function calls and their local variables, allowing for the management of recursive function execution.",
      "This is incorrect. The stack does not store the base case of the function.",
      "This is incorrect. The stack's role is not related to ensuring the function always returns a value.",
      "This is incorrect. The stack's role is not related to managing the iteration of the recursive function.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "What does it mean if a recursive function exhibits tail recursion?",
    answers: [
      "The recursive call is the last operation performed by the function.",
      "The function has multiple base cases.",
      "The function returns a value without any recursive calls.",
      "The function does not have a base case.",
    ],
    correct: 0,
    explanations: [
      "In tail recursion, the recursive call is the last operation performed by the function before returning, optimizing memory usage.",
      "This is incorrect. Tail recursion does not imply having multiple base cases.",
      "This is incorrect. Tail recursion involves recursive calls, not immediate return values.",
      "This is incorrect. Tail recursion still requires a base case.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following statements best describes the concept of recursion?",
    answers: [
      "A function calls itself directly or indirectly in order to solve a problem.",
      "A function repeats a set of instructions for a specified number of times.",
      "A function uses a loop construct to execute a set of instructions.",
      "A function returns a value based on a condition.",
    ],
    correct: 0,
    explanations: [
      "Recursion involves a function calling itself directly or indirectly to solve a problem, often involving smaller instances of the same problem.",
      "This is incorrect. Recursion is not about repeating a set of instructions a specified number of times.",
      "This is incorrect. Recursion does not necessarily involve loop constructs.",
      "This is incorrect. Recursion is not solely based on returning a value based on a condition.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
];
